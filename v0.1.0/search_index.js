var documenterSearchIndex = {"docs":
[{"location":"APIs/#Application-Programming-Interface-(APIs)-1","page":"Home","title":"Application Programming Interface (APIs)","text":"","category":"section"},{"location":"APIs/#","page":"Home","title":"Home","text":"Here, references are provided for ClimateMachine's programming interface. These references aim to describe what functions do, their arguments, what is returned, and the composition of structs.","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Numerics/LinearSolvers/bgmres.jl\"","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#Batched-Generalized-Minimal-Residual-1","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"","category":"section"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"In this tutorial we describe the basics of using the batched gmres iterative solver. At the end you should be able to","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Use BatchedGeneralizedMinimalResidual to solve batches of linear systems\nConstruct a columnwise linear solver with BatchedGeneralizedMinimalResidual","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#What-is-the-Generalized-Minimal-Residual-Method?-1","page":"Batched Generalized Minimal Residual","title":"What is the Generalized Minimal Residual Method?","text":"","category":"section"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The  Generalized Minimal Residual Method (GMRES) is a Krylov subspace method for solving linear systems:","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":" Ax = b","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"See the wikipedia for more details.","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#What-is-the-Batched-Generalized-Minimal-Residual-Method?-1","page":"Batched Generalized Minimal Residual","title":"What is the Batched Generalized Minimal Residual Method?","text":"","category":"section"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"As the name suggests it solves a whole bunch of independent GMRES problems","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#Basic-Example-1","page":"Batched Generalized Minimal Residual","title":"Basic Example","text":"","category":"section"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"First we must load a few things","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"using ClimateMachine,\n    ClimateMachine.LinearSolvers,\n    ClimateMachine.BatchedGeneralizedMinimalResidualSolver\nusing LinearAlgebra, Random, Plots","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Next we define two linear systems that we would like to solve simultaneously. The matrix for the first linear system is","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"A1 = [\n    2.0 -1.0 0.0\n    -1.0 2.0 -1.0\n    0.0 -1.0 2.0\n];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"And the right hand side is","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"b1 = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The exact solution to the first linear system is","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x1_exact = [1.5, 2.0, 1.5];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The matrix for the first linear system is","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"A2 = [\n    2.0 -1.0 0.0\n    0.0 2.0 -1.0\n    0.0 0.0 2.0\n];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"And the right hand side is","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"b2 = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The exact solution to second linear system is","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x2_exact = [0.875, 0.75, 0.5];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We now define a function that performs the action of each linear operator independently.","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"function closure_linear_operator(A1, A2)\n    function linear_operator!(x, y)\n        mul!(view(x, :, 1), A1, view(y, :, 1))\n        mul!(view(x, :, 2), A2, view(y, :, 2))\n        return nothing\n    end\n    return linear_operator!\nend;\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"To understand how this works let us construct an instance of the linear operator and apply it to a vector","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"linear_operator! = closure_linear_operator(A1, A2);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Let us see what the action of this linear operator is","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"y1 = ones(typeof(1.0), 3);\ny2 = ones(typeof(1.0), 3) * 2.0;\ny = [y1 y2];\nx = copy(y);\nlinear_operator!(x, y);\nx","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We see that the first column is A1 * [1 1 1]' and the second column is A2 * [2 2 2]' that is,","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"[A1 * y1 A2 * y2]","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We are now ready to set up our Batched Generalized Minimal Residual solver We must now set up the right hand side of the linear system","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"b = [b1 b2];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"as well as the exact solution, (to verify convergence)","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x_exact = [x1_exact x2_exact];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"warning: Warning\nFor BatchedGeneralizedMinimalResidual the assumption is that each column of b is independent and corresponds to a batch. This will come back later.","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We now use an instance of the solver","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"linearsolver = BatchedGeneralizedMinimalResidual(b);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"As well as an initial guess, denoted by the variable x","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x1 = ones(typeof(1.0), 3);\nx2 = ones(typeof(1.0), 3);\nx = [x1 x2];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"To solve the linear system, we just need to pass to the linearsolve! function","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"iters = linearsolve!(linear_operator!, linearsolver, x, b)","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"which is guaranteed to converge in 3 iterations since length(b1)=length(b2)=3 We can now check that the solution that we computed, x","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"has converged to the exact solution","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x_exact","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Which indeed it has.","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#Advanced-Example-1","page":"Batched Generalized Minimal Residual","title":"Advanced Example","text":"","category":"section"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We now go through a more advanced application of the Batched Generalized Minimal Residual solver","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"warning: Warning\nIterative methods should be used with preconditioners!","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The first thing we do is define a linear operator that mimics the behavior of a columnwise operator in ClimateMachine","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"function closure_linear_operator!(A, tup)\n    function linear_operator!(y, x)\n        alias_x = reshape(x, tup)\n        alias_y = reshape(y, tup)\n        for i6 in 1:tup[6]\n            for i4 in 1:tup[4]\n                for i2 in 1:tup[2]\n                    for i1 in 1:tup[1]\n                        tmp = alias_x[i1, i2, :, i4, :, i6][:]\n                        tmp2 = A[i1, i2, i4, i6] * tmp\n                        alias_y[i1, i2, :, i4, :, i6] .=\n                            reshape(tmp2, (tup[3], tup[5]))\n                    end\n                end\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Next we define the array structure of an MPIStateArray in its true high dimensional form","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"tup = (2, 2, 5, 2, 10, 2);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We define our linear operator as a random matrix","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Random.seed!(1234);\nB = [\n    randn(tup[3] * tup[5], tup[3] * tup[5])\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\ncolumnwise_A = [\n    B[i1, i2, i4, i6] + 3 * (i1 + i2 + i4 + i6) * I\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"as well as its inverse","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"columnwise_inv_A = [\n    inv(columnwise_A[i1, i2, i4, i6])\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\ncolumnwise_linear_operator! = closure_linear_operator!(columnwise_A, tup);\ncolumnwise_inverse_linear_operator! =\n    closure_linear_operator!(columnwise_inv_A, tup);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The structure of an MPIStateArray is related to its true higher dimensional form as follows:","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"mpi_tup = (tup[1] * tup[2] * tup[3], tup[4], tup[5] * tup[6]);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We now define the right hand side of our Linear system","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"b = randn(mpi_tup);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"As well as the initial guess","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x = copy(b);\nx += randn(mpi_tup) * 0.1;\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"In the previous tutorial we mentioned that it is assumed that the right hand side is an array whose column vectors all independent linear systems. But right now the array structure of x and b do not follow this requirement. To handle this case we must pass in additional arguments that tell the linear solver how to reconcile these differences. The first thing that the linear solver must know of is the higher tensor form of the MPIStateArray, which is just the tup from before","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"reshape_tuple_f = tup;\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"The second thing it needs to know is which indices correspond to a column and we want to make sure that these are the first set of indices that appear in the permutation tuple (which can be thought of as enacting a Tensor Transpose).","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"permute_tuple_f = (5, 3, 4, 6, 1, 2);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"It has this format since the 3 and 5 index slots are the ones associated with traversing a column. And the 4 index slot corresponds to a state. We also need to tell our solver which kind of Array struct to use","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"ArrayType = Array;\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We are now ready to finally define our linear solver, which uses a number of keyword arguments","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"gmres = BatchedGeneralizedMinimalResidual(\n    b,\n    ArrayType = ArrayType,\n    m = tup[3] * tup[5] * tup[4],\n    n = tup[1] * tup[2] * tup[6],\n    reshape_tuple_f = reshape_tuple_f,\n    permute_tuple_f = permute_tuple_f,\n    atol = eps(Float64) * 10^2,\n    rtol = eps(Float64) * 10^2,\n);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"m is the number of gridpoints along a column. As mentioned previously, this is tup[3]*tup[5]*tup[4]. The n term corresponds to the batch size or the number of columns in this case. atol and rtol are relative and absolute tolerances","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"All the hard work is done, now we just call our linear solver","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"iters = linearsolve!(\n    columnwise_linear_operator!,\n    gmres,\n    x,\n    b,\n    max_iters = tup[3] * tup[5] * tup[4],\n)","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"We see that it converged in less than tup[3]*tup[5] = 50 iterations. Let us verify that it is indeed correct by computing the exact answer numerically and comparing it against the iterative solver.","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"x_exact = copy(x);\ncolumnwise_inverse_linear_operator!(x_exact, b);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Now we can compare with some norms","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"norm(x - x_exact) / norm(x_exact)\ncolumnwise_linear_operator!(x_exact, x);\nnorm(x_exact - b) / norm(b)","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"Which we see are small, given our choice of atol and rtol. The struct also keeps a record of its convergence rate in the residual member. The convergence rate of each column can be visualized via","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"plot(log.(gmres.residual[1:iters, :]) / log(10));\nplot!(legend = false, xlims = (1, iters), ylims = (-15, 2));\nplot!(ylabel = \"log10 residual\", xlabel = \"iterations\")","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"","category":"page"},{"location":"generated/Numerics/LinearSolvers/bgmres/#","page":"Batched Generalized Minimal Residual","title":"Batched Generalized Minimal Residual","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#Surface-Fluxes-1","page":"SurfaceFluxes","title":"Surface Fluxes","text":"","category":"section"},{"location":"Theory/Common/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Surface flux functions, e.g. for buoyancy flux, friction velocity, and exchange coefficients.","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#Byun1990-1","page":"SurfaceFluxes","title":"Byun1990","text":"","category":"section"},{"location":"Theory/Common/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Compute surface fluxes using the approach in Byun (1990).","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#Plots-1","page":"SurfaceFluxes","title":"Plots","text":"","category":"section"},{"location":"Theory/Common/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"using ClimateMachine.SurfaceFluxes.Byun1990\nusing Plots, LaTeXStrings\nusing CLIMAParameters\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nparam_set = EarthParameterSet()\n\nFT = Float64\nRi_range = range(FT(-1.2), stop = FT(0.24), length = 100)\nscales = FT[50, 200, 600, 1000, 10_000]\n\nz_0 = FT(1.0)\nγ_m, γ_h = FT(15.0), FT(9.0)\nβ_m, β_h = FT(4.8), FT(7.8)\nPr_0 = FT(0.74)\n\nplot(Ri_range,\n     [Byun1990.compute_exchange_coefficients(param_set, Ri, scale * z_0, z_0,\n                                             γ_m, γ_h, β_m, β_h, Pr_0)[1]\n        for Ri in Ri_range, scale in scales],\n     xlabel = \"Bulk Richardson number (Ri_b)\",\n     ylabel = \"Drag coefficient\",\n     title = \"Momentum exchange coefficient\",\n     labels = scales, legendtitle=L\"z/z_0\")\n\nsavefig(\"exchange_byun1990_fig4a.svg\") # hide\nnothing # hide","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Recreation of Figure 4(a) from Byun (1990)","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"plot(Ri_range,\n     [Byun1990.compute_exchange_coefficients(param_set, Ri, scale * z_0, z_0,\n                                             γ_m, γ_h, β_m, β_h, Pr_0)[2]\n        for Ri in Ri_range, scale in scales],\n     xlabel = \"Bulk Richardson number (Ri_b)\",\n     ylabel = \"Exchange coefficient\",\n     title = \"Heat exchange coefficient\",\n     labels = scales, legendtitle=L\"z/z_0\")\n\nsavefig(\"exchange_byun1990_fig4b.svg\") # hide\nnothing # hide","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Recreation of Figure 4(b) from Byun (1990)","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#Nishizawa2018-1","page":"SurfaceFluxes","title":"Nishizawa2018","text":"","category":"section"},{"location":"Theory/Common/SurfaceFluxes/#Plots-2","page":"SurfaceFluxes","title":"Plots","text":"","category":"section"},{"location":"Theory/Common/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"using ClimateMachine.SurfaceFluxes.Nishizawa2018\nusing Plots, LaTeXStrings\nusing CLIMAParameters\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nparam_set = EarthParameterSet()\n\nFT = Float64\n\na = FT(4.7)\nθ = FT(350)\nz_0 = FT(10)\nu_ave = FT(10)\nflux = FT(1)\nΔz = range(FT(10.0), stop=FT(100.0), length=100)\nΨ_m_tol, tol_abs, iter_max = FT(1e-3), FT(1e-3), 10\n\nu_star = Nishizawa2018.compute_friction_velocity.(\n    Ref(param_set),\n    u_ave, θ, flux, Δz, z_0, a, Ψ_m_tol, tol_abs, iter_max)\n\nplot(u_star, Δz, title = \"Friction velocity vs dz\",\n     xlabel = \"Friction velocity\", ylabel = \"dz\")\n\nsavefig(\"friction_velocity.svg\") # hide\nnothing # hide","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Theory/Common/SurfaceFluxes/#References-1","page":"SurfaceFluxes","title":"References","text":"","category":"section"},{"location":"Theory/Common/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Businger, Joost A., et al. \"Flux-profile relationships in the atmospheric surface layer.\" Journal of the atmospheric Sciences 28.2 (1971): 181-189. doi: 10.1175/1520-0469(1971)028<0181:FPRITA>2.0.CO;2\nNishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin-Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175. doi: 10.1029/2018MS001534\nByun, Daewon W. \"On the analytical solutions of flux-profile relationships for the atmospheric surface layer.\" Journal of Applied Meteorology 29.7 (1990): 652-657. doi: 10.1175/1520-0450(1990)029<0652:OTASOF>2.0.CO;2\nWyngaard, John C. \"Modeling the planetary boundary layer-Extension to the stable case.\" Boundary-Layer Meteorology 9.4 (1975): 441-460. doi: 10.1007/BF00223393","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Numerics/DGmethods/nonnegative.jl\"","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"This tutorial uses the TMAR Filter from","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"@article{doi:10.1175/MWR-D-16-0220.1,      author = {Light, Devin and Durran, Dale},      title = {Preserving Nonnegativity in Discontinuous Galerkin               Approximations to Scalar Transport via Truncation and Mass               Aware Rescaling (TMAR)},      journal = {Monthly Weather Review},      volume = {144},      number = {12},      pages = {4771-4786},      year = {2016},      doi = {10.1175/MWR-D-16-0220.1},    }","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"to reproduce the tutorial in section 4b.  It is a shear swirling flow deformation of a transported quantity from LeVeque 1996.  The exact solution at the final time is the same as the initial condition.","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"using MPI\nusing Test\nusing ClimateMachine\nClimateMachine.init()\nusing Logging\nusing ClimateMachine.Mesh.Topologies\nusing ClimateMachine.Mesh.Grids\nusing ClimateMachine.Mesh.Filters\nusing ClimateMachine.DGmethods\nusing ClimateMachine.DGmethods.NumericalFluxes\nusing ClimateMachine.MPIStateArrays\nusing ClimateMachine.ODESolvers\nusing LinearAlgebra\nusing Printf\nusing Dates\nusing ClimateMachine.GenericCallbacks:\n    EveryXWallTimeSeconds, EveryXSimulationSteps\nusing ClimateMachine.VTK: writevtk, writepvtu\n\ninclude(joinpath(\n    @__DIR__,\n    \"..\",\n    \"..\",\n    \"..\",\n    \"test\",\n    \"Numerics\",\n    \"DGmethods\",\n    \"advection_diffusion\",\n    \"advection_diffusion_model.jl\",\n))\n\nBase.@kwdef struct SwirlingFlow{FT} <: AdvectionDiffusionProblem\n    period::FT = 5\nend\n\ninit_velocity_diffusion!(::SwirlingFlow, aux::Vars, geom::LocalGeometry) =\n    nothing\n\ncosbell(τ, q) = τ ≤ 1 ? ((1 + cospi(τ)) / 2)^q : zero(τ)\n\nfunction initial_condition!(::SwirlingFlow, state, aux, coord, t)\n    FT = eltype(state)\n    x, y, _ = aux.coord\n    x0, y0 = FT(1 // 4), FT(1 // 4)\n    τ = 4 * hypot(x - x0, y - y0)\n    state.ρ = cosbell(τ, 3)\nend\n\nhas_variable_coefficients(::SwirlingFlow) = true\nfunction update_velocity_diffusion!(\n    problem::SwirlingFlow,\n    ::AdvectionDiffusion,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    x, y, _ = aux.coord\n    sx, cx = sinpi(x), cospi(x)\n    sy, cy = sinpi(y), cospi(y)\n    ct = cospi(t / problem.period)\n\n    u = 2 * sx^2 * sy * cy * ct\n    v = -2 * sy^2 * sx * cx * ct\n    aux.u = SVector(u, v, 0)\nend\n\nfunction do_output(mpicomm, vtkdir, vtkstep, dg, Q, model, testname)\n    # name of the file that this MPI rank will write\n    filename = @sprintf(\n        \"%s/%s_mpirank%04d_step%04d\",\n        vtkdir,\n        testname,\n        MPI.Comm_rank(mpicomm),\n        vtkstep\n    )\n\n    statenames = flattenednames(vars_state_conservative(model, eltype(Q)))\n\n    writevtk(filename, Q, dg, statenames)\n\n    # generate the pvtu file for these vtk files\n    if MPI.Comm_rank(mpicomm) == 0\n        # name of the pvtu file\n        pvtuprefix = @sprintf(\"%s/%s_step%04d\", vtkdir, testname, vtkstep)\n\n        # name of each of the ranks vtk files\n        prefixes = ntuple(MPI.Comm_size(mpicomm)) do i\n            @sprintf(\"%s_mpirank%04d_step%04d\", testname, i - 1, vtkstep)\n        end\n\n        writepvtu(pvtuprefix, prefixes, statenames)\n\n        @info \"Done writing VTK: $pvtuprefix\"\n    end\nend\n\nfunction run(\n    mpicomm,\n    ArrayType,\n    topl,\n    problem,\n    dt,\n    N,\n    timeend,\n    FT,\n    vtkdir,\n    outputtime,\n)\n    grid = DiscontinuousSpectralElementGrid(\n        topl,\n        FloatType = FT,\n        DeviceArray = ArrayType,\n        polynomialorder = N,\n    )\n\n    model = AdvectionDiffusion{2, false, true}(problem)\n\n    dg = DGModel(\n        model,\n        grid,\n        UpwindNumericalFlux(),\n        CentralNumericalFluxSecondOrder(),\n        CentralNumericalFluxGradient(),\n    )\n\n    Q = init_ode_state(dg, FT(0))\n\n    initialsumQ = weightedsum(Q)","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"We integrate so that the final solution is equal to the initial solution","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"    Qe = copy(Q)\n\n    rhs! = function (dQdt, Q, ::Nothing, t; increment = false)\n        Filters.apply!(Q, 1, grid, TMARFilter())\n        dg(dQdt, Q, nothing, t; increment = false)\n    end\n\n    odesolver = SSPRK33ShuOsher(rhs!, Q; dt = dt, t0 = 0)\n\n    cbTMAR = EveryXSimulationSteps(1) do\n        Filters.apply!(Q, 1, grid, TMARFilter())\n    end","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"create output directory on first rank of communicator","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"    if MPI.Comm_rank(mpicomm) == 0\n        mkpath(vtkdir)\n    end\n    MPI.Barrier(mpicomm)\n\n    vtkstep = 0","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"output initial step","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"    do_output(mpicomm, vtkdir, vtkstep, dg, Q, model, \"nonnegative\")","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"setup the output callback","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"    cbvtk = EveryXSimulationSteps(floor(outputtime / dt)) do\n        vtkstep += 1\n        minQ, maxQ = minimum(Q), maximum(Q)\n        sumQ = weightedsum(Q)\n\n        sumerror = (initialsumQ - sumQ) / initialsumQ\n\n        @info @sprintf \"\"\"Step  = %d\n          minimum(Q)  = %.16e\n          maximum(Q)  = %.16e\n          sum error   = %.16e\n          \"\"\" vtkstep minQ maxQ sumerror\n\n        do_output(mpicomm, vtkdir, vtkstep, dg, Q, model, \"nonnegative\")\n    end\n\n    callbacks = (cbTMAR, cbvtk)\n    solve!(Q, odesolver; timeend = timeend, callbacks = callbacks)\n\n    minQ, maxQ = minimum(Q), maximum(Q)\n    finalsumQ = weightedsum(Q)\n    sumerror = (initialsumQ - finalsumQ) / initialsumQ\n    error = euclidean_distance(Q, Qe)\n\n    @test minQ ≥ 0\n\n    @info @sprintf \"\"\"Finished\n    minimum(Q) = %.16e\n    maximum(Q) = %.16e\n    L2 error   = %.16e\n    sum error  = %.16e\n    \"\"\" minQ maxQ error sumerror\nend\n\nlet\n    ArrayType = ClimateMachine.array_type()\n\n    mpicomm = MPI.COMM_WORLD\n\n    FT = Float64\n    dim = 2\n    Ne = 20\n    polynomialorder = 4\n\n    problem = SwirlingFlow()\n\n    brickrange = (\n        range(FT(0); length = Ne + 1, stop = 1),\n        range(FT(0); length = Ne + 1, stop = 1),\n        range(FT(0); length = Ne + 1, stop = 1),\n    )\n\n    topology = BrickTopology(\n        mpicomm,\n        brickrange[1:dim],\n        boundary = ntuple(d -> (3, 3), dim),\n    )\n\n    maxvelocity = 2\n    elementsize = 1 / Ne\n    dx = elementsize / polynomialorder^2\n    CFL = 1\n    dt = CFL * dx / maxvelocity\n\n    vtkdir =\n        abspath(joinpath(ClimateMachine.Settings.output_dir, \"vtk_nonnegative\"))\n    outputtime = 0.0625\n    dt = outputtime / ceil(Int64, outputtime / dt)\n\n    timeend = problem.period\n\n    @info @sprintf \"\"\"Starting\n    FT               = %s\n    dim              = %d\n    Ne               = %d\n    polynomial order = %d\n    final time       = %.16e\n    time step        = %.16e\n    \"\"\" FT dim Ne polynomialorder timeend dt\n\n    run(\n        mpicomm,\n        ArrayType,\n        topology,\n        problem,\n        dt,\n        polynomialorder,\n        timeend,\n        FT,\n        vtkdir,\n        outputtime,\n    )\nend","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"","category":"page"},{"location":"generated/Numerics/DGmethods/nonnegative/#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"DevDocs/CodeStyle/#Coding-conventions-1","page":"Coding style","title":"Coding conventions","text":"","category":"section"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"For the most part, we follow the YASGuide. Some key considerations:","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"Limit use of Unicode as described in AcceptableUnicode.\nModules and struct names should follow TitleCase convention.\nFunction names should be lowercase with words separated by underscores as necessary to improve readability.\nVariable names follow the format used in the Variable List. In addition, follow CMIP conventions where possible and practicable.\nDocument design and purpose rather than mechanics and implementation (document interfaces and embed documentation in code).\nAvoid variable names that coincide with module and struct names, as well as function/variable names that are natively supported.\nNever use the characters l (lowercase letter 'el'), O (uppercase letter 'oh'), or I (uppercase letter 'eye') as single character variable names.\nTry to limit all lines to a maximum of 78 characters.\nimport/using should be grouped in the following order:\nStandard library imports.\nRelated third party imports.\nLocal application/library specific imports.\nUse a blank line between each group of imports.","category":"page"},{"location":"DevDocs/CodeStyle/#Use-JuliaFormatter-1","page":"Coding style","title":"Use JuliaFormatter","text":"","category":"section"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"Once you are happy with your PR, apply our JuliaFormatter.jl settings to all changed files in the repository from the top-level ClimateMachine directory:","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"julia .dev/climaformat.jl <list of changed files>","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"This is easiest done by installing our formatting githook.","category":"page"},{"location":"DevDocs/CodeStyle/#Formatting-githook-1","page":"Coding style","title":"Formatting githook","text":"","category":"section"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"A pre-commit script can be placed in $GIT_DIR/hooks/* which will prevent commits of incorrectly formatted Julia code.  It will also provide instructions on how to format the code correctly.","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"Install the script with:","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"$ ln -s ../../.dev/hooks/pre-commit .git/hooks","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"Then, when you run git commit, an error message will be shown for staged Julia files that are not formatted correctly. For example, if you try to commit changes to src/Arrays/MPIStateArrays.jl that are not formatted correctly:","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"❯ git commit                                                                                                           │\nActivating environment at `~/research/code/ClimateMachine.jl/.dev/Project.toml`                                        │\n┌ Error: File src/Arrays/MPIStateArrays.jl needs to be indented with:                                                  │\n│     julia /home/lucas/research/code/ClimateMachine.jl/.dev/climaformat.jl /home/lucas/research/code/ClimateMachine.jl│\n/src/Arrays/MPIStateArrays.jl                                                                                          │\n│ and added to the git index via                                                                                       │\n│     git add /home/lucas/research/code/ClimateMachine.jl/src/Arrays/MPIStateArrays.jl                                 │\n└ @ Main ~/research/code/ClimateMachine.jl/.git/hooks/pre-commit:30","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"Learn more about git hooks.","category":"page"},{"location":"DevDocs/CodeStyle/#Precompiling-JuliaFormatter-1","page":"Coding style","title":"Precompiling JuliaFormatter","text":"","category":"section"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"To speed up the formatter and the githook, a custom system image can be built with the [PackageCompiler]. That said, the following [drawback] from the PackageCompiler repository should be noted:","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"It should be clearly stated that there are some drawbacks to using a custom sysimage, thereby sidestepping the standard Julia package precompilation system. The biggest drawback is that packages that are compiled into a sysimage (including their dependencies!) are \"locked\" to the version they where at when the sysimage was created. This means that no matter what package version you have installed in your current project, the one in the sysimage will take precedence. This can lead to bugs where you start with a project that needs a specific version of a package, but you have another one compiled into the sysimage.","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"The PackageCompiler compiler can be used with JuliaFormatter using the following commands (from the top-level directory of a clone of ClimateMachine):","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"$ julia -q\njulia> using Pkg\njulia> Pkg.add(\"PackageCompiler\")\njulia> using PackageCompiler\njulia> Pkg.activate(joinpath(@__DIR__, \".dev\"))\njulia> using PackageCompiler\njulia> PackageCompiler.create_sysimage(:JuliaFormatter; precompile_execution_file=joinpath(@__DIR__, \".dev/precompile.jl\"), replace_default=true)","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"If you cannot or do not want to modify the default system image, use the following instead:","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"$ julia -q\njulia> using Pkg\njulia> Pkg.add(\"PackageCompiler\")\njulia> using PackageCompiler\njulia> Pkg.activate(joinpath(@__DIR__, \".dev\"))\njulia> PackageCompiler.create_sysimage(:JuliaFormatter; precompile_execution_file=joinpath(@__DIR__, \".dev/precompile.jl\"), sysimage_path=joinpath(@__DIR__, \".git/hooks/JuliaFormatterSysimage.so\"))","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"In this case, use the pre-commit.sysimage git hook with:","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"$ ln -s ../../.dev/hooks/pre-commit.sysimage .git/hooks/pre-commit","category":"page"},{"location":"DevDocs/CodeStyle/#","page":"Coding style","title":"Coding style","text":"Note: Putting the system image in .git/hooks protects it from calls to git clean -x.","category":"page"},{"location":"Theory/Atmos/Microphysics/#Microphysics-Module-1","page":"Microphysics","title":"Microphysics Module","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The Microphysics module describes warm rain bulk parameterization of cloud microphysical processes. The module describes the warm rain (no ice and snow) formation and is based on the ideas of Kessler 1995.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"Parameterized processes include:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"rain sedimentation with mass weighted average terminal velocity,\ncondensation/evaporation of cloud water,\nautoconversion,\naccretion,\nevaporation of rain water.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The cloud microphysics variables are expressed as specific humidities:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"q_tot - total water specific humidity,\nq_vap - water vapor specific humidity,\nq_liq - liquid water specific humidity,\nq_rai - rain water specific humidity.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"Parameters used in the parameterization are defined in MicrophysicsParameters module. They consist of:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"symbol definition units default value\nn_0_MP rain drop size distribution parameter frac1m^4 16 cdot 10^6\ntau_cond_evap cloud water condensation/evaporation timescale s 10\ntau_acnv cloud to rain water autoconversion timescale s 10^3\nq_liq_threshold cloud to rain water autoconversion threshold - 5 cdot 10^-4\nE_col collision efficiency between rain drops and cloud droplets - 08\nC_drag rain drop drag coefficient - 055\na_vent b_vent rain drop ventilation factor coefficients - 15 , 053\nK_therm thermal conductivity of air fracJm  s  K 24 cdot 10^-2\nnu_air kinematic viscosity of air fracm^2s 16 cdot 10^-5\nD_vapor diffusivity of water vapor fracm^2s 226 cdot 10^-5","category":"page"},{"location":"Theory/Atmos/Microphysics/#Rain-drop-size-distribution-1","page":"Microphysics","title":"Rain drop size distribution","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The rain-drop size distribution is assumed to follow Marshall-Palmer distribution (Marshall Palmer 1948 eq. 1):","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nn(r) = n_0_MP expleft(- lambda_MP  r right)\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"r is the drop radius,\nn_0_MP and lambda_MP are the Marshall-Palmer distribution","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"parameters (twice the values used in the Marshall Palmer 1948, because  we use drop radius and not diameter).","category":"page"},{"location":"Theory/Atmos/Microphysics/#Terminal-velocity-1","page":"Microphysics","title":"Terminal velocity","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The terminal velocity of an individual rain drop is defined by the balance between the gravitational acceleration (taking into account the density difference between water and air) and the drag force:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nv_drop = left(frac83  C_drag left( fracrho_waterrho -1 right) right)^12 (g  r)^12 = v_c(rho)  (g  r)^12\nlabeleqvdrop\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"g is the gravitational acceleration,\nC_drag is the drag coefficient,\nrho_water is the density of water,\nrho is the density of air.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The mass weighted terminal velocity v_t is defined following Ogura and Takahashi 1971","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nv_t = fracF_rainRWC\nlabeleqvt\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"F_rain = int_0^infty n(r)  m(r)  v_drop(r)  dr is the","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"vertical flux of rain drops,","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"RWC = int_0^infty n(r)  m(r)  dr = rho  q_rai is the","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"rain water content.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"Integrating over the assumed Marshall-Palmer distribution results in","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nRWC = frac8 pi  n_0_MP  rho_waterlambda_MP^4\nlabeleqlambda\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nF_rain = Gamma left(frac92 right) frac43 n_0_MP  pi  rho_water v_c(rho)  g^12 (lambda_MP)^-92\nlabeleqfrain\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"Substituting eq.(\\ref{eq:lambda}) and eq.(\\ref{eq:frain}) into eq.(\\ref{eq:vt}) results in:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nv_t = Gamma left( frac92 right)  fracv_c(rho)6  left( fracglambda_MPright)^12\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where lambda_MP is computed as","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"lambda_MP = left( frac8 pi rho_water n_0_MPrho q_rai right)^14","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The default value of C_drag is chosen such that the v_t is close to the empirical terminal velocity formulation in Smolarkiewicz and Grabowski 1996. Assuming a constant drag coefficient is an approximation as it should be size and flow dependent, see drag_coefficient.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"using ClimateMachine.Microphysics\nusing Plots\nusing CLIMAParameters\nusing CLIMAParameters.Atmos.Microphysics\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()\n\n# eq. 5d in Smolarkiewicz and Grabowski 1996\n# https://doi.org/10.1175/1520-0493(1996)124<0487:TTLSLM>2.0.CO;2\nfunction terminal_velocity_empirical(q_rai::DT, q_tot::DT, ρ::DT, ρ_air_ground::DT) where {DT<:Real}\n    rr  = q_rai / (DT(1) - q_tot)\n    vel = DT(14.34) * ρ_air_ground^DT(0.5) * ρ^-DT(0.3654) * rr^DT(0.1346)\n    return vel\nend\n\nq_rain_range = range(1e-8, stop=5e-3, length=100)\nρ_air, q_tot, ρ_air_ground = 1.2, 20 * 1e-3, 1.22\n\nplot(q_rain_range * 1e3,  [terminal_velocity(param_set, q_rai, ρ_air) for q_rai in q_rain_range], xlabel=\"q_rain [g/kg]\", ylabel=\"velocity [m/s]\", title=\"Average terminal velocity of rain\", label=\"ClimateMachine\")\nplot!(q_rain_range * 1e3, [terminal_velocity_empirical(q_rai, q_tot, ρ_air, ρ_air_ground) for q_rai in q_rain_range], label=\"Empirical\")\nsavefig(\"rain_terminal_velocity.svg\") # hide\nnothing # hide","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"(Image: )","category":"page"},{"location":"Theory/Atmos/Microphysics/#Cloud-condensation/evaporation-1","page":"Microphysics","title":"Cloud condensation/evaporation","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"Condensation and evaporation of cloud water is parameterized as a relaxation to equilibrium value at the current time step.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\n  left fracd  q_liqdt right_cond evap = fracq^eq_liq - q_liqtau_cond_evap\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"q^eq_liq - liquid water specific humidity in equilibrium,\nq_liq - liquid water specific humidity,\ntau_cond_evap - relaxation timescale (parameter in","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"MicrophysicsParameters module).","category":"page"},{"location":"Theory/Atmos/Microphysics/#Autoconversion-1","page":"Microphysics","title":"Autoconversion","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"Autoconversion defines the rate of conversion form cloud to rain water due to collisions between cloud droplets. It is parameterized following Kessler 1995:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\n  left fracd  q_raidt right_acnv = fracmax(0 q_liq - q_liq_threshold)tau_acnv\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"q_liq - liquid water specific humidity,\ntau_acnv - timescale (parameter in MicrophysicsParameters","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"module),","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"q_liq_threshold - autoconversion (parameter in","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"MicrophysicsParameters module).","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The default values of tau_acnv and q_liq_threshold are based on Smolarkiewicz and Grabowski 1996.","category":"page"},{"location":"Theory/Atmos/Microphysics/#Accretion-1","page":"Microphysics","title":"Accretion","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"Accretion defines the rate of conversion from cloud to rain water resulting from collisions between cloud droplets and rain drops. It is parameterized following Kessler 1995:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_accr = int_0^infty n(r)  pi r^2  v_drop E_col q_liq dr\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"E_col is the collision efficiency,\nv_drop is defined in eq.(\\ref{eq:vdrop}).","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"Integrating over the distribution and using the RWC to eliminate the lambda_MP results in:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_accr  = Gamma left(frac72 right) pi^18 8^-78 E_col v_c(rho)  left(fracrhorho_waterright)^78 n_0_MP^18 g^12 q_liq q_rai^78 = A(rho)  n_0_MP^18 g^12 q_liq q_rai^78\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The default value of collision efficiency E_coll is set to 0.8 so that the resulting accretion rate is close to the empirical accretion rate in Smolarkiewicz and Grabowski 1996. Assuming a constant E_col is an approximation, see for example collision efficiency.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"using ClimateMachine.Microphysics\nusing Plots\nusing CLIMAParameters\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()\n\n# eq. 5b in Smolarkiewicz and Grabowski 1996\n# https://doi.org/10.1175/1520-0493(1996)124<0487:TTLSLM>2.0.CO;2\nfunction accretion_empirical(q_rai::DT, q_liq::DT, q_tot::DT) where {DT<:Real}\n    rr  = q_rai / (DT(1) - q_tot)\n    rl  = q_liq / (DT(1) - q_tot)\n    return DT(2.2) * rl * rr^DT(7/8)\nend\n\n# some example values\nq_rain_range = range(1e-8, stop=5e-3, length=100)\nρ_air, q_liq, q_tot = 1.2, 5e-4, 20e-3\n\nplot(q_rain_range * 1e3,  [conv_q_liq_to_q_rai_accr(param_set, q_liq, q_rai, ρ_air) for q_rai in q_rain_range], xlabel=\"q_rain [g/kg]\", ylabel=\"accretion rate [1/s]\", title=\"Accretion\", label=\"ClimateMachine\")\nplot!(q_rain_range * 1e3, [accretion_empirical(q_rai, q_liq, q_tot) for q_rai in q_rain_range], label=\"empirical\")\nsavefig(\"accretion_rate.svg\") # hide\nnothing # hide","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"(Image: )","category":"page"},{"location":"Theory/Atmos/Microphysics/#Rain-evaporation-1","page":"Microphysics","title":"Rain evaporation","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"Based on Maxwell 1971 the equation of growth of individual water drop is:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\n\nr fracdrdt = frac1rho_water\n                  left(fracq_vapq_vap^sat - 1 right)\n                  left(\n                    fracLKT left(fracLR_v T - 1 right) +\n                    fracR_v Tp_vap^sat D\n                  right)^-1\n                = frac1rho_water S(q_vap q_vap^sat)  G(T)\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"q_vap^sat is the saturation vapor specific humidity,\nL is the latent heat of vaporization,\nK_thermo is the thermal conductivity of air,\nR_v is the gas constant of water vapor,\nD_vapor is the diffusivity of water vapor,\nS(q_vap q_vap^sat) = fracq_vapq_vap^sat - 1","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"is commonly labeled as supersaturation,","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"G(T) = left(fracLKT left(fracLR_v T - 1 right) + fracR_v Tp_vap^sat D right)^-1","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"combines the effects of thermal conductivity and water diffusivity.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The rate of q_rai evaporation is:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_evap  =  int_0^infty frac1rho  4 pi  r  S(q_vap q_vap^sat)  G(T)  F(r)  n(r)  dr\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"F(r) is the rain drop ventilation factor.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"Following Seifert and Beheng 2006 eq. 24 the ventilation factor is defined as:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nF(r) = a_vent + b_vent  N_Sc^13 N_Re(r)^12\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"a_vent, b_vent are coefficients,\nN_Sc is the Schmidt number,\nN_Re is the Reynolds number of a falling rain drop.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The Schmidt number is assumed constant:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"N_Sc = fracnu_airD_vapor","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"nu_air is the kinematic viscosity of air.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The Reynolds number of a rain drop is defined as:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"N_Re = frac2  r  v_drop(r rho)nu_air = frac2 v_c(rho)  g^12  r^32nu_air","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The final integral is:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_evap  =  4 pi S(q_vap q_vap^sat) fracn_0_MP G(T)rho\n                                                  int_0^infty left( a_vent r + b_vent N_Sc^13 (2 v_c(rho))^12 fracg^14nu_air^12 r^74 right) exp(-lambda_MP r) dr\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"Integrating and eliminating lambda_MP using eq.(\\ref{eq:lambda}) results in:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"beginequation\nleft fracd  q_raidt right_evap  = S(q_vap q_vap^sat) fracG(T) n_0_MP^12rho left( A q_rai^12 + B fracg^14n_0_MP^316 nu_air^12 q_rai^1116 right)\nendequation","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"where:","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"A = (2 pi)^12 a_vent left( fracrhorho_water right)^12\nB = Gammaleft(frac114right) 2^716 pi^516 b_vent N_Sc^13 v_c(rho)^12 left( fracrhorho_water right)^1116","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"The values of a_vent and b_vent are chosen so that at q_tot = 15 gkg and T=288K the resulting rain evaporation rate is close to the empirical rain evaporation rate from Smolarkiewicz and Grabowski 1996.","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"using ClimateMachine.Microphysics\nusing ClimateMachine.MoistThermodynamics\n\nusing CLIMAParameters\nusing CLIMAParameters.Planet: R_d, planet_radius, grav, MSLP, molmass_ratio\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()\n\nusing Plots\n\n# eq. 5c in Smolarkiewicz and Grabowski 1996\n# https://doi.org/10.1175/1520-0493(1996)124<0487:TTLSLM>2.0.CO;2\nfunction rain_evap_empirical(q_rai::DT, q::PhasePartition, T::DT, p::DT, ρ::DT) where {DT<:Real}\n\n    ts_neq = TemperatureSHumNonEquil(param_set, T, ρ, q)\n    q_sat  = q_vap_saturation(ts_neq)\n    q_vap  = q.tot - q.liq\n    rr     = q_rai / (DT(1) - q.tot)\n    rv_sat = q_sat / (DT(1) - q.tot)\n    S      = q_vap/q_sat - DT(1)\n\n    ag, bg = 5.4 * 1e2, 2.55 * 1e5\n    G = DT(1) / (ag + bg / p / rv_sat) / ρ\n\n    av, bv = 1.6, 124.9\n    F = av * (ρ/DT(1e3))^DT(0.525)  * rr^DT(0.525) + bv * (ρ/DT(1e3))^DT(0.7296) * rr^DT(0.7296)\n\n    return DT(1) / (DT(1) - q.tot) * S * F * G\nend\n\n# example values\nT, p = 273.15 + 15, 90000.\nϵ = 1. / molmass_ratio(param_set)\np_sat = saturation_vapor_pressure(param_set, T, Liquid())\nq_sat = ϵ * p_sat / (p + p_sat * (ϵ - 1.))\nq_rain_range = range(1e-8, stop=5e-3, length=100)\nq_tot = 15e-3\nq_vap = 0.15 * q_sat\nq_ice = 0.\nq_liq = q_tot - q_vap - q_ice\nq = PhasePartition(q_tot, q_liq, q_ice)\nR = gas_constant_air(param_set, q)\nρ = p / R / T\n\nplot(q_rain_range * 1e3,  [conv_q_rai_to_q_vap(param_set, q_rai, q, T, p, ρ) for q_rai in q_rain_range], xlabel=\"q_rain [g/kg]\", ylabel=\"rain evaporation rate [1/s]\", title=\"Rain evaporation\", label=\"ClimateMachine\")\nplot!(q_rain_range * 1e3, [rain_evap_empirical(q_rai, q, T, p, ρ) for q_rai in q_rain_range], label=\"empirical\")\nsavefig(\"rain_evaporation_rate.svg\") # hide\nnothing # hide","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"(Image: )","category":"page"},{"location":"Theory/Atmos/Microphysics/#References-1","page":"Microphysics","title":"References","text":"","category":"section"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"@article{GrabowskiandSmolarkiewicz_1996, author = {Grabowski, Wojciech W. and Smolarkiewicz, Piotr K.}, title = {Two-Time-Level Semi-Lagrangian Modeling of Precipitating Clouds}, journal = {Monthly Weather Review}, volume = {124}, number = {3}, pages = {487-497}, year = {1996}, doi = {10.1175/1520-0493(1996)124<0487:TTLSLM>2.0.CO;2}}","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"@article{Kessler_1995, author = {Kessler, E.}, title = {On the continuity and distribution of water substance in atmospheric circulations}, journal = {Atmospheric Research}, volume = {38}, number = {1}, pages = {109 - 145}, year = {1995}, doi = {10.1016/0169-8095(94)00090-Z}}","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"@book{Mason_1971, author = {Mason, B. J.}, title = {The Physics of Clouds}, publisher = {Oxford Univ. Press}, year = {1971}}","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"@article{MarshallandPalmer_1948, author = {Marshall, J. S. and Palmer, W. Mc K.}, title = {The distribution of raindrops with size}, journal = {Journal of Meteorology}, volume = {5}, number = {4}, pages = {165-166}, year = {1948}, doi = {10.1175/1520-0469(1948)005<0165:TDORWS>2.0.CO;2}}","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"@article{OguraandTakahashi_1971, author = {Oqura, Yoshimitsu and Takahashi, Tsutomu}, title = {Numerical simulation of the life cycle of a thunderstorm cell}, journal = {Monthly Weather Review}, volume = {99}, number = {12}, pages = {895-911}, year = {1971}, doi = {10.1175/1520-0493(1971)099<0895:NSOTLC>2.3.CO;2}}","category":"page"},{"location":"Theory/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"@article{SeifertandBeheng_2006, author={Seifert, A. and Beheng, K. D.}, title={A two-moment cloud microphysics parameterization for mixed-phase clouds. Part 1: Model description}, journal={Meteorology and Atmospheric Physics}, year={2006}, volume={92}, number={1}, pages={45–66}, doi={10.1007/s00703-005-0112-4}}","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#How-to-make-a-Balance-law-1","page":"How to make a balance law","title":"How to make a Balance law","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"CurrentModule = ClimateMachine.DGmethods","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"Defining the set of solved PDEs in ClimateMachine revolve around defining a BalanceLaw. A balance law solves equations of the form:","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"∂Y\n-- = - ∇ • ( F_{first_order}(Y) + F_{second_order}(Y, Σ) ) + S_{non_conservative}(Y, Σ)\n∂t","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"Here, Y, Σ, F_{first_order}, F_{second_order}, and S_{non_conservative} can be thought of column vectors[1] expressing:","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"Y the conservative state variables, or unknowns of the PDEs to be solved\nΣ the gradients of functions of the conservative state variables\nF_{first-order} contains all first-order fluxes (e.g. not functions","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"of gradients of any variables)","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"F_{second-order} contains all second-order and higher-order fluxes","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"(e.g. functions of gradients of any variables)","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"S_{non_conservative} non-conservative sources[2]","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"In order to alleviate users from being concerned with the burden of spatial discretization, users must provide their own implementations of the following methods, which are computed locally at each nodal point:","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#Variable-name-specification-methods-1","page":"How to make a balance law","title":"Variable name specification methods","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"Method Necessary Purpose\nvars_state_conservative YES specify the names of the variables in the conservative state vector, typically mass, momentum, and various tracers.\nvars_state_auxiliary YES specify the names of any variables required for the balance law that aren't related to derivatives of the state variables (e.g. spatial coordinates or various integrals) or those needed to solve expensive auxiliary equations (e.g., temperature via a non-linear equation solve)\nvars_state_gradient YES specify the names of the gradients of functions of the conservative state variables. used to represent values before and after differentiation\nvars_state_gradient_flux YES specify the names of the gradient fluxes necessary to impose Neumann boundary conditions. typically the product of a diffusivity tensor with a gradient state variable, potentially equivalent to the second-order flux for a conservative state variable\nvars_integrals NO specify the names of any one-dimensional vertical integrals from bottom to top of the domain required for the balance law. used to represent both the integrand and the resulting indefinite integral\nvars_reverse_integrals NO specify the names of any one-dimensional vertical integral from top to bottom of the domain required for the balance law. each variable here must also exist in vars_integrals since the reverse integral kernels use subtraction to reverse the integral instead of performing a new integral. use to represent the value before and after reversing direction","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#Methods-to-compute-gradients-and-integrals-1","page":"How to make a balance law","title":"Methods to compute gradients and integrals","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"Method Purpose\ncompute_gradient_argument! specify how to compute the arguments to the gradients. can be functions of conservative state  and auxiliary variables.\ncompute_gradient_flux! specify how to compute gradient fluxes. can be a functions of the gradient state, the conservative state, and auxiliary variables.\nintegral_load_auxiliary_state! specify how to compute integrands. can be functions of the conservative state and auxiliary variables.\nintegral_set_auxiliary_state! specify which auxiliary variables are used to store the output of the integrals.\nreverse_integral_load_auxiliary_state! specify auxiliary variables need their integrals reversed.\nreverse_integral_set_auxiliary_state! specify which auxiliary variables are used to store the output of the reversed integrals.\nupdate_auxiliary_state! perform any updates to the auxiliary variables needed at the beginning of each time-step. Can be used to solve non-linear equations, calculate integrals, and apply filters.\nupdate_auxiliary_state_gradient! same as above, but after computing gradients and gradient fluxes in case these variables are needed during the update.","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#Methods-to-compute-fluxes-and-sources-1","page":"How to make a balance law","title":"Methods to compute fluxes and sources","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"Method Purpose\nflux_first_order! specify F_{first_order} for each conservative state variable. can be functions of the conservative state and auxiliary variables.\nflux_second_order! specify F_{second_order} for each conservative state variable. can be functions of the conservative state, gradient flux state, and auxiliary variables.\nsource! specify S_{non_conservative}  for each conservative state variable. can be functions of the conservative state, gradient flux state, and auxiliary variables.","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#Methods-to-compute-numerical-fluxes-1","page":"How to make a balance law","title":"Methods to compute numerical fluxes","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"Method Purpose\nwavespeed specify how to compute the local wavespeed if using the RusanovNumericalFlux.\nboundary_state! define exterior nodal values of the conservative state and gradient flux state used to compute the numerical boundary fluxes.","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#Methods-to-set-initial-conditions-1","page":"How to make a balance law","title":"Methods to set initial conditions","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"Method Purpose\ninit_state_conservative! provide initial values for the conservative state as a function of time and space.\ninit_state_auxiliary! provide initial values for the auxiliary variables as a function of the geometry.","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#General-Remarks-1","page":"How to make a balance law","title":"General Remarks","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"While Y can be thought of a column vector (each row of which corresponds to each state variable and its prognostic equation), the second function argument inside these methods behave as dictionaries, for example:","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"struct MyModel <: BalanceLaw end\n\nfunction vars_state_conservative(m::MyModel, FT)\n    @vars begin\n        ρ::FT\n        T::FT\n    end\nend\n\nfunction source!(m::MyModel, source::Vars, args...)\n    source.ρ = 1 # adds a source of 1 to RHS of ρ equation\n    source.T = 1 # adds a source of 1 to RHS of T equation\nend","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"All equations are marched simultaneously in time.","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#Reference-links-1","page":"How to make a balance law","title":"Reference links","text":"","category":"section"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"[1]: Column Vectors","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"[2]: Note that using non-conservative sources should be a final resort,","category":"page"},{"location":"HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/#","page":"How to make a balance law","title":"How to make a balance law","text":"as this can leak conservation of the unknowns and lead to numerical instabilities. It is recommended to use either F_{diffusive} or F_{non_diffusive}, as these fluxes are communicated across elements[3] [3]: MPI communication occurs only across elements, not within each element, where there may be many [Gauss-Lobatto][4] points [4]: Gauss-Lobatto","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ODESolvers-docs-1","page":"ODESolvers","title":"ODESolvers","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#LowStorageRungeKutta-1","page":"ODESolvers","title":"LowStorageRungeKutta","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.LowStorageRungeKutta2N\nODESolvers.LSRK54CarpenterKennedy\nODESolvers.LSRK144NiegemannDiehlBusch","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.LowStorageRungeKutta2N","page":"ODESolvers","title":"ClimateMachine.ODESolvers.LowStorageRungeKutta2N","text":"LowStorageRungeKutta2N(f, RKA, RKB, RKC, Q; dt, t0 = 0)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThe constructor builds a low-storage Runge-Kutta scheme using 2N storage based on the provided RKA, RKB and RKC coefficient arrays.\n\nThe available concrete implementations are:\n\nLSRK54CarpenterKennedy\nLSRK144NiegemannDiehlBusch\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.LSRK54CarpenterKennedy","page":"ODESolvers","title":"ClimateMachine.ODESolvers.LSRK54CarpenterKennedy","text":"LSRK54CarpenterKennedy(f, Q; dt, t0 = 0)\n\nThis function returns a LowStorageRungeKutta2N time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the fourth-order, low-storage, Runge–Kutta scheme of Carpenter and Kennedy (1994) (in their notation (5,4) 2N-Storage RK scheme).\n\nReferences\n\n@TECHREPORT{CarpenterKennedy1994,\n  author = {M.~H. Carpenter and C.~A. Kennedy},\n  title = {Fourth-order {2N-storage} {Runge-Kutta} schemes},\n  institution = {National Aeronautics and Space Administration},\n  year = {1994},\n  number = {NASA TM-109112},\n  address = {Langley Research Center, Hampton, VA},\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.LSRK144NiegemannDiehlBusch","page":"ODESolvers","title":"ClimateMachine.ODESolvers.LSRK144NiegemannDiehlBusch","text":"LSRK144NiegemannDiehlBusch((f, Q; dt, t0 = 0)\n\nThis function returns a LowStorageRungeKutta2N time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the fourth-order, 14-stage, low-storage, Runge–Kutta scheme of Niegemann, Diehl, and Busch (2012) with optimized stability region\n\nReferences\n\n@article{niegemann2012efficient,\n  title={Efficient low-storage Runge--Kutta schemes with optimized stability regions},\n  author={Niegemann, Jens and Diehl, Richard and Busch, Kurt},\n  journal={Journal of Computational Physics},\n  volume={231},\n  number={2},\n  pages={364--372},\n  year={2012},\n  publisher={Elsevier}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#StrongStabilityPreservingRungeKutta-1","page":"ODESolvers","title":"StrongStabilityPreservingRungeKutta","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.StrongStabilityPreservingRungeKutta\nODESolvers.SSPRK33ShuOsher\nODESolvers.SSPRK34SpiteriRuuth","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.StrongStabilityPreservingRungeKutta","page":"ODESolvers","title":"ClimateMachine.ODESolvers.StrongStabilityPreservingRungeKutta","text":"StrongStabilityPreservingRungeKutta(f, RKA, RKB, RKC, Q; dt, t0 = 0)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThe constructor builds a strong-stability-preserving Runge–Kutta scheme based on the provided RKA, RKB and RKC coefficient arrays.\n\nThe available concrete implementations are:\n\nSSPRK33ShuOsher\nSSPRK34SpiteriRuuth\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.SSPRK33ShuOsher","page":"ODESolvers","title":"ClimateMachine.ODESolvers.SSPRK33ShuOsher","text":"SSPRK33ShuOsher(f, Q; dt, t0 = 0)\n\nThis function returns a StrongStabilityPreservingRungeKutta time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the third-order, 3-stage, strong-stability-preserving, Runge–Kutta scheme of Shu and Osher (1988)\n\nReferences\n\n@article{shu1988efficient,\n  title={Efficient implementation of essentially non-oscillatory shock-capturing schemes},\n  author={Shu, Chi-Wang and Osher, Stanley},\n  journal={Journal of computational physics},\n  volume={77},\n  number={2},\n  pages={439--471},\n  year={1988},\n  publisher={Elsevier}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.SSPRK34SpiteriRuuth","page":"ODESolvers","title":"ClimateMachine.ODESolvers.SSPRK34SpiteriRuuth","text":"SSPRK34SpiteriRuuth(f, Q; dt, t0 = 0)\n\nThis function returns a StrongStabilityPreservingRungeKutta time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\n  dotQ = f(Q t)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the third-order, 4-stage, strong-stability-preserving, Runge–Kutta scheme of Spiteri and Ruuth (1988)\n\nReferences\n\n@article{spiteri2002new,\n  title={A new class of optimal high-order strong-stability-preserving time discretization methods},\n  author={Spiteri, Raymond J and Ruuth, Steven J},\n  journal={SIAM Journal on Numerical Analysis},\n  volume={40},\n  number={2},\n  pages={469--491},\n  year={2002},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#AdditiveRungeKutta-1","page":"ODESolvers","title":"AdditiveRungeKutta","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.AdditiveRungeKutta\nODESolvers.ARK2GiraldoKellyConstantinescu\nODESolvers.ARK548L2SA2KennedyCarpenter\nODESolvers.ARK437L2SA1KennedyCarpenter","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.AdditiveRungeKutta","page":"ODESolvers","title":"ClimateMachine.ODESolvers.AdditiveRungeKutta","text":"AdditiveRungeKutta(f, l, backward_euler_solver, RKAe, RKAi, RKB, RKC, Q;\n                   split_explicit_implicit, variant, dt, t0 = 0)\n\nThis is a time stepping object for implicit-explicit time stepping of a decomposed differential equation. When split_explicit_implicit == false the equation is assumed to be decomposed as\n\n  dotQ = l(Q t) + f(Q t) - l(Q t)\n\nwhere Q is the state, f is the full tendency and l is the chosen implicit operator. When split_explicit_implicit == true the assumed decomposition is\n\n  dotQ = l(Q t) + f(Q t)\n\nwhere f is now only the nonlinear tendency. For both decompositions the implicit operator l is integrated implicitly whereas the remaining part is integrated explicitly. Other arguments are the required time step size dt and the optional initial time t0. The resulting backward Euler type systems are solved using the provided backward_euler_solver. This time stepping object is intended to be passed to the solve! command.\n\nThe constructor builds an additive Runge–Kutta scheme based on the provided RKAe, RKAi, RKB and RKC coefficient arrays.  Additionally variant specifies which of the analytically equivalent but numerically different formulations of the scheme is used.\n\nThe available concrete implementations are:\n\nARK2GiraldoKellyConstantinescu\nARK548L2SA2KennedyCarpenter\nARK437L2SA1KennedyCarpenter\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.ARK2GiraldoKellyConstantinescu","page":"ODESolvers","title":"ClimateMachine.ODESolvers.ARK2GiraldoKellyConstantinescu","text":"ARK2GiraldoKellyConstantinescu(f, l, backward_euler_solver, Q; dt, t0,\n                               split_explicit_implicit, variant, paperversion)\n\nThis function returns an AdditiveRungeKutta time stepping object, see the documentation of AdditiveRungeKutta for arguments definitions. This time stepping object is intended to be passed to the solve! command.\n\npaperversion=true uses the coefficients from the paper, paperversion=false uses coefficients that make the scheme (much) more stable but less accurate\n\nThis uses the second-order-accurate 3-stage additive Runge–Kutta scheme of Giraldo, Kelly and Constantinescu (2013).\n\nReferences\n\n@article{giraldo2013implicit,\n  title={Implicit-explicit formulations of a three-dimensional\n         nonhydrostatic unified model of the atmosphere ({NUMA})},\n  author={Giraldo, Francis X and Kelly, James F and Constantinescu, Emil M},\n  journal={SIAM Journal on Scientific Computing},\n  volume={35},\n  number={5},\n  pages={B1162--B1194},\n  year={2013},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.ARK548L2SA2KennedyCarpenter","page":"ODESolvers","title":"ClimateMachine.ODESolvers.ARK548L2SA2KennedyCarpenter","text":"ARK548L2SA2KennedyCarpenter(f, l, backward_euler_solver, Q; dt, t0,\n                            split_explicit_implicit, variant)\n\nThis function returns an AdditiveRungeKutta time stepping object, see the documentation of AdditiveRungeKutta for arguments definitions. This time stepping object is intended to be passed to the solve! command.\n\nThis uses the fifth-order-accurate 8-stage additive Runge–Kutta scheme of Kennedy and Carpenter (2013).\n\nReferences\n\n@article{kennedy2019higher,\n  title={Higher-order additive Runge--Kutta schemes for ordinary\n         differential equations},\n  author={Kennedy, Christopher A and Carpenter, Mark H},\n  journal={Applied Numerical Mathematics},\n  volume={136},\n  pages={183--205},\n  year={2019},\n  publisher={Elsevier}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.ARK437L2SA1KennedyCarpenter","page":"ODESolvers","title":"ClimateMachine.ODESolvers.ARK437L2SA1KennedyCarpenter","text":"ARK437L2SA1KennedyCarpenter(f, l, backward_euler_solver, Q; dt, t0,\n                            split_explicit_implicit, variant)\n\nThis function returns an AdditiveRungeKutta time stepping object, see the documentation of AdditiveRungeKutta for arguments definitions. This time stepping object is intended to be passed to the solve! command.\n\nThis uses the fourth-order-accurate 7-stage additive Runge–Kutta scheme of Kennedy and Carpenter (2013).\n\nReferences\n\n@article{kennedy2019higher,\n  title={Higher-order additive Runge--Kutta schemes for ordinary\n         differential equations},\n  author={Kennedy, Christopher A and Carpenter, Mark H},\n  journal={Applied Numerical Mathematics},\n  volume={136},\n  pages={183--205},\n  year={2019},\n  publisher={Elsevier}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#GenericCallbacks-1","page":"ODESolvers","title":"GenericCallbacks","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"GenericCallbacks.GenericCallbacks\nGenericCallbacks.EveryXWallTimeSeconds\nGenericCallbacks.EveryXSimulationSteps","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.GenericCallbacks","page":"ODESolvers","title":"ClimateMachine.GenericCallbacks","text":"A set of callback functions to be used with an AbstractODESolver\n\n\n\n\n\n","category":"module"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.GenericCallbacks.EveryXWallTimeSeconds","page":"ODESolvers","title":"ClimateMachine.GenericCallbacks.EveryXWallTimeSeconds","text":"EveryXWallTimeSeconds(f, time, mpicomm)\n\nThis callback will run the function 'f()' every time wallclock time seconds. The mpicomm is used to syncronize runtime across MPI ranks.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.GenericCallbacks.EveryXSimulationSteps","page":"ODESolvers","title":"ClimateMachine.GenericCallbacks.EveryXSimulationSteps","text":"EveryXSimulationSteps(f, steps)\n\nThis callback will run the function 'f()' every steps of the time stepper\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ODESolvers-1","page":"ODESolvers","title":"ODESolvers","text":"","category":"section"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.solve!\nODESolvers.gettime\nODESolvers.updatedt!","category":"page"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.solve!","page":"ODESolvers","title":"ClimateMachine.ODESolvers.solve!","text":"solve!(Q, solver::AbstractODESolver; timeend,\n       stopaftertimeend=true, numberofsteps, callbacks)\n\nSolves an ODE using the solver starting from a state Q. The state Q is updated inplace. The final time timeend or numberofsteps must be specified.\n\nA series of optional callback functions can be specified using the tuple callbacks; see GenericCallbacks.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.gettime","page":"ODESolvers","title":"ClimateMachine.ODESolvers.gettime","text":"gettime(solver::AbstractODESolver)\n\nReturns the current simulation time of the ODE solver solver\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/ODESolvers/ODESolvers/#ClimateMachine.ODESolvers.updatedt!","page":"ODESolvers","title":"ClimateMachine.ODESolvers.updatedt!","text":"updatedt!(solver::AbstractODESolver, dt)\n\nChange the time step size to dt for the ODE solver solver.\n\n\n\n\n\n","category":"function"},{"location":"DevDocs/VariableList/#ClimateMachine-Variable-List-1","page":"Variable list","title":"ClimateMachine Variable List","text":"","category":"section"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"This document is currently for collaborators within the project with access to the Overleaf CliMA-Atmos docs. The purpose of this page is to unify the naming conventions used in the Overleaf document in a manner useful for coding. This document suggests 'reserved' variable names in <property>_<species> format with the default working fluid (no-subscript) being moist air. Contributors to the CliMA repository are welcome to suggest changes when necessary.","category":"page"},{"location":"DevDocs/VariableList/#Type-parameters-1","page":"Variable list","title":"Type parameters","text":"","category":"section"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"The Julia code typically uses T as a type parameter, however this conflicts with the typical usage for temperature. Instead, good choices are:","category":"page"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"FT for floating point values","category":"page"},{"location":"DevDocs/VariableList/#Names-reserved-for-'use-and-throw'-/-debug-variables-1","page":"Variable list","title":"Names reserved for 'use and throw' / debug variables","text":"","category":"section"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"dummy\nscratch","category":"page"},{"location":"DevDocs/VariableList/#.1-Working-Fluid-and-Equation-of-State-1","page":"Variable list","title":"2.1  Working Fluid and Equation of State","text":"","category":"section"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"q_dry = dry air mass fraction\nq_vap = specific humidity, vapour\nq_liq = specific humidity, liquid\nq_ice = specific humidity, ice\nq_con = specific humidity, condensate\nq_tot = specific humidity, total\n\nP_<species>     = pressure, species (no subscript == default working fluid moist air)\nρ_<species>     = density, species (no subscript == default working fluid moist air)\nR_m             = gas constant, moist\nR_d             = gas constant, dry\nR_v             = gas constant, water vapour\nT               = temperature, moist air\nT_<species>     = temperature, species","category":"page"},{"location":"DevDocs/VariableList/#.2-Mass-Balance-1","page":"Variable list","title":"2.2 Mass Balance","text":"","category":"section"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"dt              = time increment\nu               = x-velocity\nv               = y-velocity\nw               = z-velocity\nU               = x-momentum\nV               = y-momentum\nW               = z=momentum","category":"page"},{"location":"DevDocs/VariableList/#.3-Moisture-balances-1","page":"Variable list","title":"2.3 Moisture balances","text":"","category":"section"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"source_qt           = local source/sink of water mass [S_qt]\ndiffusiveflux_vap   = diffusive flux, water vapour\ndiffusiveflux_liq   = diffusive flux, cloud liquid\ndiffusiveflux_ice   = diffusive flux, cloud ice\ndiffusiveflux_tot   = diffusive flux, total","category":"page"},{"location":"DevDocs/VariableList/#.4-Momentum-balances-1","page":"Variable list","title":"2.4 Momentum balances","text":"","category":"section"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"U               = x-momentum\nV               = y-momentum\nW               = z-momentum (2D/3D: this is the vertical coordinate)\nΩ_x             = x-angular momentum\nΩ_y             = y-angular momentum\nΩ_z             = z-angular momentum\nτ_xx            = stress tensor ((1,1) component)\nτ_<ij>          = replace ij with combination of x/y/z to recover appropriate value\nλ_stokes        = Stokes parameter","category":"page"},{"location":"DevDocs/VariableList/#.5-Energy-balance-1","page":"Variable list","title":"2.5 Energy balance","text":"","category":"section"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"<Lower case e_<type> suggests specific (per unit mass) quantities>\ne_kin_<spe>      = specific energy per unit volume, kinetic\ne_pot_<spe>      = specific energy per unit volume, potential\ne_int_<spe>      = specific energy per unit volume, internal\ne_tot_<spe>      = specific energy per unit volume, total\n\nE_kin_<spe>      = energy, kinetic\nE_pot_<spe>      = energy, potential\nE_int_<spe>      = energy, internal\nE_tot_<spe>      = energy, total\n\ncv_m             = isochoric specific heat, moist air\ncv_d             = isochoric specific heat, dry air\ncv_l             = isochoric specific heat, liquid water\ncv_v             = isochoric specific heat, water vapour\ncv_i             = isochoric specific heat, ice\n\ncp_m             = isobaric specific heat, moist air\ncp_d             = isobaric specific heat, dry air\ncp_l             = isobaric specific heat, liquid water\ncp_v             = isobaric specific heat, water vapour\ncp_i             = isobaric specific heat, ice","category":"page"},{"location":"DevDocs/VariableList/#.6-Microphysics-1","page":"Variable list","title":"2.6 Microphysics","text":"","category":"section"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"q_rai = specific humidity, rain [kg/kg]\n\nterminal_velocity = mass weighted average rain fall speed [m/s]\n\nconv_q_vap_to_q_liq      = tendency to q_liq and q_ice due to\n                           condensation/evaporation and\n                           sublimation/resublimation from q_vap [1/s]\nconv_q_liq_to_q_rai_acnv = tendency to q_rai due to autoconversion from q_liq [1/s]\nconv_q_liq_to_q_rai_accr = tendency to q_rai due to accretion from q_liq [1/s]\nconv_q_rai_to_q_vap      = tendency to q_vap due to evaporation from q_rai [1/s]","category":"page"},{"location":"DevDocs/VariableList/#.7-Diagnostics-1","page":"Variable list","title":"2.7 Diagnostics","text":"","category":"section"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"Please see CliMA Diagnostic Variable List.","category":"page"},{"location":"DevDocs/VariableList/#TODO-1","page":"Variable list","title":"TODO","text":"","category":"section"},{"location":"DevDocs/VariableList/#","page":"Variable list","title":"Variable list","text":"Update with list of additional parameters / source terms as necessary","category":"page"},{"location":"GettingStarted/Atmos/#Atmosphere-model-configurations-1","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"","category":"section"},{"location":"GettingStarted/Atmos/#","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"The struct AtmosModel defines a specific subtype of a balance law (i.e. conservation equations) specific to atmospheric modeling. A complete description of a model is provided by the fields listed below. In this implementation of the AtmosModel we concern ourselves with the conservative form of the compressible equations of moist fluid motion given a set of initial, boundary and forcing(source) conditions.","category":"page"},{"location":"GettingStarted/Atmos/#[LES-Configuration](@id-LESConfig)-(with-defaults)-1","page":"Atmosphere model configurations","title":"LES Configuration (with defaults)","text":"","category":"section"},{"location":"GettingStarted/Atmos/#","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"Default field values for the LES AtmosModel definition are included below. Users are directed to the model subcomponent pages to view the possible options for each subcomponent.","category":"page"},{"location":"GettingStarted/Atmos/#","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"    ::Type{AtmosLESConfigType},\n    param_set::AbstractParameterSet;\n    orientation::O = FlatOrientation(),\n    ref_state::RS = HydrostaticState(DecayingTemperatureProfile{FT}(param_set),)\n    turbulence::T = SmagorinskyLilly{FT}(0.21),\n    hyperdiffusion::HD = NoHyperDiffusion(),\n    moisture::M = EquilMoist{FT}(),\n    precipitation::P = NoPrecipitation(),\n    radiation::R = NoRadiation(),\n    source::S = (Gravity(), Coriolis(), GeostrophicForcing{FT}(7.62e-5, 0, 0)),\n    tracers::TR = NoTracers(),\n    boundarycondition::BC = AtmosBC(),\n    init_state_conservative::IS = nothing,\n    data_config::DC = nothing,","category":"page"},{"location":"GettingStarted/Atmos/#","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"note: Note\nMost AtmosModel subcomponents are common to both LES / GCM configurations.  Equation sets are written in vector-invariant form and solved in Cartesian coordinates.  The component orientation determines whether the problem is solved in a box (LES) or a sphere (GCM))","category":"page"},{"location":"GettingStarted/Atmos/#[GCM-Configuration](@id-GCMConfig)(with-defaults)-1","page":"Atmosphere model configurations","title":"GCM Configuration(with defaults)","text":"","category":"section"},{"location":"GettingStarted/Atmos/#","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"Default field values for the GCM AtmosModel definition are included below. Users are directed to the model subcomponent pages to view the possible options for each subcomponent.","category":"page"},{"location":"GettingStarted/Atmos/#","page":"Atmosphere model configurations","title":"Atmosphere model configurations","text":"    ::Type{AtmosGCMConfigType},\n    param_set::AbstractParameterSet;\n    orientation::O = SphericalOrientation(),\n    ref_state::RS = HydrostaticState(DecayingTemperatureProfile{FT}(param_set),)\n    turbulence::T = SmagorinskyLilly{FT}(C_smag(param_set)),\n    hyperdiffusion::HD = NoHyperDiffusion(),\n    moisture::M = EquilMoist{FT}(),\n    precipitation::P = NoPrecipitation(),\n    radiation::R = NoRadiation(),\n    source::S = (Gravity(), Coriolis()),\n    tracers::TR = NoTracers(),\n    boundarycondition::BC = AtmosBC(),\n    init_state_conservative::IS = nothing,\n    data_config::DC = nothing,","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"EditURL = \"<unknown>/src/Atmos/Model/turbulence.jl\"","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#Turbulence-Closures-docs-1","page":"Turbulence","title":"Turbulence Closures","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"In turbulence.jl we specify turbulence closures. Currently, pointwise models of the eddy viscosity/eddy diffusivity type are supported for turbulent shear and tracer diffusivity. Methods currently supported are:\nConstantViscosityWithDivergence\nSmagorinskyLilly\nVreman\nAnisoMinDiss\n","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"note: Note\nUsage: This is a quick-ref guide to using turbulence models as a subcomponent of AtmosModel \nnu is the kinematic viscosity, C_smag is the Smagorinsky Model coefficient,turbulence=ConstantViscosityWithDivergence(ν)\n\nturbulence=SmagorinskyLilly(C_smag)\n\nturbulence=Vreman(C_smag)\n\nturbulence=AnisoMinDiss(C_poincare)","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"using DocStringExtensions\nusing CLIMAParameters.Atmos.SubgridScale: inv_Pr_turb\nexport ConstantViscosityWithDivergence, SmagorinskyLilly, Vreman, AnisoMinDiss\nexport turbulence_tensors","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#Abstract-Type-1","page":"Turbulence","title":"Abstract Type","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"We define a TurbulenceClosure abstract type and default functions for the generic turbulence closure which will be overloaded with model specific functions. Minimally, overloaded functions for the following stubs must be defined for a turbulence model.","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"abstract type TurbulenceClosure end\n\n\nvars_state_gradient((::TurbulenceClosure, FT) = @vars()\nvars_state_gradient_flux(::TurbulenceClosure, FT) = @vars()\nvars_state_auxiliary(::TurbulenceClosure, FT) = @vars()\n\nfunction atmos_init_aux!(\n    ::TurbulenceClosure,\n    ::AtmosModel,\n    aux::Vars,\n    geom::LocalGeometry,\n) end\nfunction compute_gradient_argument!(\n    ::TurbulenceClosure,\n    transform::Vars,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n) end\nfunction compute_gradient_flux!(\n    ::TurbulenceClosure,\n    ::Orientation,\n    diffusive,\n    ∇transform,\n    state,\n    aux,\n    t,\n) end","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"The following may need to be addressed if turbulence models require additional state variables or auxiliary variable updates (e.g. TKE based models)","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"vars_state_conservative(::TurbulenceClosure, FT) = @vars()\nfunction atmos_nodal_update_auxiliary_state!(\n    ::TurbulenceClosure,\n    ::AtmosModel,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n) end","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#Eddy-viscosity-Models-1","page":"Turbulence","title":"Eddy-viscosity Models","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"The following function provides an example of a stub for an eddy-viscosity model.  Currently, scalar and diagonal tensor viscosities and diffusivities are supported.","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"ClimateMachine.Atmos.turbulence_tensors","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#ClimateMachine.Atmos.turbulence_tensors","page":"Turbulence","title":"ClimateMachine.Atmos.turbulence_tensors","text":"ν, D_t, τ = turbulence_tensors(\n                ::TurbulenceClosure,\n                orientation::Orientation,\n                param_set::AbstractParameterSet,\n                state::Vars,\n                diffusive::Vars,\n                aux::Vars,\n                t::Real\n            )\n\nCompute the kinematic viscosity (ν), the diffusivity (D_t) and SGS momentum flux tensor (τ) for a given turbulence closure. Each closure overloads this method with the appropriate calculations for the returned quantities.\n\nArguments\n\n::TurbulenceClosure = Struct identifier for turbulence closure model\norientation = AtmosModel.orientation\nparam_set = AtmosModel.param_set\nstate = Array of prognostic (state) variables. See vars_state_conservative in AtmosModel\ndiffusive = Array of diffusive variables\naux = Array of auxiliary variables\nt = time\n\n\n\n\n\n","category":"function"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"Generic math functions for use within the turbulence closures such as the principal tensor invariants, symmetric tensors and tensor norms have been included.","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#tensor-invariants-1","page":"Turbulence","title":"Pricipal Invariants","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"textitI_1 = mathrmtr(X) \ntextitI_2 = (mathrmtr(X)^2 - mathrmtr(X)^2)  2 \ntextitI_3 = mathrmdet(X) ","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"ClimateMachine.Atmos.principal_invariants","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#ClimateMachine.Atmos.principal_invariants","page":"Turbulence","title":"ClimateMachine.Atmos.principal_invariants","text":"principal_invariants(X)\n\nCalculates principal invariants of a tensor X. Returns 3 element tuple containing the invariants.\n\n\n\n\n\n","category":"function"},{"location":"Theory/Atmos/Model/turbulence/#symmetric-tensors-1","page":"Turbulence","title":"Symmetrize","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"fracmathrmX + mathrmX^T2 ","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"ClimateMachine.Atmos.symmetrize","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#ClimateMachine.Atmos.symmetrize","page":"Turbulence","title":"ClimateMachine.Atmos.symmetrize","text":"symmetrize(X)\n\nGiven a (3,3) second rank tensor X, compute (X + X')/2, returning a symmetric SHermitianCompact object.\n\n\n\n\n\n","category":"function"},{"location":"Theory/Atmos/Model/turbulence/#tensor-norms-1","page":"Turbulence","title":"2-Norm","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"Given a tensor X, return the tensor dot product","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"sum_ij S_ij^2","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"ClimateMachine.Atmos.norm2","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#ClimateMachine.Atmos.norm2","page":"Turbulence","title":"ClimateMachine.Atmos.norm2","text":"norm2(X)\n\nGiven a tensor X, computes its tensor dot product.\n\n\n\n\n\n","category":"function"},{"location":"Theory/Atmos/Model/turbulence/#strain-rate-magnitude-1","page":"Turbulence","title":"Strain-rate Magnitude","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"By definition, the strain-rate magnitude, as defined in standard turbulence modelling is computed such that","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"mathrmS = sqrt2 sum_ij mathrmS_ij^2","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"where","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"vecS(vecu) = frac12  left(nablavecu +  left( nablavecu right)^T right)","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"\\mathrm{S} is the rate-of-strain tensor. (Symmetric component of the velocity gradient). Note that the skew symmetric component (rate-of-rotation) is not currently computed.","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"ClimateMachine.Atmos.strain_rate_magnitude","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#ClimateMachine.Atmos.strain_rate_magnitude","page":"Turbulence","title":"ClimateMachine.Atmos.strain_rate_magnitude","text":"strain_rate_magnitude(S)\n\nGiven the rate-of-strain tensor S, computes its magnitude.\n\n\n\n\n\n","category":"function"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"\"\"\"\n    strain_rate_magnitude(S)\nGiven the rate-of-strain tensor `S`, computes its magnitude.\n\"\"\"\nfunction strain_rate_magnitude(S::SHermitianCompact{3, FT, 6}) where {FT}\n    return sqrt(2 * norm2(S))\nend","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#constant-viscosity-1","page":"Turbulence","title":"Constant Viscosity Model","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"ConstantViscosityWithDivergence requires a user to specify the constant viscosity (kinematic) and appropriately computes the turbulent stress tensor based on this term. Diffusivity can be computed using the turbulent Prandtl number for the appropriate problem regime.","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"tau = - 2 nu mathrmS","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"ClimateMachine.Atmos.ConstantViscosityWithDivergence","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#ClimateMachine.Atmos.ConstantViscosityWithDivergence","page":"Turbulence","title":"ClimateMachine.Atmos.ConstantViscosityWithDivergence","text":"ConstantViscosityWithDivergence <: TurbulenceClosure\n\nTurbulence with constant dynamic viscosity (ρν). Divergence terms are included in the momentum flux tensor.\n\nFields\n\nρν\nDynamic Viscosity [kg/m/s]\n\n\n\n\n\n","category":"type"},{"location":"Theory/Atmos/Model/turbulence/#smagorinsky-lilly-1","page":"Turbulence","title":"Smagorinsky-Lilly","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"The Smagorinsky turbulence model, with Lilly's correction to stratified atmospheric flows, is included in ClimateMachine. The input parameter to this model is the Smagorinsky coefficient. For atmospheric flows, the coefficient C_smag typically takes values between 0.15 and 0.23. Flow dependent C_smag are currently not supported (e.g. Germano's extension). The Smagorinsky-Lilly model does not contain explicit filtered terms.","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#Equations-1","page":"Turbulence","title":"Equations","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"nu = (C_s mathrmf_b Delta)^2 sqrtmathrmS","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"with the stratification correction term","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"f_b =\n   begincases\n   1  mathrmRi leq 0 \n   max(0 1 - mathrmRi  mathrmPr_t)^14  mathrmRi  0 \n   endcases","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"mathrmRi =  fracN^2S^2","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"N = left( fracgtheta_v fracpartial theta_vpartial zright)^12","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"Here, mathrmRi and mathrmPr_t are the Richardson and turbulent Prandtl numbers respectively.  Delta is the mixing length in the relevant coordinate direction. We use the DG metric terms to determine the local effective resolution (see src/Mesh/Geometry.jl), and modify the vertical lengthscale by the stratification correction factor mathrmf_b so that Delta_vert = Delta z f_b.","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"ClimateMachine.Atmos.SmagorinskyLilly","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#ClimateMachine.Atmos.SmagorinskyLilly","page":"Turbulence","title":"ClimateMachine.Atmos.SmagorinskyLilly","text":"SmagorinskyLilly <: TurbulenceClosure\n\nFields\n\nC_smag\nSmagorinsky Coefficient [dimensionless]\n\nSmagorinsky Model Reference\n\narticle{doi:10.1175/1520-0493(1963)091<0099:GCEWTP>2.3.CO;2,\n  author = {Smagorinksy, J.},\n  title = {General circulation experiments with the primitive equations},\n  journal = {Monthly Weather Review},\n  volume = {91},\n  number = {3},\n  pages = {99-164},\n  year = {1963},\n  doi = {10.1175/1520-0493(1963)091<0099:GCEWTP>2.3.CO;2},\n  URL = {https://doi.org/10.1175/1520-0493(1963)091<0099:GCEWTP>2.3.CO;2},\n  eprint = {https://doi.org/10.1175/1520-0493(1963)091<0099:GCEWTP>2.3.CO;2}\n  }\n\nLilly Model Reference\n\narticle{doi:10.1111/j.2153-3490.1962.tb00128.x,\n  author = {LILLY, D. K.},\n  title = {On the numerical simulation of buoyant convection},\n  journal = {Tellus},\n  volume = {14},\n  number = {2},\n  pages = {148-172},\n  doi = {10.1111/j.2153-3490.1962.tb00128.x},\n  url = {https://onlinelibrary.wiley.com/doi/abs/10.1111/j.2153-3490.1962.tb00128.x},\n  eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.2153-3490.1962.tb00128.x},\n  year = {1962}\n  }\n\nBrunt-Väisälä Frequency Reference\n\nBrunt-Vaisala frequency N² defined as in equation (1b) in\n  Durran, D.R. and J.B. Klemp, 1982:\n  On the Effects of Moisture on the Brunt-Väisälä Frequency.\n  J. Atmos. Sci., 39, 2152–2158,\n  https://doi.org/10.1175/1520-0469(1982)039<2152:OTEOMO>2.0.CO;2\n\n\n\n\n\n","category":"type"},{"location":"Theory/Atmos/Model/turbulence/#vreman-1","page":"Turbulence","title":"Vreman Model","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"Vreman's turbulence model for anisotropic flows, which provides a less dissipative solution (specifically in the near-wall and transitional regions) than the Smagorinsky-Lilly method. This model relies of first derivatives of the velocity vector (i.e., the gradient tensor).  By design, the Vreman model handles transitional as well as fully turbulent flows adequately. The input parameter to this model is the Smagorinsky coefficient - the coefficient is modified within the model functions to account for differences in model construction.","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#Equations-2","page":"Turbulence","title":"Equations","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"nu_t = 25 C_s^2 sqrtfracB_betau_iju_ij","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"where (ij m = (123))","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"beginalign\nB_beta = beta_11beta_22 + beta_11beta_33 + beta_22beta_33 - (beta_13^2 + beta_12^2 + beta_23^2) \nbeta_ij = Delta_m^2 u_i m u_j m \nu_ij = fracpartial u_ipartial x_j\nendalign","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"ClimateMachine.Atmos.Vreman","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#ClimateMachine.Atmos.Vreman","page":"Turbulence","title":"ClimateMachine.Atmos.Vreman","text":"Vreman{FT} <: TurbulenceClosure\n\nFilter width Δ is the local grid resolution calculated from the mesh metric tensor. A Smagorinsky coefficient is specified and used to compute the equivalent Vreman coefficient.\n\nν_e = √(Bᵦ/(αᵢⱼαᵢⱼ)) where αᵢⱼ = ∂uⱼ∂uᵢ with uᵢ the resolved scale velocity component.\nβij = Δ²αₘᵢαₘⱼ\nBᵦ = β₁₁β₂₂ + β₂₂β₃₃ + β₁₁β₃₃ - β₁₂² - β₁₃² - β₂₃²\n\nβᵢⱼ is symmetric, positive-definite. If Δᵢ = Δ, then β = Δ²αᵀα\n\nFields\n\nC_smag\nSmagorinsky Coefficient [dimensionless]\n\nReference\n\n@article{Vreman2004,\n  title={An eddy-viscosity subgrid-scale model for turbulent shear flow: Algebraic theory and applications},\n  author={Vreman, AW},\n  journal={Physics of fluids},\n  volume={16},\n  number={10},\n  pages={3670--3681},\n  year={2004},\n  publisher={AIP}\n}\n\n\n\n\n\n","category":"type"},{"location":"Theory/Atmos/Model/turbulence/#aniso-min-diss-1","page":"Turbulence","title":"Anisotropic Minimum Dissipation","text":"","category":"section"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"This method is based Vreugdenhil and Taylor's minimum-dissipation eddy-viscosity model.  The principles of the Rayleigh quotient minimizer are applied to the energy dissipation terms in the conservation equations, resulting in a maximum dissipation bound, and a model for eddy viscosity and eddy diffusivity.","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"nu_e = (mathrmCdelta)^2  mathrmmaxleft0 - frachatpartial_k hatu_i hatpartial_k hatu_j mathrmhatS_ijhatpartial_p hatu_q hatpartial_p hatu_q right","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#","page":"Turbulence","title":"Turbulence","text":"ClimateMachine.Atmos.AnisoMinDiss","category":"page"},{"location":"Theory/Atmos/Model/turbulence/#ClimateMachine.Atmos.AnisoMinDiss","page":"Turbulence","title":"ClimateMachine.Atmos.AnisoMinDiss","text":"AnisoMinDiss{FT} <: TurbulenceClosure\n\nFilter width Δ is the local grid resolution calculated from the mesh metric tensor. A Poincare coefficient is specified and used to compute the equivalent AnisoMinDiss coefficient (computed as the solution to the eigenvalue problem for the Laplacian operator).\n\nFields\n\nC_poincare\n\nReference\n\n@article{\n    doi:10.1063/1.5037039,\n    author = {Vreugdenhil,Catherine A.  and Taylor,John R. },\n    title = {Large-eddy simulations of stratified plane Couette flow using the anisotropic minimum-dissipation model},\n    journal = {Physics of Fluids},\n    volume = {30},\n    number = {8},\n    pages = {085104},\n    year = {2018},\n    doi = {10.1063/1.5037039},\n    URL = {https://doi.org/10.1063/1.5037039}\n}\n\n\n\n\n\n","category":"type"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Microphysics/ex_1_saturation_adjustment.jl\"","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"include(\"KinematicModel.jl\")\n\nfunction vars_state_conservative(m::KinematicModel, FT)\n    @vars begin\n        ρ::FT\n        ρu::SVector{3, FT}\n        ρe::FT\n        ρq_tot::FT\n    end\nend\n\nfunction vars_state_auxiliary(m::KinematicModel, FT)\n    @vars begin","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"defined in initstateauxiliary","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"        p::FT\n        z::FT","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"defined in update_aux","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"        u::FT\n        w::FT\n        q_tot::FT\n        q_vap::FT\n        q_liq::FT\n        q_ice::FT\n        e_tot::FT\n        e_kin::FT\n        e_pot::FT\n        e_int::FT\n        T::FT\n        S::FT\n        RH::FT\n    end\nend\n\nfunction init_kinematic_eddy!(eddy_model, state, aux, (x, y, z), t)\n    FT = eltype(state)\n\n    _grav::FT = grav(param_set)\n\n    dc = eddy_model.data_config","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"density","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    q_pt_0 = PhasePartition(dc.qt_0)\n    R_m, cp_m, cv_m, γ = gas_constants(param_set, q_pt_0)\n    T::FT = dc.θ_0 * (aux.p / dc.p_1000)^(R_m / cp_m)\n    ρ::FT = aux.p / R_m / T\n    state.ρ = ρ","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"moisture","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    state.ρq_tot = ρ * dc.qt_0","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"velocity (derivative of streamfunction)","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    ρu::FT =\n        dc.wmax * dc.xmax / dc.zmax *\n        cos(π * z / dc.zmax) *\n        cos(2 * π * x / dc.xmax)\n    ρw::FT = 2 * dc.wmax * sin(π * z / dc.zmax) * sin(2 * π * x / dc.xmax)\n    state.ρu = SVector(ρu, FT(0), ρw)\n    u::FT = ρu / ρ\n    w::FT = ρw / ρ","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"energy","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    e_kin::FT = 1 // 2 * (u^2 + w^2)\n    e_pot::FT = _grav * z\n    e_int::FT = internal_energy(param_set, T, q_pt_0)\n    e_tot::FT = e_kin + e_pot + e_int\n    state.ρe = ρ * e_tot\n\n    return nothing\nend\n\nfunction kinematic_model_nodal_update_auxiliary_state!(\n    m::KinematicModel,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    FT = eltype(state)\n    _grav::FT = grav(param_set)\n\n    aux.u = state.ρu[1] / state.ρ\n    aux.w = state.ρu[3] / state.ρ\n\n    aux.q_tot = state.ρq_tot / state.ρ\n\n    aux.e_tot = state.ρe / state.ρ\n    aux.e_kin = 1 // 2 * (aux.u^2 + aux.w^2)\n    aux.e_pot = _grav * aux.z\n    aux.e_int = aux.e_tot - aux.e_kin - aux.e_pot","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"saturation adjustment happens here","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    ts = PhaseEquil(param_set, aux.e_int, state.ρ, aux.q_tot)\n    pp = PhasePartition(ts)\n\n    aux.T = ts.T\n    aux.q_vap = aux.q_tot - pp.liq - pp.ice\n    aux.q_liq = pp.liq\n    aux.q_ice = pp.ice\n\n    q = PhasePartition(aux.q_tot, aux.q_liq, aux.q_ice)\n    ts_neq = TemperatureSHumNonEquil(param_set, aux.T, state.ρ, q)\n    aux.S = max(0, aux.q_vap / q_vap_saturation(ts_neq) - FT(1)) * FT(100)\n    aux.RH = aux.q_vap / q_vap_saturation(ts_neq) * FT(100)\nend\n\nfunction boundary_state!(\n    ::RusanovNumericalFlux,\n    m::KinematicModel,\n    state⁺,\n    aux⁺,\n    n,\n    state⁻,\n    aux⁻,\n    bctype,\n    t,\n    args...,\n) end\n\n@inline function wavespeed(\n    m::KinematicModel,\n    nM,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    u = state.ρu / state.ρ\n    return abs(dot(nM, u))\nend\n\n@inline function flux_first_order!(\n    m::KinematicModel,\n    flux::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    FT = eltype(state)","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"advect moisture ...","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    flux.ρq_tot = SVector(\n        state.ρu[1] * state.ρq_tot / state.ρ,\n        FT(0),\n        state.ρu[3] * state.ρq_tot / state.ρ,\n    )","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"... energy ...","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    flux.ρe = SVector(\n        state.ρu[1] / state.ρ * (state.ρe + aux.p),\n        FT(0),\n        state.ρu[3] / state.ρ * (state.ρe + aux.p),\n    )","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"... and don't advect momentum (kinematic setup)","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"end\n\nsource!(::KinematicModel, _...) = nothing\n\nfunction main()","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"Working precision","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    FT = Float64","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"DG polynomial order","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    N = 4","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"Domain resolution and size","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    Δx = FT(20)\n    Δy = FT(1)\n    Δz = FT(20)\n    resolution = (Δx, Δy, Δz)","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"Domain extents","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    xmax = 1500\n    ymax = 10\n    zmax = 1500","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"initial configuration","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    wmax = FT(0.6)  # max velocity of the eddy  [m/s]\n    θ_0 = FT(289) # init. theta value (const) [K]\n    p_0 = FT(101500) # surface pressure [Pa]\n    p_1000 = FT(100000) # reference pressure in theta definition [Pa]\n    qt_0 = FT(7.5 * 1e-3) # init. total water specific humidity (const) [kg/kg]\n    z_0 = FT(0) # surface height","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"time stepping","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    t_ini = FT(0)\n    t_end = FT(60 * 30)\n    dt = 40\n    output_freq = 9\n\n    driver_config = config_kinematic_eddy(\n        FT,\n        N,\n        resolution,\n        xmax,\n        ymax,\n        zmax,\n        wmax,\n        θ_0,\n        p_0,\n        p_1000,\n        qt_0,\n        z_0,\n    )\n    solver_config = ClimateMachine.SolverConfiguration(\n        t_ini,\n        t_end,\n        driver_config;\n        ode_dt = dt,\n        init_on_cpu = true,\n        #Courant_number = CFL,\n    )\n\n    mpicomm = MPI.COMM_WORLD","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"output for paraview","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"initialize base prefix directory from rank 0","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    vtkdir = abspath(joinpath(ClimateMachine.Settings.output_dir, \"vtk\"))\n    if MPI.Comm_rank(mpicomm) == 0\n        mkpath(vtkdir)\n    end\n    MPI.Barrier(mpicomm)\n\n    model = driver_config.bl\n    step = [0]\n    cbvtk =\n        GenericCallbacks.EveryXSimulationSteps(output_freq) do (init = false)\n            out_dirname = @sprintf(\n                \"new_ex_1_mpirank%04d_step%04d\",\n                MPI.Comm_rank(mpicomm),\n                step[1]\n            )\n            out_path_prefix = joinpath(vtkdir, out_dirname)\n            @info \"doing VTK output\" out_path_prefix\n            writevtk(\n                out_path_prefix,\n                solver_config.Q,\n                solver_config.dg,\n                flattenednames(vars_state_conservative(model, FT)),\n                solver_config.dg.state_auxiliary,\n                flattenednames(vars_state_auxiliary(model, FT)),\n            )\n            step[1] += 1\n            nothing\n        end","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"get aux variables indices for testing","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    q_tot_ind = varsindex(vars_state_auxiliary(model, FT), :q_tot)\n    q_vap_ind = varsindex(vars_state_auxiliary(model, FT), :q_vap)\n    q_liq_ind = varsindex(vars_state_auxiliary(model, FT), :q_liq)\n    q_ice_ind = varsindex(vars_state_auxiliary(model, FT), :q_ice)\n    S_ind = varsindex(vars_state_auxiliary(model, FT), :S)","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"call solve! function for time-integrator","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    result = ClimateMachine.invoke!(\n        solver_config;\n        user_callbacks = (cbvtk,),\n        check_euclidean_distance = true,\n    )","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"no supersaturation","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    max_S = maximum(abs.(solver_config.dg.state_auxiliary[:, S_ind, :]))\n    @test isequal(max_S, FT(0))","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"qt is conserved","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    max_q_tot = maximum(abs.(solver_config.dg.state_auxiliary[:, q_tot_ind, :]))\n    min_q_tot = minimum(abs.(solver_config.dg.state_auxiliary[:, q_tot_ind, :]))\n    @test isapprox(max_q_tot, qt_0; rtol = 1e-3)\n    @test isapprox(min_q_tot, qt_0; rtol = 1e-3)","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"qvap + qliq = q_tot","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    max_water_diff = maximum(abs.(\n        solver_config.dg.state_auxiliary[:, q_tot_ind, :] .-\n        solver_config.dg.state_auxiliary[:, q_vap_ind, :] .-\n        solver_config.dg.state_auxiliary[:, q_liq_ind, :],\n    ))\n    @test isequal(max_water_diff, FT(0))","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"no ice","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    max_q_ice = maximum(abs.(solver_config.dg.state_auxiliary[:, q_ice_ind, :]))\n    @test isequal(max_q_ice, FT(0))","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"q_liq ∈ reference range","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"    max_q_liq = max(solver_config.dg.state_auxiliary[:, q_liq_ind, :]...)\n    min_q_liq = min(solver_config.dg.state_auxiliary[:, q_liq_ind, :]...)\n    @test max_q_liq < FT(1e-3)\n    @test isequal(min_q_liq, FT(0))\nend\n\nmain()","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"","category":"page"},{"location":"generated/Microphysics/ex_1_saturation_adjustment/#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Atmos/dry_rayleigh_benard.jl\"","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"using Distributions\nusing Random\nusing StaticArrays\nusing Test\nusing DocStringExtensions\nusing Printf\n\nusing ClimateMachine\nClimateMachine.init()\nusing ClimateMachine.Atmos\nusing ClimateMachine.ConfigTypes\nusing ClimateMachine.DGmethods.NumericalFluxes\nusing ClimateMachine.Diagnostics\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.Mesh.Filters\nusing ClimateMachine.MoistThermodynamics:\n    TemperatureSHumEquil_given_pressure, internal_energy\nusing ClimateMachine.VariableTemplates\n\nusing CLIMAParameters\nusing CLIMAParameters.Planet: R_d, cp_d, cv_d, grav, MSLP\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"–––––––––- Description –––––––––––––––––––– #","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"Dry Rayleigh Benard Convection (re-entrant channel configuration)\nBoundaries - Sides : Periodic (Default bctuple used to identify bot,top walls)              Top   : Prescribed temperature, no-slip              Bottom: Prescribed temperature, no-slip\nDomain - 250m[horizontal] x 250m[horizontal] x 500m[vertical]\nTimeend - 1000s\nMesh Aspect Ratio (Effective resolution) 1:1\nRandom values in initial condition (Requires init_on_cpu=true argument)\nOverrides defaults for            C_smag            Courant_number            init_on_cpu            ref_state            solver_type            bc            sources\nDefault settings can be found in src/Driver/Configurations.jl","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"struct DryRayleighBenardConvectionDataConfig{FT}\n    xmin::FT\n    ymin::FT\n    zmin::FT\n    xmax::FT\n    ymax::FT\n    zmax::FT\n    T_bot::FT\n    T_lapse::FT\n    T_top::FT\nend\n\nfunction init_problem!(bl, state, aux, (x, y, z), t)\n    dc = bl.data_config\n    FT = eltype(state)\n\n    _R_d::FT = R_d(bl.param_set)\n    _cp_d::FT = cp_d(bl.param_set)\n    _grav::FT = grav(bl.param_set)\n    _cv_d::FT = cv_d(bl.param_set)\n    _MSLP::FT = MSLP(bl.param_set)\n\n    γ::FT = _cp_d / _cv_d\n    δT =\n        sinpi(6 * z / (dc.zmax - dc.zmin)) *\n        cospi(6 * z / (dc.zmax - dc.zmin)) + rand()\n    δw =\n        sinpi(6 * z / (dc.zmax - dc.zmin)) *\n        cospi(6 * z / (dc.zmax - dc.zmin)) + rand()\n    ΔT = _grav / _cv_d * z + δT\n    T = dc.T_bot - ΔT\n    P = _MSLP * (T / dc.T_bot)^(_grav / _R_d / dc.T_lapse)\n    ρ = P / (_R_d * T)\n\n    q_tot = FT(0)\n    e_pot = gravitational_potential(bl.orientation, aux)\n    ts = TemperatureSHumEquil_given_pressure(bl.param_set, T, P, q_tot)\n\n    ρu, ρv, ρw = FT(0), FT(0), ρ * δw\n\n    e_int = internal_energy(ts)\n    e_kin = FT(1 / 2) * δw^2\n\n    ρe_tot = ρ * (e_int + e_pot + e_kin)\n    state.ρ = ρ\n    state.ρu = SVector(ρu, ρv, ρw)\n    state.ρe = ρe_tot\n    state.moisture.ρq_tot = FT(0)\n    ρχ = zero(FT)\n    if z <= 100\n        ρχ += FT(0.1) * (cospi(z / 2 / 100))^2\n    end\n    state.tracers.ρχ = SVector{1, FT}(ρχ)\nend\n\nfunction config_problem(FT, N, resolution, xmax, ymax, zmax)","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"Boundary conditions","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"    T_bot = FT(299)\n\n    _cp_d::FT = cp_d(param_set)\n    _grav::FT = grav(param_set)\n\n    T_lapse = FT(_grav / _cp_d)\n    T_top = T_bot - T_lapse * zmax\n\n    ntracers = 1\n    δ_χ = SVector{ntracers, FT}(1)","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"Turbulence","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"    C_smag = FT(0.23)\n    data_config = DryRayleighBenardConvectionDataConfig{FT}(\n        0,\n        0,\n        0,\n        xmax,\n        ymax,\n        zmax,\n        T_bot,\n        T_lapse,\n        FT(T_bot - T_lapse * zmax),\n    )","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"Set up the model","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"    model = AtmosModel{FT}(\n        AtmosLESConfigType,\n        param_set;\n        turbulence = Vreman(C_smag),\n        source = (Gravity(),),\n        boundarycondition = (\n            AtmosBC(\n                momentum = Impenetrable(NoSlip()),\n                energy = PrescribedTemperature((state, aux, t) -> T_bot),\n            ),\n            AtmosBC(\n                momentum = Impenetrable(NoSlip()),\n                energy = PrescribedTemperature((state, aux, t) -> T_top),\n            ),\n        ),\n        tracers = NTracers{ntracers, FT}(δ_χ),\n        init_state_conservative = init_problem!,\n        data_config = data_config,\n    )\n\n    ode_solver = ClimateMachine.MultirateSolverType(\n        linear_model = AtmosAcousticGravityLinearModel,\n        slow_method = LSRK144NiegemannDiehlBusch,\n        fast_method = LSRK144NiegemannDiehlBusch,\n        timestep_ratio = 10,\n    )\n\n    config = ClimateMachine.AtmosLESConfiguration(\n        \"DryRayleighBenardConvection\",\n        N,\n        resolution,\n        xmax,\n        ymax,\n        zmax,\n        param_set,\n        init_problem!,\n        solver_type = ode_solver,\n        model = model,\n    )\n    return config\nend\n\nfunction config_diagnostics(driver_config)\n    interval = \"10000steps\"\n    dgngrp = setup_atmos_default_diagnostics(interval, driver_config.name)\n    return ClimateMachine.DiagnosticsConfiguration([dgngrp])\nend\n\nfunction main()\n    FT = Float64","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"DG polynomial order","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"    N = 4","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"Domain resolution and size","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"    Δh = FT(10)","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"Time integrator setup","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"    t0 = FT(0)","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"Courant number","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"    CFLmax = FT(5)\n    timeend = FT(1000)\n    xmax, ymax, zmax = FT(250), FT(250), FT(500)\n\n    @testset \"DryRayleighBenardTest\" begin\n        for Δh in Δh\n            Δv = Δh\n            resolution = (Δh, Δh, Δv)\n            driver_config = config_problem(FT, N, resolution, xmax, ymax, zmax)\n            solver_config = ClimateMachine.SolverConfiguration(\n                t0,\n                timeend,\n                driver_config,\n                init_on_cpu = true,\n                Courant_number = CFLmax,\n            )\n            dgn_config = config_diagnostics(driver_config)","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"User defined callbacks (TMAR positivity preserving filter)","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"            cbtmarfilter =\n                GenericCallbacks.EveryXSimulationSteps(1) do (init = false)\n                    Filters.apply!(\n                        solver_config.Q,\n                        6,\n                        solver_config.dg.grid,\n                        TMARFilter(),\n                    )\n                    nothing\n                end\n            result = ClimateMachine.invoke!(\n                solver_config;\n                diagnostics_config = dgn_config,\n                user_callbacks = (cbtmarfilter,),\n                check_euclidean_distance = true,\n            )","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"result == engf/eng0","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"            @test isapprox(result, FT(1); atol = 1.5e-2)\n        end\n    end\nend\n\nmain()","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"","category":"page"},{"location":"generated/Atmos/dry_rayleigh_benard/#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#Linear-Solvers-1","page":"LinearSolvers","title":"Linear Solvers","text":"","category":"section"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#","page":"LinearSolvers","title":"LinearSolvers","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#Generalized-Conjugate-Residual-Method-1","page":"LinearSolvers","title":"Generalized Conjugate Residual Method","text":"","category":"section"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#","page":"LinearSolvers","title":"LinearSolvers","text":"GeneralizedConjugateResidualSolver.GeneralizedConjugateResidual","category":"page"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#ClimateMachine.GeneralizedConjugateResidualSolver.GeneralizedConjugateResidual","page":"LinearSolvers","title":"ClimateMachine.GeneralizedConjugateResidualSolver.GeneralizedConjugateResidual","text":"GeneralizedConjugateResidual(K, Q; rtol, atol)\n\nConjugate Residual\n\nThis is an object for solving linear systems using an iterative Krylov method. The constructor parameter K is the number of steps after which the algorithm is restarted (if it has not converged), Q is a reference state used only to allocate the solver internal state, and tolerance specifies the convergence criterion based on the relative residual norm. The amount of memory required by the solver state is roughly (2K + 2) * size(Q). This object is intended to be passed to the linearsolve! command.\n\nThis uses the restarted Generalized Conjugate Residual method of Eisenstat (1983).\n\nReferences\n\n@article{eisenstat1983variational,\n  title={Variational iterative methods for nonsymmetric systems of linear equations},\n  author={Eisenstat, Stanley C and Elman, Howard C and Schultz, Martin H},\n  journal={SIAM Journal on Numerical Analysis},\n  volume={20},\n  number={2},\n  pages={345--357},\n  year={1983},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#Generalized-Minimal-Residual-Method-1","page":"LinearSolvers","title":"Generalized Minimal Residual Method","text":"","category":"section"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#","page":"LinearSolvers","title":"LinearSolvers","text":"GeneralizedMinimalResidualSolver.GeneralizedMinimalResidual","category":"page"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#ClimateMachine.GeneralizedMinimalResidualSolver.GeneralizedMinimalResidual","page":"LinearSolvers","title":"ClimateMachine.GeneralizedMinimalResidualSolver.GeneralizedMinimalResidual","text":"GMRES\n\nGeneralizedMinimalResidual(Q; M, rtol, atol)\n\nThis is an object for solving linear systems using an iterative Krylov method. The constructor parameter M is the number of steps after which the algorithm is restarted (if it has not converged), Q is a reference state used only to allocate the solver internal state, and rtol specifies the convergence criterion based on the relative residual norm. The amount of memory required for the solver state is roughly (M + 1) * size(Q). This object is intended to be passed to the linearsolve! command.\n\nThis uses the restarted Generalized Minimal Residual method of Saad and Schultz (1986).\n\nReferences\n\n@article{saad1986gmres,\n  title={GMRES: A generalized minimal residual algorithm for solving nonsymmetric linear systems},\n  author={Saad, Youcef and Schultz, Martin H},\n  journal={SIAM Journal on scientific and statistical computing},\n  volume={7},\n  number={3},\n  pages={856--869},\n  year={1986},\n  publisher={SIAM}\n}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#Conjugate-Gradient-Solver-Method-1","page":"LinearSolvers","title":"Conjugate Gradient Solver Method","text":"","category":"section"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#","page":"LinearSolvers","title":"LinearSolvers","text":"ConjugateGradientSolver.ConjugateGradient\nLinearSolvers.initialize!\nLinearSolvers.doiteration!","category":"page"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#ClimateMachine.ConjugateGradientSolver.ConjugateGradient","page":"LinearSolvers","title":"ClimateMachine.ConjugateGradientSolver.ConjugateGradient","text":"ConjugateGradient\n\nfunction ConjugateGradient(Q::AT; rtol = eps(eltype(Q)), atol = eps(eltype(Q)), dims = :) where AT\n\nDescription\n\nOuter constructor for the ConjugateGradient struct\n\nArguments\n\nQ:(array). The kind of object that linearoperator! acts on.\n\nKeyword Arguments\n\nrtol: (float). relative tolerance\natol: (float). absolute tolerance\ndims: (tuple or : ). the dimensions to reduce over\nreshape_tuple: (tuple). the dimensions that the conjugate gradient solver operators over\n\nComment\n\nThe reshape tuple is necessary in case the linearoperator! is defined over vectors of a different size as compared to what plays nicely with the dimension reduction in the ConjugateGradient. It also allows the user to define preconditioners over arrays that are more convenienently shaped.\n\nReturn\n\nConjugateGradient struct\n\n\n\n\n\nfunction ConjugateGradient(Q::MPIStateArray; rtol = eps(eltype(Q)), atol = eps(eltype(Q)), dims = :)\n\nDescription\n\nOuter constructor for the ConjugateGradient struct with MPIStateArrays. THIS IS A HACK DUE TO RESHAPE FUNCTIONALITY ON MPISTATEARRAYS.\n\nArguments\n\nQ:(array). The kind of object that linearoperator! acts on.\n\nKeyword Arguments\n\nrtol: (float). relative tolerance\natol: (float). absolute tolerance\ndims: (tuple or : ). the dimensions to reduce over\nreshape_tuple: (tuple). the dimensions that the conjugate gradient solver operators over\n\nComment\n\nThe reshape tuple is necessary in case the linearoperator! is defined over vectors of a different size as compared to what plays nicely with the dimension reduction in the ConjugateGradient. It also allows the user to define preconditioners over arrays that are more convenienently shaped.\n\nReturn\n\nConjugateGradient struct\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#ClimateMachine.LinearSolvers.initialize!","page":"LinearSolvers","title":"ClimateMachine.LinearSolvers.initialize!","text":"LS.initialize!(linearoperator!, Q, Qrhs, solver::ColumnwisePreconditionedConjugateGradient, args...)\n\nDescription\n\nThis function initializes the iterative solver. It is called as part of the AbstractIterativeLinearSolver routine. SEE CODEREF for documentation on AbstractIterativeLinearSolver\n\nArguments\n\nlinearoperator!: (function). This applies the predefined linear operator on an array. Applies a linear operator to object \"y\" and overwrites object \"z\". The function argument i s linearoperator!(z,y, args...) and it returns nothing.\nQ: (array). This is an object that linearoperator! outputs\nQrhs: (array). This is an object that linearoperator! acts on\nsolver: (struct). This is a scruct for dispatch, in this case for ColumnwisePreconditionedConjugateGradient\nargs...: (arbitrary). This is optional arguments that can be passed into linearoperator! function.\n\nKeyword Arguments\n\nThere are no keyword arguments\n\nReturn\n\nconverged: (bool). A boolean to say whether or not the iterative solver has converged.\nthreshold: (float). The value of the residual for the first timestep\n\nComment\n\nThis function does nothing for conjugate gradient\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#ClimateMachine.LinearSolvers.doiteration!","page":"LinearSolvers","title":"ClimateMachine.LinearSolvers.doiteration!","text":"LS.doiteration!(linearoperator!, Q, Qrhs, solver::ColumnwisePreconditionedConjugateGradient, threshold, args...; applyPC!)\n\nDescription\n\nThis function enacts the iterative solver. It is called as part of the AbstractIterativeLinearSolver routine. SEE CODEREF for documentation on AbstractIterativeLinearSolver\n\nArguments\n\nlinearoperator!: (function). This applies the predefined linear operator on an array. Applies a linear operator to object \"y\" and overwrites object \"z\". It is a function with arguments linearoperator!(z,y, args...), where \"z\" gets overwritten by \"y\" and \"args...\" are additional arguments passed to the linear operator. The linear operator is assumed to return nothing.\nQ: (array). This is an object that linearoperator! overwrites\nQrhs: (array). This is an object that linearoperator! acts on. This is the rhs to the linear system\nsolver: (struct). This is a scruct for dispatch, in this case for ConjugateGradient\nthreshold: (float). Either an absolute or relative tolerance\napplyPC!: (function). Applies a preconditioner to objecy \"y\" and overwrites object \"z\". applyPC!(z,y)\nargs...: (arbitrary). This is necessary for the linearoperator! function which has a signature linearoperator!(b, x, args....)\n\nKeyword Arguments\n\nThere are no keyword arguments\n\nReturn\n\nconverged: (bool). A boolean to say whether or not the iterative solver has converged.\niteration: (int). Iteration number for the iterative solver\nthreshold: (float). The value of the residual for the first timestep\n\nComment\n\nThis function does conjugate gradient\n\n\n\n\n\nLS.doiteration!(linearoperator!, Q::MPIStateArray, Qrhs::MPIStateArray, solver::ColumnwisePreconditionedConjugateGradient, threshold, args...; applyPC!)\n\nDescription\n\nThis function enacts the iterative solver. It is called as part of the AbstractIterativeLinearSolver routine. SEE CODEREF for documentation on AbstractIterativeLinearSolver. THIS IS A HACK TO WORK WITH MPISTATEARRAYS. THE ISSUE IS WITH RESHAPE.\n\nArguments\n\nlinearoperator!: (function). This applies the predefined linear operator on an array. Applies a linear operator to object \"y\" and overwrites object \"z\". It is a function with arguments linearoperator!(z,y, args...), where \"z\" gets overwritten by \"y\" and \"args...\" are additional arguments passed to the linear operator. The linear operator is assumed to return nothing.\nQ: (array). This is an object that linearoperator! overwrites\nQrhs: (array). This is an object that linearoperator! acts on. This is the rhs to the linear system\nsolver: (struct). This is a scruct for dispatch, in this case for ConjugateGradient\nthreshold: (float). Either an absolute or relative tolerance\napplyPC!: (function). Applies a preconditioner to objecy \"y\" and overwrites object \"z\". applyPC!(z,y)\nargs...: (arbitrary). This is necessary for the linearoperator! function which has a signature linearoperator!(b, x, args....)\n\nKeyword Arguments\n\nThere are no keyword arguments\n\nReturn\n\nconverged: (bool). A boolean to say whether or not the iterative solver has converged.\niteration: (int). Iteration number for the iterative solver\nthreshold: (float). The value of the residual for the first timestep\n\nComment\n\nThis function does conjugate gradient\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#Shared-components-1","page":"LinearSolvers","title":"Shared components","text":"","category":"section"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#","page":"LinearSolvers","title":"LinearSolvers","text":"LinearSolvers.AbstractLinearSolver\nLinearSolvers.AbstractIterativeLinearSolver\nLinearSolvers.linearsolve!\nLinearSolvers.settolerance!\nLinearSolvers.prefactorize","category":"page"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#ClimateMachine.LinearSolvers.AbstractLinearSolver","page":"LinearSolvers","title":"ClimateMachine.LinearSolvers.AbstractLinearSolver","text":"AbstractLinearSolver\n\nThis is an abstract type representing a generic linear solver.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#ClimateMachine.LinearSolvers.AbstractIterativeLinearSolver","page":"LinearSolvers","title":"ClimateMachine.LinearSolvers.AbstractIterativeLinearSolver","text":"AbstractIterativeLinearSolver\n\nThis is an abstract type representing a generic iterative linear solver.\n\nThe available concrete implementations are:\n\nGeneralizedConjugateResidual\nGeneralizedMinimalResidual\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#ClimateMachine.LinearSolvers.linearsolve!","page":"LinearSolvers","title":"ClimateMachine.LinearSolvers.linearsolve!","text":"linearsolve!(linearoperator!, solver::AbstractIterativeLinearSolver, Q, Qrhs, args...)\n\nSolves a linear problem defined by the linearoperator! function and the state Qrhs, i.e,\n\nL(Q) = Q_rhs\n\nusing the solver and the initial guess Q. After the call Q contains the solution.  The arguments args is passed to linearoperator! when it is called.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#ClimateMachine.LinearSolvers.settolerance!","page":"LinearSolvers","title":"ClimateMachine.LinearSolvers.settolerance!","text":"settolerance!(solver::AbstractIterativeLinearSolver, tolerance, relative)\n\nSets the relative or absolute tolerance of the iterative linear solver solver to tolerance.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/LinearSolvers/LinearSolvers/#ClimateMachine.LinearSolvers.prefactorize","page":"LinearSolvers","title":"ClimateMachine.LinearSolvers.prefactorize","text":"prefactorize(linop!, linearsolver, args...)\n\nPrefactorize the in-place linear operator linop! for use with linearsolver.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#Microphysics-1","page":"Microphysics","title":"Microphysics","text":"","category":"section"},{"location":"APIs/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"CurrentModule = ClimateMachine.Microphysics","category":"page"},{"location":"APIs/Atmos/Microphysics/#Methods-1","page":"Microphysics","title":"Methods","text":"","category":"section"},{"location":"APIs/Atmos/Microphysics/#","page":"Microphysics","title":"Microphysics","text":"terminal_velocity\nconv_q_vap_to_q_liq\nconv_q_liq_to_q_rai_acnv\nconv_q_liq_to_q_rai_accr\nconv_q_rai_to_q_vap","category":"page"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.terminal_velocity","page":"Microphysics","title":"ClimateMachine.Microphysics.terminal_velocity","text":"terminal_velocity(q_rai, ρ)\n\nwhere:\n\nq_rai - rain water specific humidity\nρ     - density of air\n\nReturns the mass weighted average rain terminal velocity assuming Marshall Palmer 1948 distribution of rain drops.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.conv_q_vap_to_q_liq","page":"Microphysics","title":"ClimateMachine.Microphysics.conv_q_vap_to_q_liq","text":"conv_q_vap_to_q_liq(q_sat, q)\n\nwhere:\n\nq_sat - PhasePartition at equilibrium\nq     - current PhasePartition\n\nReturns the q_liq tendency due to condensation/evaporation. The tendency is obtained assuming a relaxation to equilibrium with constant timescale.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.conv_q_liq_to_q_rai_acnv","page":"Microphysics","title":"ClimateMachine.Microphysics.conv_q_liq_to_q_rai_acnv","text":"conv_q_liq_to_q_rai_acnv(q_liq)\n\nwhere:\n\nq_liq - is the liquid water specific humidity\n\nReturns the q_rai tendency due to collisions between cloud droplets (autoconversion) parametrized following Kessler 1995.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.conv_q_liq_to_q_rai_accr","page":"Microphysics","title":"ClimateMachine.Microphysics.conv_q_liq_to_q_rai_accr","text":"conv_q_liq_to_q_rai_accr(param_set, q_liq, q_rai, ρ)\n\nwhere:\n\nparam_set - is an AbstractParameterSet\nq_liq - is the liquid water specific humidity\nq_rai - is the rain water specific humidity\nρ - is the density of air\n\nReturns the q_rai tendency due to collisions between cloud droplets and rain drops (accretion) parametrized following Kessler 1995.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Atmos/Microphysics/#ClimateMachine.Microphysics.conv_q_rai_to_q_vap","page":"Microphysics","title":"ClimateMachine.Microphysics.conv_q_rai_to_q_vap","text":"conv_q_rai_to_q_vap(q_rai, q, T, p, ρ)\n\nwhere:\n\nq_rai - rain water specific humidity\nq - current PhasePartition\nT - temperature\np - pressure\nρ - air density\n\nReturns the q_rai tendency due to rain evaporation. Parameterized following Smolarkiewicz and Grabowski 1996.\n\n\n\n\n\n","category":"function"},{"location":"HowToGuides/Land/#Land-1","page":"Land","title":"Land","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/#AtmosModel-1","page":"AtmosModel","title":"AtmosModel","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/#AtmosModel-type-1","page":"AtmosModel","title":"AtmosModel type","text":"","category":"section"},{"location":"APIs/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"ClimateMachine.Atmos.AtmosModel","category":"page"},{"location":"APIs/Atmos/AtmosModel/#ClimateMachine.Atmos.AtmosModel","page":"AtmosModel","title":"ClimateMachine.Atmos.AtmosModel","text":"AtmosModel <: BalanceLaw\n\nA BalanceLaw for atmosphere modeling. Users may over-ride prescribed default values for each field.\n\nUsage\n\nAtmosModel(\n    param_set,\n    orientation,\n    ref_state,\n    turbulence,\n    hyperdiffusion,\n    moisture,\n    radiation,\n    source,\n    tracers,\n    boundarycondition,\n    init_state_conservative\n)\n\nFields\n\nparam_set\nParameter Set (type to dispatch on, e.g., planet parameters. See CLIMAParameters.jl package)\norientation\nOrientation (ClimateMachine.FlatOrientation(LES in a box) or ClimateMachine.SphericalOrientation)\nref_state\nReference State (For initial conditions, or for linearisation when using implicit solvers)\nturbulence\nTurbulence Closure (Equations for dynamics of under-resolved turbulent flows)\nhyperdiffusion\nHyperdiffusion Model (Equations for dynamics of high-order spatial wave attenuation)\nmoisture\nMoisture Model (Equations for dynamics of moist variables)\nprecipitation\nPrecipitation Model (Equations for dynamics of precipitating species)\nradiation\nRadiation Model (Equations for radiative fluxes)\nsource\nSource Terms (Problem specific source terms)\ntracers\nTracer Terms (Equations for dynamics of active and passive tracers)\nboundarycondition\nBoundary condition specification\ninit_state_conservative\nInitial Condition (Function to assign initial values of state variables)\ndata_config\nData Configuration (Helper field for experiment configuration)\n\n\n\n\n\n","category":"type"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Atmos/heldsuarez.jl\"","category":"page"},{"location":"generated/Atmos/heldsuarez/#Dry-atmosphere-GCM-with-Held-Suarez-forcing-1","page":"Dry Idealized GCM","title":"Dry atmosphere GCM with Held-Suarez forcing","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"The Held-Suarez setup (Held and Suarez, 1994) is a textbook example for a simplified atmospheric global circulation model configuration which has been used as a benchmark experiment for development of the dynamical cores (i.e., GCMs without continents, moisture or parametrization schemes of the physics) for atmospheric models.  It is forced by a thermal relaxation to a reference state and damped by linear (Rayleigh) friction. This example demonstrates how","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"to set up a ClimateMachine-Atmos GCM configuration;\nto select and save GCM diagnostics output.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"To begin, we load ClimateMachine and a few miscellaneous useful Julia packages.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"using Distributions\nusing Random\nusing StaticArrays","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"ClimateMachine specific modules needed to make this example work (e.g., we will need spectral filters, etc.).","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"using ClimateMachine\nusing ClimateMachine.Atmos\nusing ClimateMachine.ConfigTypes\nusing ClimateMachine.Diagnostics\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.Mesh.Grids\nusing ClimateMachine.Mesh.Filters\nusing ClimateMachine.TemperatureProfiles\nusing ClimateMachine.MoistThermodynamics\nusing ClimateMachine.VariableTemplates","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"ClimateMachine parameters are needed to have access to Earth's physical parameters.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"using CLIMAParameters\nusing CLIMAParameters.Planet: R_d, day, grav, cp_d, cv_d, planet_radius","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"We need to load the physical parameters for Earth to have an Earth-like simulation :).","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"struct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"Construct the Held-Suarez forcing function. We can view this as part the right-hand-side of our governing equations. It forces the total energy field in a way that the resulting steady-state velocity and temperature fields of the simulation resemble those of an idealized dry planet.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"function held_suarez_forcing!(\n    balance_law,\n    source,\n    state,\n    diffusive,\n    aux,\n    time::Real,\n    direction,\n)\n    FT = eltype(state)\n\n    # Parameters\n    T_ref::FT = 255 # reference temperature for Held-Suarez forcing (K)\n\n    # Extract the state\n    ρ = state.ρ\n    ρu = state.ρu\n    ρe = state.ρe\n\n    coord = aux.coord\n    e_int = internal_energy(\n        balance_law.moisture,\n        balance_law.orientation,\n        state,\n        aux,\n    )\n    T = air_temperature(balance_law.param_set, e_int)\n    _R_d = FT(R_d(balance_law.param_set))\n    _day = FT(day(balance_law.param_set))\n    _grav = FT(grav(balance_law.param_set))\n    _cp_d = FT(cp_d(balance_law.param_set))\n    _cv_d = FT(cv_d(balance_law.param_set))\n\n    # Held-Suarez parameters\n    k_a = FT(1 / (40 * _day))\n    k_f = FT(1 / _day)\n    k_s = FT(1 / (4 * _day))\n    ΔT_y = FT(60)\n    Δθ_z = FT(10)\n    T_equator = FT(315)\n    T_min = FT(200)\n    σ_b = FT(7 / 10)\n\n    # Held-Suarez forcing\n    φ = latitude(balance_law.orientation, aux)\n    p = air_pressure(balance_law.param_set, T, ρ)\n\n    ##TODO: replace _p0 with dynamic surface pressure in Δσ calculations to\n    #account for topography, but leave unchanged for calculations of σ involved\n    #in T_equil\n    _p0 = 1.01325e5\n    σ = p / _p0\n    exner_p = σ^(_R_d / _cp_d)\n    Δσ = (σ - σ_b) / (1 - σ_b)\n    height_factor = max(0, Δσ)\n    T_equil = (T_equator - ΔT_y * sin(φ)^2 - Δθ_z * log(σ) * cos(φ)^2) * exner_p\n    T_equil = max(T_min, T_equil)\n    k_T = k_a + (k_s - k_a) * height_factor * cos(φ)^4\n    k_v = k_f * height_factor\n\n    # Apply Held-Suarez forcing\n    source.ρu -= k_v * projection_tangential(balance_law, aux, ρu)\n    source.ρe -= k_T * ρ * _cv_d * (T - T_equil)\n    return nothing\nend\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-initial-condition-1","page":"Dry Idealized GCM","title":"Set initial condition","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"When using ClimateMachine, we need to define a function that sets the initial state of our model run. In our case, we use the reference state of the simulation (defined below) and add a little bit of noise. Note that the initial states includes a zero initial velocity field.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"function init_heldsuarez!(balance_law, state, aux, coordinates, time)\n    FT = eltype(state)\n\n    # Set initial state to reference state with random perturbation\n    rnd = FT(1.0 + rand(Uniform(-1e-3, 1e-3)))\n    state.ρ = aux.ref_state.ρ\n    state.ρu = SVector{3, FT}(0, 0, 0)\n    state.ρe = rnd * aux.ref_state.ρe\n\n    nothing\nend\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Initialize-ClimateMachine-1","page":"Dry Idealized GCM","title":"Initialize ClimateMachine","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"Before we do anything further, we need to initialize ClimateMachine. Among other things, this will initialize the MPI us.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"ClimateMachine.init()\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Setting-the-floating-type-precision-1","page":"Dry Idealized GCM","title":"Setting the floating-type precision","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"ClimateMachine allows us to run a model with different floating-type precisions, with lower precision we get our results faster, and with higher precision, we may get more accurate results, depending on the questions we are after.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"FT = Float32\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Setup-model-configuration-1","page":"Dry Idealized GCM","title":"Setup model configuration","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"Now that we have defined our forcing and initialization functions, and have initialized ClimateMachine, we can set up the model.","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-up-a-reference-state-1","page":"Dry Idealized GCM","title":"Set up a reference state","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"We start by setting up a reference state. This is simply a vector field that we subtract from the solutions to the governing equations to both improve numerical stability of the implicit time stepper and enable faster model spin-up. The reference state assumes hydrostatic balance and ideal gas law, with a pressure p_r(z) and density rho_r(z) that only depend on altitude z and are in hydrostatic balance with each other.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"In this example, the reference temperature field smoothly transitions from a linearly decaying profile near the surface to a constant temperature profile at the top of the domain.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"temp_profile_ref = DecayingTemperatureProfile{FT}(param_set)\nref_state = HydrostaticState(temp_profile_ref)\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-up-a-Rayleigh-sponge-layer-1","page":"Dry Idealized GCM","title":"Set up a Rayleigh sponge layer","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"To avoid wave reflection at the top of the domain, the model applies a sponge layer that linearly damps the momentum equations.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"domain_height = FT(30e3)               ## height of the computational domain (m)\nz_sponge = FT(12e3)                    ## height at which sponge begins (m)\nα_relax = FT(1 / 60 / 15)              ## sponge relaxation rate (1/s)\nexponent = FT(2)                       ## sponge exponent for squared-sinusoid profile\nu_relax = SVector(FT(0), FT(0), FT(0)) ## relaxation velocity (m/s)\nsponge = RayleighSponge(domain_height, z_sponge, α_relax, u_relax, exponent)\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-up-turbulence-models-1","page":"Dry Idealized GCM","title":"Set up turbulence models","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"In order to produce a stable simulation, we need to dissipate energy and enstrophy at the smallest scales of the developed flow field. To achieve this we set up diffusive forcing functions.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"c_smag = FT(0.21)   ## Smagorinsky constant\nτ_hyper = FT(4 * 3600) ## hyperdiffusion time scale\nturbulence_model = SmagorinskyLilly(c_smag)\nhyperdiffusion_model = StandardHyperDiffusion(FT(4 * 3600))\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Instantiate-the-model-1","page":"Dry Idealized GCM","title":"Instantiate the model","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"The Held Suarez setup was designed to produce an equilibrated state that is comparable to the zonal mean of the Earth’s atmosphere.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"model = AtmosModel{FT}(\n    AtmosGCMConfigType,\n    param_set;\n    ref_state = ref_state,\n    turbulence = turbulence_model,\n    hyperdiffusion = hyperdiffusion_model,\n    moisture = DryModel(),\n    source = (Gravity(), Coriolis(), held_suarez_forcing!, sponge),\n    init_state = init_heldsuarez!,\n)\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"This concludes the setup of the physical model!","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-up-the-driver-1","page":"Dry Idealized GCM","title":"Set up the driver","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"We just need to set up a few parameters that define the resolution of the discontinuous Galerkin method and for how long we want to run our model setup.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"poly_order = 5                        ## discontinuous Galerkin polynomial order\nn_horz = 2                            ## horizontal element number\nn_vert = 2                            ## vertical element number\nresolution = (n_horz, n_vert)\nn_days = 1                            ## experiment day number\ntimestart = FT(0)                     ## start time (s)\ntimeend = FT(n_days * day(param_set)) ## end time (s)\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"The next lines set up the spatial grid.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"driver_config = ClimateMachine.AtmosGCMConfiguration(\n    \"HeldSuarez\",\n    poly_order,\n    resolution,\n    domain_height,\n    param_set,\n    init_heldsuarez!;\n    model = model,\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"The next lines set up the time stepper.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"solver_config = ClimateMachine.SolverConfiguration(\n    timestart,\n    timeend,\n    driver_config,\n    Courant_number = FT(0.2),\n    init_on_cpu = true,\n    CFL_direction = HorizontalDirection(),\n    diffdir = HorizontalDirection(),\n);\nnothing #hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Set-up-spectral-exponential-filter-1","page":"Dry Idealized GCM","title":"Set up spectral exponential filter","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"After every completed time step we apply a spectral filter to remove remaining small-scale noise introduced by the numerical procedures. This assures that our run remains stable.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"filterorder = 10\nfilter = ExponentialFilter(solver_config.dg.grid, 0, filterorder)\ncbfilter = GenericCallbacks.EveryXSimulationSteps(1) do\n    Filters.apply!(\n        solver_config.Q,\n        1:size(solver_config.Q, 2),\n        solver_config.dg.grid,\n        filter,\n    )\n    nothing\nend","category":"page"},{"location":"generated/Atmos/heldsuarez/#Setup-diagnostic-output-1","page":"Dry Idealized GCM","title":"Setup diagnostic output","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"Choose frequency and resolution of output, and a diagnostics group (dgngrp) which defines output variables. This needs to be defined in diagnostics.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"interval = \"1000steps\"\n_planet_radius = FT(planet_radius(param_set))\ninfo = driver_config.config_info\nboundaries = [\n    FT(-90.0) FT(-180.0) _planet_radius\n    FT(90.0) FT(180.0) FT(_planet_radius + info.domain_height)\n]\nresolution = (FT(10), FT(10), FT(1000)) # in (deg, deg, m)\ninterpol = ClimateMachine.InterpolationConfiguration(\n    driver_config,\n    boundaries,\n    resolution,\n)\n\ndgn_config = setup_dump_state_and_aux_diagnostics(\n    interval,\n    driver_config.name,\n    interpol = interpol,\n    project = true,\n)\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#Run-the-model-1","page":"Dry Idealized GCM","title":"Run the model","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"Finally, we can run the model using the physical setup and solvers from above. We use the spectral filter in our callbacks after every time step, and collect the diagnostics output.","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"result = ClimateMachine.invoke!(\n    solver_config;\n    diagnostics_config = dgn_config,\n    user_callbacks = (cbfilter,),\n    check_euclidean_distance = true,\n)\nnothing # hide","category":"page"},{"location":"generated/Atmos/heldsuarez/#References-1","page":"Dry Idealized GCM","title":"References","text":"","category":"section"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"Held, I.M. and M.J. Suarez, 1994: A Proposal for the Intercomparison","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"the Dynamical Cores of Atmospheric General Circulation Models. Bull. # Amer. Meteor. Soc., 75, 1825–1830, https://doi.org/10.1175/1520-0477(1994)075<1825:APFTIO>2.0.CO;2","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"","category":"page"},{"location":"generated/Atmos/heldsuarez/#","page":"Dry Idealized GCM","title":"Dry Idealized GCM","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Atmos-Model-1","page":"AtmosModel","title":"Atmos Model","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"This page provides a summary of a specific type of balance law within the ClimateMachine source code, the AtmosModel. This documentation aims to introduce a user to the properties of the AtmosModel, including the balance law equations and default model configurations. Both LES and GCM configurations are included.","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Conservation-Equations-1","page":"AtmosModel","title":"Conservation Equations","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"The conservation equations specific to this implementation of AtmosModel are included below.","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Mass-1","page":"AtmosModel","title":"Mass","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"fracpartial rhopartial t + nablacdot (rhovecu) = rho mathcalhat S_q_t","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Momentum-1","page":"AtmosModel","title":"Momentum","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"frac(partial rhovecu)partial t + nablacdot left rhovecu otimes vecu + (p - p_r) vecI_3right =\n- (rho - rho_r) nablaPhi - 2vecOmega times rhovecu \n- nablacdot (rho vectau) - nablacdotleft( vecd_q_t otimes rhovecu right) + nablacdot left( q_c w_c vechat k otimes rho vecu right) + rho vecF_vecu","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Energy-1","page":"AtmosModel","title":"Energy","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":" fracpartial(rho e^mathrmtot)partial t + nablacdot left( (rho e^mathrmtot + p)vecu right)\n = -nablacdot (rho vecF_R) - nablacdot biglrho (vecJ + vecD)bigr + rho Q  \n  +nablacdot left(rho W_c vechat k right)  - nablacdot (vecu cdot rhovectau) + rho vecu cdot vecF_vecu \n   - sum_jinvli(I_j + Phi)  rho C(q_j rightarrow q_p) - M","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Moisture-1","page":"AtmosModel","title":"Moisture","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"fracpartial (rho q_t)partial t + nablacdot (rho q_t vecu)\n= rho mathcalS_q_t - nablacdot (rho vecd_q_t) + nablacdot bigl(rho q_c w_c vechat k  bigr)\nequiv rho mathcalhat S_q_t","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Precipitating-Species-1","page":"AtmosModel","title":"Precipitating Species","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"fracpartial (rho q_pi)partial t + nablacdot leftrho q_pi (vecu - w_pi vechat k) right =\nrho leftC(q_t rightarrow q_pi) + C(q_pk rightarrow q_pi) right -nablacdot (rho vecd_q_p i)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Tracer-Species-1","page":"AtmosModel","title":"Tracer Species","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"frac(partial rho chi_i)partial t + nablacdot left(rho chi_i vecu right) = rho mathcalS_chi_i - nablacdot (rho vecd_chi_i) + nablacdot (rho chi_i w_chi i vechat k)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Equation-Abstractions-1","page":"AtmosModel","title":"Equation Abstractions","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"fracpartial vecYpartial t = - nabla cdot (vecF_nondiff + vecF_diff + vecF_rad + vecF_precip) + vecS","category":"page"},{"location":"Theory/Atmos/AtmosModel/#State-Variables-1","page":"AtmosModel","title":"State Variables","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"vecY=left( beginarrayc\nrho \nrhovecu \nrho e^mathrmtot\nrho q_k\nrho q_pi\nrho chi_j\nendarray\nright)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Fluxes-1","page":"AtmosModel","title":"Fluxes","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#Nondiffusive-Fluxes-1","page":"AtmosModel","title":"Nondiffusive Fluxes","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":" mathrmF_nondiff=left( beginarrayc\n rho vecu \n rho vecu otimes vecu + (p - p_r) vecI_3 \n rho e^mathrmtot vecu + p vecu\n rho q_k vecu\n rho q_pi vecu \n rho chi_j vecu\nendarray\nright)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Diffusive-Fluxes-1","page":"AtmosModel","title":"Diffusive Fluxes","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"mathrmF_diff=left( beginarrayc\nrhovecd_q_t \nrhovectau + rhovecd_q_t otimes vecu\nvecu cdot rhovectau + rho (vecJ + vecD) \nrhovecd_q_k\nrho vecd_q_p i\nrho vecd_chi_j\nendarray\nright)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Radiation-Fluxes-1","page":"AtmosModel","title":"Radiation Fluxes","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"mathrmF_rad =\nleft( beginarrayc\nvec0 \nvec0 \nrho vecF_R \nvec0 \nvec0 \nvec0\nendarray\nright)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Fluxes-of-precipitating-species-1","page":"AtmosModel","title":"Fluxes of precipitating species","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"mathrmF_fall =\n- left( beginarrayc\nrho q_c w_c vechat k  \nq_c w_c vechat k otimes rho vecu  \nrho W_c vechat k \nrho q_k w_k vechat k  \nrho q_pi w_p i vechat k \nrho chi_i w_chi i vechat k\nendarray right)","category":"page"},{"location":"Theory/Atmos/AtmosModel/#Sources-1","page":"AtmosModel","title":"Sources","text":"","category":"section"},{"location":"Theory/Atmos/AtmosModel/#","page":"AtmosModel","title":"AtmosModel","text":"mathrmS(vecY nablavecY)=\n left( beginarrayc\n -rho C(q_t rightarrow q_p) \n  -(rho - rho_r) nablaPhi - 2 vecOmega times rhovecu  + rho vecF_vecu \n rho Q - sum_jinvli (I_j + Phi)  rho C(q_j rightarrow q_p) - M  + rho vecu cdot vecF_vecu  \nrho C(q_p rightarrow q_k) + rho sum_j rho C(q_j rightarrow q_k) \n    rho sum_k C(q_k rightarrow q_p i) - rho sum_j C(q_p i rightarrow q_p j)\nrho mathcalS_chi_i\nendarray\nright)","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/#Diagnostics-1","page":"List of variables","title":"Diagnostics","text":"","category":"section"},{"location":"APIs/Diagnostics/Diagnostics/#","page":"List of variables","title":"List of variables","text":"CurrentModule = ClimateMachine.Diagnostics","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/#Diagnostics-2","page":"List of variables","title":"Diagnostics","text":"","category":"section"},{"location":"APIs/Diagnostics/Diagnostics/#","page":"List of variables","title":"List of variables","text":"Diagnostics","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics","page":"List of variables","title":"ClimateMachine.Diagnostics","text":"Diagnostics\n\nAccumulate mean fields and covariance statistics on the computational grid.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Diagnostics/Diagnostics/#Diagnostic-Fields-1","page":"List of variables","title":"Diagnostic Fields","text":"","category":"section"},{"location":"APIs/Diagnostics/Diagnostics/#","page":"List of variables","title":"List of variables","text":"Diagnostics computes the physically relevant fields for postprocessing.","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/#Types-1","page":"List of variables","title":"Types","text":"","category":"section"},{"location":"APIs/Diagnostics/Diagnostics/#","page":"List of variables","title":"List of variables","text":"ClimateMachine.Diagnostics.VecGrad\nClimateMachine.Diagnostics.Vorticity","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.VecGrad","page":"List of variables","title":"ClimateMachine.Diagnostics.VecGrad","text":"VecGrad{FT <: AbstractFloat,\n     FTA2D <: AbstractArray{FT, 2},\n     FTA3D <: AbstractArray{FT, 3},}\n\nThis data structure stores the spatial gradients of a velocity field.\n\nFields\n\ndata\nDevice array storing the spatial gradient data\n∂₁u₁\nView of ∂u₁/∂x₁\n∂₂u₁\nView of ∂u₁/∂x₂\n∂₃u₁\nView of ∂u₁/∂x₃\n∂₁u₂\nView of ∂u₂/∂x₁\n∂₂u₂\nView of ∂u₂/∂x₂\n∂₃u₂\nView of ∂u₂/∂x₃\n∂₁u₃\nView of ∂u₃/∂x₁\n∂₂u₃\nView of ∂u₃/∂x₂\n∂₃u₃\nView of ∂u₃/∂x₃\n\nUsage\n\nVecGrad(Npl, Nel, ::Type{FT}) where {FT <: AbstractFloat}\n\nArguments for the inner constructor\n\nNpl: Number of local degrees of freedom in a spectral element\nNel: Number of spectral elements\nFT: Floating point precision\n\n\n\n\n\n","category":"type"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.Vorticity","page":"List of variables","title":"ClimateMachine.Diagnostics.Vorticity","text":"Vorticity{FT <: AbstractFloat,\n       FTA2D <: AbstractArray{FT, 2},\n       FTA3D <: AbstractArray{FT, 3},}\n\nThis data structure stores the vorticity of a velocity field.\n\nFields\n\ndata\nDevice array storing the vorticity data\nΩ₁\nView of x1 component of vorticity\nΩ₂\nView of x2 component of vorticity\nΩ₃\nView of x3 component of vorticity\n\nUsage\n\nVorticity(Npl, Nel, ::Type{FT}) where {FT <: AbstractFloat}\n\nArguments for the inner constructor\n\nNpl: Number of local degrees of freedom in a spectral element\nNel: Number of spectral elements\nFT: Floating point precision\n\n\n\n\n\n","category":"type"},{"location":"APIs/Diagnostics/Diagnostics/#Functions-1","page":"List of variables","title":"Functions","text":"","category":"section"},{"location":"APIs/Diagnostics/Diagnostics/#","page":"List of variables","title":"List of variables","text":"ClimateMachine.Diagnostics.compute_vec_grad\nClimateMachine.Diagnostics.compute_vorticity","category":"page"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.compute_vec_grad","page":"List of variables","title":"ClimateMachine.Diagnostics.compute_vec_grad","text":"compute_vec_grad(model::BalanceLaw,\n                     Q::AbstractArray{FT},\n                    dg::DGModel,\n                 vgrad::VecGrad{FT},) where {FT <: AbstractFloat}\n\nThis function computes the spatial gradients of the velocity field.\n\nArguments\n\nmodel: BalanceLaw\nQ: State array\ndg: DGmodel\nvgrad: Vector gradients\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/Diagnostics/#ClimateMachine.Diagnostics.compute_vorticity","page":"List of variables","title":"ClimateMachine.Diagnostics.compute_vorticity","text":"compute_vorticity(dg::DGModel,\n               vgrad::VecGrad{FT},\n                vort::Vorticity{FT},) where {FT <: AbstractFloat}\n\nThis function computes the vorticity of the velocity field.\n\nArguments\n\ndg: DGmodel\nvgrad: Velocity gradients\nvort: Vorticity\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#Moist-Thermodynamics-1","page":"Moist Thermodynamics","title":"Moist Thermodynamics","text":"","category":"section"},{"location":"APIs/Common/MoistThermodynamics/#","page":"Moist Thermodynamics","title":"Moist Thermodynamics","text":"CurrentModule = ClimateMachine.MoistThermodynamics","category":"page"},{"location":"APIs/Common/MoistThermodynamics/#Moist-Thermodynamics-2","page":"Moist Thermodynamics","title":"Moist Thermodynamics","text":"","category":"section"},{"location":"APIs/Common/MoistThermodynamics/#","page":"Moist Thermodynamics","title":"Moist Thermodynamics","text":"MoistThermodynamics","category":"page"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics","text":"MoistThermodynamics\n\nMoist thermodynamic functions, e.g., for air pressure (atmosphere equation of state), latent heats of phase transitions, saturation vapor pressures, and saturation specific humidities.\n\nAbstractParameterSet's\n\nMany functions defined in this module rely on CLIMAParameters.jl. CLIMAParameters.jl defines several functions (e.g., many planet parameters). For example, to compute the mole-mass ratio:\n\nusing CLIMAParameters.Planet: molmass_ratio\nusing CLIMAParameters: AbstractEarthParameterSet\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nparam_set = EarthParameterSet()\n_molmass_ratio = molmass_ratio(param_set)\n\nBecause these parameters are widely used throughout this module, param_set is an argument for many MoistThermodynamics functions.\n\n\n\n\n\n","category":"module"},{"location":"APIs/Common/MoistThermodynamics/#Thermodynamic-State-Constructors-1","page":"Moist Thermodynamics","title":"Thermodynamic State Constructors","text":"","category":"section"},{"location":"APIs/Common/MoistThermodynamics/#","page":"Moist Thermodynamics","title":"Moist Thermodynamics","text":"PhasePartition\nPhasePartition_equil\nThermodynamicState\nPhaseDry\nPhaseDry_given_pT\nPhaseDry_given_ρT\nPhaseEquil\nPhaseNonEquil\nTemperatureSHumEquil\nTemperatureSHumEquil_given_pressure\nLiquidIcePotTempSHumEquil\nLiquidIcePotTempSHumNonEquil\nLiquidIcePotTempSHumNonEquil_given_pressure","category":"page"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.PhasePartition","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.PhasePartition","text":"PhasePartition\n\nRepresents the mass fractions of the moist air mixture.\n\nConstructors\n\nPhasePartition(q_tot::Real[, q_liq::Real[, q_ice::Real]])\nPhasePartition(ts::ThermodynamicState)\n\nSee also PhasePartition_equil\n\nFields\n\ntot\ntotal specific humidity\nliq\nliquid water specific humidity (default: 0)\nice\nice specific humidity (default: 0)\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.PhasePartition_equil","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.PhasePartition_equil","text":"PhasePartition_equil(param_set, T, ρ, q_tot)\n\nPartition the phases in equilibrium, returning a PhasePartition object using the liquid_fraction function where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ (moist-)air density\nq_tot total specific humidity\n\nThe residual q.tot - q.liq - q.ice is the vapor specific humidity.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.ThermodynamicState","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.ThermodynamicState","text":"ThermodynamicState{FT}\n\nA thermodynamic state, which can be initialized for various thermodynamic formulations (via its sub-types). All ThermodynamicState's have access to functions to compute all other thermodynamic properties.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.PhaseDry","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.PhaseDry","text":"PhaseDry{FT} <: ThermodynamicState\n\nA dry thermodynamic state (q_tot = 0).\n\nConstructors\n\nPhaseDry(param_set, e_int, ρ)\n\nFields\n\nparam_set\nparameter set, used to dispatch planet parameter function calls\ne_int\ninternal energy\nρ\ndensity of dry air\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.PhaseDry_given_pT","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.PhaseDry_given_pT","text":"PhaseDry_given_pT(param_set, p, T)\n\nConstructs a PhaseDry thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\np pressure\nT temperature\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.PhaseDry_given_ρT","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.PhaseDry_given_ρT","text":"PhaseDry_given_ρT(param_set, ρ, T)\n\nConstructs a PhaseDry thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nρ density\nT temperature\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.PhaseEquil","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.PhaseEquil","text":"PhaseEquil{FT} <: ThermodynamicState\n\nA thermodynamic state assuming thermodynamic equilibrium (therefore, saturation adjustment may be needed).\n\nConstructors\n\nPhaseEquil(param_set, e_int, ρ, q_tot)\n\nFields\n\nparam_set\nparameter set, used to dispatch planet parameter function calls\ne_int\ninternal energy\nρ\ndensity of air (potentially moist)\nq_tot\ntotal specific humidity\nT\ntemperature: computed via saturation_adjustment\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.PhaseNonEquil","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.PhaseNonEquil","text":"PhaseNonEquil{FT} <: ThermodynamicState\n\nA thermodynamic state assuming thermodynamic non-equilibrium (therefore, temperature can be computed directly).\n\nConstructors\n\nPhaseNonEquil(param_set, e_int, q::PhasePartition, ρ)\n\nFields\n\nparam_set\nparameter set, used to dispatch planet parameter function calls\ne_int\ninternal energy\nρ\ndensity of air (potentially moist)\nq\nphase partition\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.TemperatureSHumEquil","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.TemperatureSHumEquil","text":"TemperatureSHumEquil(param_set, T, ρ, q_tot)\n\nConstructs a PhaseEquil thermodynamic state from temperature.\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ density\nq_tot total specific humidity\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.TemperatureSHumEquil_given_pressure","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.TemperatureSHumEquil_given_pressure","text":"TemperatureSHumEquil_given_pressure(param_set, T, p, q_tot)\n\nConstructs a PhaseEquil thermodynamic state from temperature.\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\np pressure\nq_tot total specific humidity\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.LiquidIcePotTempSHumEquil","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.LiquidIcePotTempSHumEquil","text":"LiquidIcePotTempSHumEquil(param_set, θ_liq_ice, ρ, q_tot)\n\nConstructs a PhaseEquil thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nθ_liq_ice liquid-ice potential temperature\nρ (moist-)air density\nq_tot total specific humidity\ntemperature_tol temperature tolerance for saturation adjustment\nmaxiter maximum iterations for saturation adjustment\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.LiquidIcePotTempSHumNonEquil","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.LiquidIcePotTempSHumNonEquil","text":"LiquidIcePotTempSHumNonEquil(param_set, θ_liq_ice, ρ, q_pt)\n\nConstructs a PhaseNonEquil thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nθ_liq_ice liquid-ice potential temperature\nρ (moist-)air density\nq_pt phase partition\n\nand, optionally\n\npotential_temperature_tol potential temperature for non-linear equation solve\nmaxiter maximum iterations for non-linear equation solve\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.LiquidIcePotTempSHumNonEquil_given_pressure","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.LiquidIcePotTempSHumNonEquil_given_pressure","text":"LiquidIcePotTempSHumNonEquil_given_pressure(param_set, θ_liq_ice, p, q_pt)\n\nConstructs a PhaseNonEquil thermodynamic state from:\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nθ_liq_ice liquid-ice potential temperature\np pressure\nq_pt phase partition\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#Thermodynamic-state-methods-1","page":"Moist Thermodynamics","title":"Thermodynamic state methods","text":"","category":"section"},{"location":"APIs/Common/MoistThermodynamics/#","page":"Moist Thermodynamics","title":"Moist Thermodynamics","text":"air_density\nair_pressure\nair_temperature\nair_temperature_from_liquid_ice_pottemp\ncp_m\ncv_m\ndry_pottemp\nexner\ngas_constant_air\nIce\ninternal_energy\ninternal_energy_sat\nlatent_heat_fusion\nlatent_heat_sublim\nlatent_heat_vapor\nLiquid\nliquid_fraction\nliquid_ice_pottemp\nliquid_ice_pottemp_sat\ngas_constants\nsaturation_adjustment\nsaturation_excess\nq_vap_saturation\nq_vap_saturation_generic\nsaturation_vapor_pressure\nsoundspeed_air\nspecific_volume\ntotal_energy\nvirtual_pottemp","category":"page"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.air_density","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.air_density","text":"air_density(param_set, T, p[, q::PhasePartition])\n\nThe (moist-)air density from the equation of state (ideal gas law) where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT air temperature\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nair_density(ts::ThermodynamicState)\n\nThe (moist-)air density, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.air_pressure","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.air_pressure","text":"air_pressure(param_set, T, ρ[, q::PhasePartition])\n\nThe air pressure from the equation of state (ideal gas law) where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT air temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nair_pressure(ts::ThermodynamicState)\n\nThe air pressure from the equation of state (ideal gas law), given a thermodynamic state ts.\n\n\n\n\n\nair_pressure(param_set, T::FT, T∞::FT, p∞::FT, ::DryAdiabaticProcess)\n\nThe air pressure for an isentropic process, where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nT∞ ambient temperature\np∞ ambient pressure\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.air_temperature","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.air_temperature","text":"air_temperature(param_set, e_int, q::PhasePartition)\n\nThe air temperature, where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\ne_int internal energy per unit mass\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nair_temperature(ts::ThermodynamicState)\n\nThe air temperature, given a thermodynamic state ts.\n\n\n\n\n\nair_temperature(param_set, p::FT, θ::FT, Φ::FT, ::DryAdiabaticProcess)\n\nThe air temperature for an isentropic process, where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\np pressure\nθ potential temperature\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.air_temperature_from_liquid_ice_pottemp","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.air_temperature_from_liquid_ice_pottemp","text":"air_temperature_from_liquid_ice_pottemp(param_set, θ_liq_ice, ρ, q::PhasePartition)\n\nThe temperature given\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nθ_liq_ice liquid-ice potential temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.cp_m","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.cp_m","text":"cp_m(param_set, [q::PhasePartition])\n\nThe isobaric specific heat capacity of moist air given\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\n\nand, optionally\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\ncp_m(ts::ThermodynamicState)\n\nThe isobaric specific heat capacity of moist air, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.cv_m","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.cv_m","text":"cv_m(param_set, [q::PhasePartition])\n\nThe isochoric specific heat capacity of moist air given\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\n\nand, optionally\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\ncv_m(ts::ThermodynamicState)\n\nThe isochoric specific heat capacity of moist air, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.dry_pottemp","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.dry_pottemp","text":"dry_pottemp(param_set, T, ρ[, q::PhasePartition])\n\nThe dry potential temperature where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\n\n\ndry_pottemp(ts::ThermodynamicState)\n\nThe dry potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.exner","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.exner","text":"exner(param_set, T, ρ[, q::PhasePartition)])\n\nThe Exner function where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nexner(ts::ThermodynamicState)\n\nThe Exner function, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.gas_constant_air","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.gas_constant_air","text":"gas_constant_air(param_set, [q::PhasePartition])\n\nThe specific gas constant of moist air given\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\ngas_constant_air(ts::ThermodynamicState)\n\nThe specific gas constant of moist air given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.Ice","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.Ice","text":"Ice <: Phase\n\nAn ice phase, to dispatch over saturation_vapor_pressure and q_vap_saturation_generic.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.internal_energy","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.internal_energy","text":"internal_energy(param_set, T[, q::PhasePartition])\n\nThe internal energy per unit mass, given a thermodynamic state ts or\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\ninternal_energy(ts::ThermodynamicState)\n\nThe internal energy per unit mass, given a thermodynamic state ts.\n\n\n\n\n\ninternal_energy(ρ::FT, ρe::FT, ρu::AbstractVector{FT}, e_pot::FT)\n\nThe internal energy per unit mass, given\n\nρ (moist-)air density\nρe total energy per unit volume\nρu momentum vector\ne_pot potential energy (e.g., gravitational) per unit mass\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.internal_energy_sat","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.internal_energy_sat","text":"internal_energy_sat(param_set, T, ρ, q_tot)\n\nThe internal energy per unit mass in thermodynamic equilibrium at saturation where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ (moist-)air density\nq_tot total specific humidity\n\n\n\n\n\ninternal_energy_sat(ts::ThermodynamicState)\n\nThe internal energy per unit mass in thermodynamic equilibrium at saturation, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.latent_heat_fusion","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.latent_heat_fusion","text":"latent_heat_fusion(param_set, T::FT) where {FT<:Real}\n\nThe specific latent heat of fusion where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\n\n\n\n\n\nlatent_heat_fusion(ts::ThermodynamicState)\n\nThe specific latent heat of fusion given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.latent_heat_sublim","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.latent_heat_sublim","text":"latent_heat_sublim(param_set, T::FT) where {FT<:Real}\n\nThe specific latent heat of sublimation where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\n\n\n\n\n\nlatent_heat_sublim(ts::ThermodynamicState)\n\nThe specific latent heat of sublimation given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.latent_heat_vapor","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.latent_heat_vapor","text":"latent_heat_vapor(param_set, T::FT) where {FT<:Real}\n\nThe specific latent heat of vaporization where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\n\n\n\n\n\nlatent_heat_vapor(ts::ThermodynamicState)\n\nThe specific latent heat of vaporization given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.Liquid","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.Liquid","text":"Liquid <: Phase\n\nA liquid phase, to dispatch over saturation_vapor_pressure and q_vap_saturation_generic.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.liquid_fraction","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.liquid_fraction","text":"liquid_fraction(param_set, T[, q::PhasePartition])\n\nThe fraction of condensate that is liquid where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nq PhasePartition\n\nIf q.liq or q.ice are nonzero, the liquid fraction is computed from them.\n\nOtherwise, phase equilibrium is assumed so that the fraction of liquid is a function that is 1 above T_freeze and goes to zero below T_freeze.\n\n\n\n\n\nliquid_fraction(ts::ThermodynamicState)\n\nThe fraction of condensate that is liquid given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.liquid_ice_pottemp","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.liquid_ice_pottemp","text":"liquid_ice_pottemp(param_set, T, ρ, q::PhasePartition)\n\nThe liquid-ice potential temperature where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nliquid_ice_pottemp(ts::ThermodynamicState)\n\nThe liquid-ice potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.liquid_ice_pottemp_sat","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.liquid_ice_pottemp_sat","text":"liquid_ice_pottemp_sat(param_set, T, ρ[, q::PhasePartition])\n\nThe saturated liquid ice potential temperature where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nliquid_ice_pottemp_sat(param_set, T, ρ, q_tot)\n\nThe saturated liquid ice potential temperature where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ (moist-)air density\nq_tot total specific humidity\n\n\n\n\n\nliquid_ice_pottemp_sat(ts::ThermodynamicState)\n\nThe liquid potential temperature given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.gas_constants","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.gas_constants","text":"(R_m, cp_m, cv_m, γ_m) = gas_constants(param_set, [q::PhasePartition])\n\nWrapper to compute all gas constants at once, where optionally,\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nq PhasePartition. Without this argument, the results are for dry air.\n\nThe function returns a tuple of\n\nR_m gas_constant_air\ncp_m cp_m\ncv_m cv_m\nγ_m = cp_m/cv_m\n\n\n\n\n\n(R_m, cp_m, cv_m, γ_m) = gas_constants(ts::ThermodynamicState)\n\nWrapper to compute all gas constants at once, given a thermodynamic state ts.\n\nThe function returns a tuple of\n\nR_m gas_constant_air\ncp_m cp_m\ncv_m cv_m\nγ_m = cp_m/cv_m\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.saturation_adjustment","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.saturation_adjustment","text":"saturation_adjustment(param_set, e_int, ρ, q_tot)\n\nCompute the temperature that is consistent with\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\ne_int internal energy\nρ (moist-)air density\nq_tot total specific humidity\ntol absolute tolerance for saturation adjustment iterations. Can be one of:\nSolutionTolerance() to stop when |x_2 - x_1| < tol\nResidualTolerance() to stop when |f(x)| < tol\nmaxiter maximum iterations for non-linear equation solve\n\nby finding the root of\n\ne_int - internal_energy_sat(param_set T ρ q_tot) = 0\n\nusing Newtons method with analytic gradients.\n\nSee also saturation_adjustment.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.saturation_excess","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.saturation_excess","text":"saturation_excess(param_set, T, ρ, q::PhasePartition)\n\nThe saturation excess in equilibrium where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ (moist-)air density\nq PhasePartition\n\nThe saturation excess is the difference between the total specific humidity q.tot and the saturation specific humidity in equilibrium, and it is defined to be nonzero only if this difference is positive.\n\n\n\n\n\nsaturation_excess(ts::ThermodynamicState)\n\nCompute the saturation excess in equilibrium, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.q_vap_saturation","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.q_vap_saturation","text":"q_vap_saturation(param_set, T, ρ[, q::PhasePartition])\n\nCompute the saturation specific humidity, given\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition\n\nIf the PhasePartition q is given, the saturation specific humidity is that of a mixture of liquid and ice, computed in a thermodynamically consistent way from the weighted sum of the latent heats of the respective phase transitions (Pressel et al., JAMES, 2015). That is, the saturation vapor pressure and from it the saturation specific humidity are computed from a weighted mean of the latent heats of vaporization and sublimation, with the weights given by the fractions of condensates q.liq/(q.liq + q.ice) and q.ice/(q.liq + q.ice) that are liquid and ice, respectively.\n\nIf the PhasePartition q is not given, or has zero liquid and ice specific humidities, the saturation specific humidity is that over a mixture of liquid and ice, with the fraction of liquid given by temperature dependent liquid_fraction(T) and the fraction of ice by the complement 1 - liquid_fraction(T).\n\n\n\n\n\nq_vap_saturation(ts::ThermodynamicState)\n\nCompute the saturation specific humidity, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.q_vap_saturation_generic","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.q_vap_saturation_generic","text":"q_vap_saturation_generic(param_set, T, ρ[; phase=Liquid()])\n\nCompute the saturation specific humidity over a plane surface of condensate, given\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nLiquid() indicating condensate is liquid\nIce() indicating condensate is ice\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.saturation_vapor_pressure","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.saturation_vapor_pressure","text":"saturation_vapor_pressure(param_set, T, Liquid())\n\nReturn the saturation vapor pressure over a plane liquid surface given\n\nT temperature\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nsaturationvaporpressure(param_set, T, Ice())\n\nReturn the saturation vapor pressure over a plane ice surface given\n\nT temperature\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nsaturationvaporpressure(paramset, T, LH0, Δcp)\n\nCompute the saturation vapor pressure over a plane surface by integration of the Clausius-Clapeyron relation.\n\nThe Clausius-Clapeyron relation\n\ndlog(p_v_sat)/dT = [LH_0 + Δcp * (T-T_0)]/(R_v*T^2)\n\nis integrated from the triple point temperature T_triple, using Kirchhoff's relation\n\nL = LH_0 + Δcp * (T - T_0)\n\nfor the specific latent heat L with constant isobaric specific heats of the phases. The linear dependence of the specific latent heat on temperature T allows analytic integration of the Clausius-Clapeyron relation to obtain the saturation vapor pressure p_v_sat as a function of the triple point pressure press_triple.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.soundspeed_air","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.soundspeed_air","text":"soundspeed_air(param_set, T[, q::PhasePartition])\n\nThe speed of sound in unstratified air, where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nsoundspeed_air(ts::ThermodynamicState)\n\nThe speed of sound in unstratified air given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.specific_volume","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.specific_volume","text":"specific_volume(ts::ThermodynamicState)\n\nThe (moist-)air specific volume, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.total_energy","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.total_energy","text":"total_energy(param_set, e_kin, e_pot, T[, q::PhasePartition])\n\nThe total energy per unit mass, given\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\ne_kin kinetic energy per unit mass\ne_pot potential energy per unit mass\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\ntotal_energy(e_kin, e_pot, ts::ThermodynamicState)\n\nThe total energy per unit mass given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/MoistThermodynamics/#ClimateMachine.MoistThermodynamics.virtual_pottemp","page":"Moist Thermodynamics","title":"ClimateMachine.MoistThermodynamics.virtual_pottemp","text":"virtual_pottemp(param_set, T, ρ[, q::PhasePartition])\n\nThe virtual temperature where\n\nparam_set an AbstractParameterSet, see the MoistThermodynamics for more details\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument, the results are for dry air.\n\n\n\n\n\nvirtual_pottemp(ts::ThermodynamicState)\n\nThe virtual potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Atmos/risingbubble.jl\"","category":"page"},{"location":"generated/Atmos/risingbubble/#EX-RTB-docs-1","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"In this example, we demonstrate the usage of the ClimateMachine AtmosModel machinery to solve the fluid dynamics of a thermal perturbation in a neutrally stratified background state defined by its uniform potential temperature. We solve a flow in a FlatOrientation (Box) configuration - this is representative of a large-eddy simulation. Several versions of the problem setup may be found in literature, but the general idea is to examine the vertical ascent of a thermal bubble (we can interpret these as simple representation of convective updrafts).","category":"page"},{"location":"generated/Atmos/risingbubble/#Description-of-experiment-1","page":"Rising Thermal Bubble","title":"Description of experiment","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Dry Rising Bubble (circular potential temperature perturbation)\nBoundaries\nImpenetrable(FreeSlip()) - no momentum flux, no mass flux through walls.\nImpermeable() - non-porous walls, i.e. no diffusive fluxes through  walls.\nLaterally periodic\nDomain - 2500m (horizontal) x 2500m (horizontal) x 2500m (vertical)\nResolution - 50m effective resolution\nTotal simulation time - 1000s\nMesh Aspect Ratio (Effective resolution) 1:1\nOverrides defaults for\nCPU Initialisation\nTime integrator\nSources\nSmagorinsky Coefficient\nDefault settings can be found in src/Driver/<files>.jl","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"note: Note\nThis experiment setup assumes that you have installed the ClimateMachine according to the instructions on the landing page. We assume the users' familiarity with the conservative form of the equations of motion for a compressible fluid (see the AtmosModel page).The following topics are covered in this examplePackage requirements\nDefining a model subtype for the set of conservation equations\nDefining the initial conditions\nApplying boundary conditions\nApplying source terms\nChoosing a turbulence model\nAdding tracers to the model\nChoosing a time-integrator\nChoosing diagnostics (output) configurationsThe following topics are not covered in this exampleDefining new boundary conditions\nDefining new turbulence models\nBuilding new time-integrators\nAdding diagnostic variables (beyond a standard pre-defined list of variables)","category":"page"},{"location":"generated/Atmos/risingbubble/#Boilerplate-(Using-Modules)-1","page":"Rising Thermal Bubble","title":"Boilerplate (Using Modules)","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/#[Skip-Section](@ref-init)-1","page":"Rising Thermal Bubble","title":"Skip Section","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Before setting up our experiment, we recognize that we need to import some pre-defined functions from other packages. Julia allows us to use existing modules (variable workspaces), or write our own to do so.  Complete documentation for the Julia module system can be found here.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"We need to use the ClimateMachine module! This imports all functions specific to atmospheric and ocean flow modelling.  While we do not cover the ins-and-outs of the contents of each of these we provide brief descriptions of the utility of each of the loaded packages.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"using ClimateMachine\nClimateMachine.init()\n\nusing ClimateMachine.Atmos","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Required so that we inherit the appropriate model types for the large-eddy simulation (LES) and global-circulation-model (GCM) configurations.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"using ClimateMachine.ConfigTypes","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Required so that we may define diagnostics configurations, e.g. choice of file-writer, choice of output variable sets, output-frequency and directory,","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"using ClimateMachine.Diagnostics","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Required so that we may define (or utilise existing functions) functions that are called-back or executed at frequencies of either timesteps, simulation-time, or wall-clock time.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"using ClimateMachine.GenericCallbacks","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Required so we load the appropriate functions for the time-integration component. Contains ODESolver methods.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"using ClimateMachine.ODESolvers","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Required for utility of spatial filtering functions (e.g. positivity preservation)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"using ClimateMachine.Mesh.Filters","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Required so functions for computation of temperature profiles.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"using ClimateMachine.TemperatureProfiles","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Required so functions for computation of moist thermodynamic quantities is enabled.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"using ClimateMachine.MoistThermodynamics","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Required so we may access our variable arrays by a sensible naming convention rather than by numerical array indices.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"using ClimateMachine.VariableTemplates","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Required so we may access planet parameters (CLIMAParameters specific to this problem include the gas constant, specific heats, mean-sea-level pressure, gravity and the Smagorinsky coefficient)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"In ClimateMachine we use StaticArrays for our variable arrays.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"using StaticArrays","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"We also use the Test package to help with unit tests and continuous integration systems to design sensible tests for our experiment to ensure new / modified blocks of code don't damage the fidelity of the physics. The test defined within this experiment is not a unit test for a specific subcomponent, but ensures time-integration of the defined problem conditions within a reasonable tolerance. Immediately useful macros and functions from this include @test and @testset which will allow us to define the testing parameter sets.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"using Test\n\nusing CLIMAParameters\nusing CLIMAParameters.Atmos.SubgridScale: C_smag\nusing CLIMAParameters.Planet: R_d, cp_d, cv_d, MSLP, grav\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()","category":"page"},{"location":"generated/Atmos/risingbubble/#init-1","page":"Rising Thermal Bubble","title":"Initial Conditions","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"This example of a rising thermal bubble can be classified as an initial value problem. We must (at the very least) assign values for the initial variables in a sensible manner. This example demonstrates the use of functions defined in the MoistThermodynamics package to generate the appropriate initial state for our problem.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"note: Note\nThe following variables are assigned in the initial conditionstate.ρ = Scalar quantity for initial density profile\nstate.ρu= 3-component vector for initial momentum profile\nstate.ρe= Scalar quantity for initial total-energy profile humidity\nstate.tracers.ρχ = Vector of four tracers (here, for demonstration only; we can interpret these as dye injections for visualisation purposes)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"function init_risingbubble!(bl, state, aux, (x, y, z), t)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Problem float-type","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    FT = eltype(state)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Unpack constant parameters","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    R_gas::FT = R_d(bl.param_set)\n    c_p::FT = cp_d(bl.param_set)\n    c_v::FT = cv_d(bl.param_set)\n    p0::FT = MSLP(bl.param_set)\n    _grav::FT = grav(bl.param_set)\n    γ::FT = c_p / c_v","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Define bubble center and background potential temperature","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    xc::FT = 1250\n    yc::FT = 1250\n    zc::FT = 1000\n    r = sqrt((x - xc)^2 + (y - yc)^2 + (z - zc)^2)\n    rc::FT = 500","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"TODO: clean this up, or add convenience function: This is configured in the reference hydrostatic state","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    θ_ref::FT = bl.ref_state.virtual_temperature_profile.T_surface\n    Δθ::FT = 0","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Compute temperature difference over bubble region","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    if r <= rc\n        Δθ = FT(5) * cospi(r / rc / 2)\n    end","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Compute perturbed thermodynamic state:","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    θ = θ_ref + Δθ                                      # potential temperature\n    π_exner = FT(1) - _grav / (c_p * θ) * z             # exner pressure\n    ρ = p0 / (R_gas * θ) * (π_exner)^(c_v / R_gas)      # density\n    T = θ * π_exner\n    e_int = internal_energy(bl.param_set, T)\n    ts = PhaseDry(bl.param_set, e_int, ρ)\n    ρu = SVector(FT(0), FT(0), FT(0))                   # momentum\n    #State (prognostic) variable assignment\n    e_kin = FT(0)                                       # kinetic energy\n    e_pot = gravitational_potential(bl.orientation, aux)# potential energy\n    ρe_tot = ρ * total_energy(e_kin, e_pot, ts)         # total energy\n\n    ρχ = FT(0)                                          # tracer","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"We inject tracers at the initial condition at some specified z coordinates","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    if 500 < z <= 550\n        ρχ += FT(0.05)\n    end","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"We want 4 tracers","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    ntracers = 4","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Define 4 tracers, (arbitrary scaling for this demo problem)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    ρχ = SVector{ntracers, FT}(ρχ, ρχ / 2, ρχ / 3, ρχ / 4)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Assign State Variables","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    state.ρ = ρ\n    state.ρu = ρu\n    state.ρe = ρe_tot\n    state.tracers.ρχ = ρχ\nend","category":"page"},{"location":"generated/Atmos/risingbubble/#config-helper-1","page":"Rising Thermal Bubble","title":"Model Configuration","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"We define a configuration function to assist in prescribing the physical model. The purpose of this is to populate the ClimateMachine.AtmosLESConfiguration with arguments appropriate to the problem being considered.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"function config_risingbubble(FT, N, resolution, xmax, ymax, zmax)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Choose an Explicit Multi-rate Solver from the existing ODESolvers options Apply the outer constructor to define the ode_solver. Here AtmosAcousticGravityLinearModel splits the acoustic-gravity wave components from the advection-diffusion dynamics. The 1D-IMEX method is less appropriate for the problem given the current mesh aspect ratio (1:1)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    ode_solver = ClimateMachine.MultirateSolverType(\n        linear_model = AtmosAcousticGravityLinearModel,\n        slow_method = LSRK144NiegemannDiehlBusch,\n        fast_method = LSRK144NiegemannDiehlBusch,\n        timestep_ratio = 10,\n    )","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Since we want four tracers, we specify this and include the appropriate diffusivity scaling coefficients (normally these would be physically informed but for this demonstration we use integers corresponding to the tracer index identifier)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    ntracers = 4\n    δ_χ = SVector{ntracers, FT}(1, 2, 3, 4)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"The model coefficient for the turbulence closure is defined via the CLIMAParameters package A reference state for the linearisation step is also defined.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    T_surface = FT(300)\n    T_min_ref = FT(0)\n    T_profile = DryAdiabaticProfile{FT}(param_set, T_surface, T_min_ref)\n    ref_state = HydrostaticState(T_profile)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"The fun part! Here we assemble the AtmosModel.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    #md # !!! note\n    #md #     Docs on model subcomponent options can be found here:\n    #md #     - [`param_set`](https://CliMA.github.io/CLIMAParameters.jl/latest/)\n    #md #     - [`turbulence`](@ref Turbulence-Closures-docs)\n    #md #     - [`hyperdiffusion`](@ref Hyperdiffusion-docs)\n    #md #     - [`source`](@ref atmos-sources)\n    #md #     - [`tracers`](@ref Tracers-docs)\n    #md #     - [`init_state`](@ref init)\n\n    _C_smag = FT(C_smag(param_set))\n    model = AtmosModel{FT}(\n        AtmosLESConfigType,                           # Flow in a box, requires the AtmosLESConfigType\n        param_set;                                    # Parameter set corresponding to earth parameters\n        turbulence = SmagorinskyLilly(_C_smag),       # Turbulence closure model\n        moisture = DryModel(),                        # Exclude moisture variables\n        hyperdiffusion = StandardHyperDiffusion(60),  # Hyperdiffusion (4th order) model\n        source = (Gravity(),),                        # Gravity is the only source term here\n        tracers = NTracers{ntracers, FT}(δ_χ),        # Tracer model with diffusivity coefficients\n        ref_state = ref_state,                        # Reference state\n        init_state_conservative = init_risingbubble!, # Apply the initial condition\n    )","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Finally, we pass a Problem Name string, the mesh information, and the model type to  the [AtmosLESConfiguration] object.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    config = ClimateMachine.AtmosLESConfiguration(\n        \"DryRisingBubble\",       # Problem title [String]\n        N,                       # Polynomial order [Int]\n        resolution,              # (Δx, Δy, Δz) effective resolution [m]\n        xmax,                    # Domain maximum size [m]\n        ymax,                    # Domain maximum size [m]\n        zmax,                    # Domain maximum size [m]\n        param_set,               # Parameter set.\n        init_risingbubble!,      # Function specifying initial condition\n        solver_type = ode_solver,# Time-integrator type\n        model = model,           # Model type\n    )\n    return config\nend","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"note: Note\nKeywords are used to specify some arguments (see appropriate source files).","category":"page"},{"location":"generated/Atmos/risingbubble/#config_diagnostics-1","page":"Rising Thermal Bubble","title":"Diagnostics","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Here we define the diagnostic configuration specific to this problem.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"function config_diagnostics(driver_config)\n    interval = \"10000steps\"\n    dgngrp = setup_atmos_default_diagnostics(interval, driver_config.name)\n    return ClimateMachine.DiagnosticsConfiguration([dgngrp])\nend\n\nfunction main()","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"These are essentially arguments passed to the config_risingbubble function.  For type consistency we explicitly define the problem floating-precision.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    FT = Float64","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"We need to specify the polynomial order for the DG discretization, effective resolution, simulation end-time, the domain bounds, and the courant-number for the time-integrator. Note how the time-integration components solver_config are distinct from the spatial / model components in driver_config. init_on_cpu is a helper keyword argument that forces problem initialisation on CPU (thereby allowing the use of random seeds, spline interpolants and other special functions at the initialisation step.)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    N = 4\n    Δh = FT(50)\n    Δv = FT(50)\n    resolution = (Δh, Δh, Δv)\n    xmax = FT(2500)\n    ymax = FT(2500)\n    zmax = FT(2500)\n    t0 = FT(0)\n    timeend = FT(1000)\n    CFL = FT(20)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Assign configurations so they can be passed to the invoke! function","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    driver_config = config_risingbubble(FT, N, resolution, xmax, ymax, zmax)\n    solver_config = ClimateMachine.SolverConfiguration(\n        t0,\n        timeend,\n        driver_config,\n        init_on_cpu = true,\n        Courant_number = CFL,\n    )\n    dgn_config = config_diagnostics(driver_config)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"User defined filter (TMAR positivity preserving filter)","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    cbtmarfilter = GenericCallbacks.EveryXSimulationSteps(1) do (init = false)\n        Filters.apply!(solver_config.Q, 6, solver_config.dg.grid, TMARFilter())\n        nothing\n    end","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Invoke solver (calls solve! function for time-integrator), pass the driver, solver and diagnostic config information.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    result = ClimateMachine.invoke!(\n        solver_config;\n        diagnostics_config = dgn_config,\n        user_callbacks = (cbtmarfilter,),\n        check_euclidean_distance = true,\n    )","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Check that the solution norm is reasonable.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"    @test isapprox(result, FT(1); atol = 1.5e-3)\nend","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"The experiment definition is now complete. Time to run it.","category":"page"},{"location":"generated/Atmos/risingbubble/#Running-the-Experiment-1","page":"Rising Thermal Bubble","title":"Running the Experiment","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"julia --project /experiments/AtmosLES/risingbubble.jl will run the experiment from the main ClimateMachine.jl directory, with diagnostics output at the intervals specified in config_diagnostics.  You can also prescribe command line arguments (docs pending, Driver.jl) for simulation update and output specifications.  For rapid turnaround, we recommend that you run this experiment on a GPU.","category":"page"},{"location":"generated/Atmos/risingbubble/#output-viz-1","page":"Rising Thermal Bubble","title":"Output Visualisation","text":"","category":"section"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"See the ClimateMachine command line arguments for generating output.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"Given VTK output,","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"VisIt\nParaview","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"are two commonly used programs for .vtu files.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"For NetCDF or JLD2 diagnostics you may use Julia's NCDatasets and JLD2 packages with a suitable plotting program.","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"main()","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"","category":"page"},{"location":"generated/Atmos/risingbubble/#","page":"Rising Thermal Bubble","title":"Rising Thermal Bubble","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/literate_markdown.jl\"","category":"page"},{"location":"generated/literate_markdown/#How-to-generate-a-literate-tutorial-file-1","page":"Notes on Literate","title":"How to generate a literate tutorial file","text":"","category":"section"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"To create an tutorial using ClimateMachine, please use Literate.jl, and consult the Literate documentation for questions.","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"For now, all literate tutorials are held in the tutorials directory","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"With Literate, all comments turn into markdown text and any Julia code is read and run as if it is in the Julia REPL. As a small caveat to this, you might need to suppress the output of certain commands. For example, if you define and run the following function","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"function f()\n    return x = [i * i for i in 1:10]\nend\n\nx = f()","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"The entire list will be output, while","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"f();\nnothing #hide","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"does not (because of the ;).","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"To show plots, you may do something like the following:","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"using Plots\nplot(x)","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"Please consider writing the comments in your tutorial as if they are meant to be read as an article explaining the topic the tutorial is meant to explain. If there are any specific nuances to writing Literate documentation for ClimateMachine, please let us know!","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"","category":"page"},{"location":"generated/literate_markdown/#","page":"Notes on Literate","title":"Notes on Literate","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#Meshing-Stuff-1","page":"Meshes","title":"Meshing Stuff","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/#","page":"Meshes","title":"Meshes","text":"CurrentModule = ClimateMachine.Mesh","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#Topologies-1","page":"Meshes","title":"Topologies","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/#","page":"Meshes","title":"Meshes","text":"Topologies encode the connectivity of the elements, spatial domain interval and MPI communication.","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#Types-1","page":"Meshes","title":"Types","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/#","page":"Meshes","title":"Meshes","text":"Topologies.AbstractTopology\nTopologies.BoxElementTopology\nTopologies.BrickTopology\nTopologies.StackedBrickTopology\nTopologies.CubedShellTopology\nTopologies.StackedCubedSphereTopology","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.AbstractTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.AbstractTopology","text":"AbstractTopology{dim}\n\nRepresents the connectivity of individual elements, with local dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.BoxElementTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.BoxElementTopology","text":"BoxElementTopology{dim, T} <: AbstractTopology{dim}\n\nThe local topology of a larger MPI-distributed topology, represented by dim-dimensional box elements.\n\nThis contains the necessary information for the connectivity elements of the elements on the local process, along with \"ghost\" elements from neighbouring processes.\n\nFields\n\nmpicomm\nMPI communicator for communicating with neighbouring processes.\n\nelems\nRange of element indices\n\nrealelems\nRange of real (aka nonghost) element indices\n\nghostelems\nRange of ghost element indices\n\nghostfaces\nGhost element to face is received; ghostfaces[f,ge] == true if face f of ghost element ge is received.\n\nsendelems\nArray of send element indices\n\nsendfaces\nSend element to face is sent; sendfaces[f,se] == true if face f of send element se is sent.\n\ninteriorelems\nArray of real elements that do not have a ghost element as a neighbor.\n\nexteriorelems\nArray of real elements that have at least on ghost element as a neighbor.\nNote that this is different from sendelems because sendelems duplicates elements that need to be sent to multiple neighboring processes.\n\nelemtocoord\nElement to vertex coordinates; elemtocoord[d,i,e] is the dth coordinate of corner i of element e\nnote: Note\ncurrently coordinates always are of size 3 for (x1, x2, x3)\n\nelemtoelem\nElement to neighboring element; elemtoelem[f,e] is the number of the element neighboring element e across face f.  If there is no neighboring element then elemtoelem[f,e] == e.\n\nelemtoface\nElement to neighboring element face; elemtoface[f,e] is the face number of the element neighboring element e across face f.  If there is no neighboring element then elemtoface[f,e] == f.\"\n\nelemtoordr\nelement to neighboring element order; elemtoordr[f,e] is the ordering number of the element neighboring element e across face f.  If there is no neighboring element then elemtoordr[f,e] == 1.\n\nelemtobndy\nElement to boundary number; elemtobndy[f,e] is the boundary number of face f of element e.  If there is a neighboring element then elemtobndy[f,e] == 0.\n\nnabrtorank\nList of the MPI ranks for the neighboring processes\n\nnabrtorecv\nRange in ghost elements to receive for each neighbor\n\nnabrtosend\nRange in sendelems to send for each neighbor\n\norigsendorder\noriginal order in partitioning\n\nhasboundary\nboolean for whether or not this topology has a boundary\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.BrickTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.BrickTopology","text":"BrickTopology{dim, T} <: AbstractTopology{dim}\n\nA simple grid-based topology. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.StackedBrickTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.StackedBrickTopology","text":"StackedBrickTopology{dim, T} <: AbstractTopology{dim}\n\nA simple grid-based topology, where all elements on the trailing dimension are stacked to be contiguous. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.CubedShellTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.CubedShellTopology","text":"CubedShellTopology{T} <: AbstractTopology{2}\n\nA cube-shell topology. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology","text":"StackedCubedSphereTopology{3, T} <: AbstractTopology{3}\n\nA cube-sphere topology. All elements on the same \"vertical\" dimension are stacked to be contiguous. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#Constructors-1","page":"Meshes","title":"Constructors","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/#","page":"Meshes","title":"Meshes","text":"Topologies.BrickTopology(mpicomm, Nelems)\nTopologies.StackedBrickTopology(mpicomm, elemrange)\nTopologies.CubedShellTopology(mpicomm, Neside, T)\nTopologies.StackedCubedSphereTopology(mpicomm, Nhorz, Rrange)","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.BrickTopology-Tuple{Any,Any}","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.BrickTopology","text":"BrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)\n\nGenerate a brick mesh topology with coordinates given by the tuple elemrange and the periodic dimensions given by the periodicity tuple.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.\n\nBy default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in boundary.  This will mark the nonperiodic brick faces with the given boundary number.\n\nExamples\n\nWe can build a 3 by 2 element two-dimensional mesh that is periodic in the x2-direction with\n\n\nusing ClimateMachine.Topologies\nusing MPI\nMPI.Init()\ntopology = BrickTopology(MPI.COMM_SELF, (2:5,4:6);\n                         periodicity=(false,true),\n                         boundary=((1,2),(3,4)))\n\nThis returns the mesh structure for\n\n         x2\n\n          ^\n          |\n         6-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  3  |  4  |  5  |\n          |  |     |     |     |\n         5-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  1  |  2  |  6  |\n          |  |     |     |     |\n         4-  +-----+-----+-----+\n          |\n          +--|-----|-----|-----|--> x1\n             2     3     4     5\n\nFor example, the (dimension by number of corners by number of elements) array elemtocoord gives the coordinates of the corners of each element.\n\njulia> topology.elemtocoord\n2×4×6 Array{Int64,3}:\n[:, :, 1] =\n 2  3  2  3\n 4  4  5  5\n\n[:, :, 2] =\n 3  4  3  4\n 4  4  5  5\n\n[:, :, 3] =\n 2  3  2  3\n 5  5  6  6\n\n[:, :, 4] =\n 3  4  3  4\n 5  5  6  6\n\n[:, :, 5] =\n 4  5  4  5\n 5  5  6  6\n\n[:, :, 6] =\n 4  5  4  5\n 4  4  5  5\n\nNote that the corners are listed in Cartesian order.\n\nThe (number of faces by number of elements) array elemtobndy gives the boundary number for each face of each element.  A zero will be given for connected faces.\n\njulia> topology.elemtobndy\n4×6 Array{Int64,2}:\n 1  0  1  0  0  0\n 0  0  0  0  2  2\n 0  0  0  0  0  0\n 0  0  0  0  0  0\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.StackedBrickTopology-Tuple{Any,Any}","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.StackedBrickTopology","text":"StackedBrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)\n\nGenerate a stacked brick mesh topology with coordinates given by the tuple elemrange and the periodic dimensions given by the periodicity tuple.\n\nThe elements are stacked such that the elements associated with range elemrange[dim] are contiguous in the element ordering.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.  Further, stacks are not split at MPI boundaries.\n\nBy default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in boundary.  This will mark the nonperiodic brick faces with the given boundary number.\n\nExamples\n\nWe can build a 3 by 2 element two-dimensional mesh that is periodic in the x2-direction with\n\n\nusing ClimateMachine.Topologies\nusing MPI\nMPI.Init()\ntopology = StackedBrickTopology(MPI.COMM_SELF, (2:5,4:6);\n                                periodicity=(false,true),\n                                boundary=((1,2),(3,4)))\n\nThis returns the mesh structure stacked in the x2-direction for\n\n         x2\n\n          ^\n          |\n         6-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  2  |  4  |  6  |\n          |  |     |     |     |\n         5-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  1  |  3  |  5  |\n          |  |     |     |     |\n         4-  +-----+-----+-----+\n          |\n          +--|-----|-----|-----|--> x1\n             2     3     4     5\n\nFor example, the (dimension by number of corners by number of elements) array elemtocoord gives the coordinates of the corners of each element.\n\njulia> topology.elemtocoord\n2×4×6 Array{Int64,3}:\n[:, :, 1] =\n 2  3  2  3\n 4  4  5  5\n\n[:, :, 2] =\n 2  3  2  3\n 5  5  6  6\n\n[:, :, 3] =\n 3  4  3  4\n 4  4  5  5\n\n[:, :, 4] =\n 3  4  3  4\n 5  5  6  6\n\n[:, :, 5] =\n 4  5  4  5\n 4  4  5  5\n\n[:, :, 6] =\n 4  5  4  5\n 5  5  6  6\n\nNote that the corners are listed in Cartesian order.\n\nThe (number of faces by number of elements) array elemtobndy gives the boundary number for each face of each element.  A zero will be given for connected faces.\n\njulia> topology.elemtobndy\n4×6 Array{Int64,2}:\n 1  0  1  0  0  0\n 0  0  0  0  2  2\n 0  0  0  0  0  0\n 0  0  0  0  0  0\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.CubedShellTopology-Tuple{Any,Any,Any}","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.CubedShellTopology","text":"CubedShellTopology(mpicomm, Nelem, T) <: AbstractTopology{dim}\n\nGenerate a cubed shell mesh with the number of elements along each dimension of the cubes being Nelem. This topology actual creates a cube mesh, and the warping should be done after the grid is created using the cubedshellwarp function. The coordinates of the points will be of type T.\n\nThe elements of the shell are partitioned equally across the MPI ranks based on a space-filling curve.\n\nNote that this topology is logically 2-D but embedded in a 3-D space\n\nExamples\n\nWe can build a cubed shell mesh with 10 elements on each cube, total elements is 10 * 10 * 6 = 600, with\n\nusing ClimateMachine.Topologies\nusing MPI\nMPI.Init()\ntopology = CubedShellTopology(MPI.COMM_SELF, 10, Float64)\n\n# Typically the warping would be done after the grid is created, but the cell\n# corners could be warped with...\n\n# Shell radius = 1\nx1, x2, x3 = ntuple(j->topology.elemtocoord[j, :, :], 3)\nfor n = 1:length(x1)\n   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])\nend\n\n# Shell radius = 10\nx1, x2, x3 = ntuple(j->topology.elemtocoord[j, :, :], 3)\nfor n = 1:length(x1)\n  x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n], 10)\nend\n\n\n\n\n\n","category":"method"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology-Tuple{Any,Any,Any}","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology","text":"StackedCubedSphereTopology(mpicomm, Nhorz, Rrange;                               boundary=(1,1)) <: AbstractTopology{3}\n\nGenerate a stacked cubed sphere topology with Nhorz by Nhorz cells for each horizontal face and Rrange is the radius edges of the stacked elements.  This topology actual creates a cube mesh, and the warping should be done after the grid is created using the cubedshellwarp function. The coordinates of the points will be of type eltype(Rrange). The inner boundary condition type is boundary[1] and the outer boundary condition type is boundary[2].\n\nThe elements are stacked such that the vertical elements are contiguous in the element ordering.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve. Further, stacks are not split at MPI boundaries.\n\nExamples\n\nWe can build a cubed sphere mesh with 10 x 10 x 5 elements on each cube, total elements is 10 * 10 * 5 * 6 = 3000, with\n\nusing ClimateMachine.Topologies\nusing MPI\nMPI.Init()\nNhorz = 10\nNstack = 5\nRrange = Float64.(accumulate(+,1:Nstack+1))\ntopology = StackedCubedSphereTopology(MPI.COMM_SELF, Nhorz, Rrange)\n\nx1, x2, x3 = ntuple(j->reshape(topology.elemtocoord[j, :, :],\n                            2, 2, 2, length(topology.elems)), 3)\nfor n = 1:length(x1)\n   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])\nend\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"APIs/Numerics/Meshes/Mesh/#Functions-1","page":"Meshes","title":"Functions","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/#","page":"Meshes","title":"Meshes","text":"Topologies.cubedshellmesh\nTopologies.cubedshellwarp\nTopologies.hasboundary","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.cubedshellmesh","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.cubedshellmesh","text":"cubedshellmesh(T, Ne; part=1, numparts=1)\n\nGenerate a cubed mesh with each of the \"cubes\" has an Ne X Ne grid of elements.\n\nThe mesh can optionally be partitioned into numparts and this returns partition part.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.\n\nThis mesh returns the cubed spehere in a flatten fashion for the vertex values, and a remapping is needed to embed the mesh in a 3-D space.\n\nThe mesh structures for the cubes is as follows:\n\nx2\n   ^\n   |\n4Ne-           +-------+\n   |           |       |\n   |           |   6   |\n   |           |       |\n3Ne-           +-------+\n   |           |       |\n   |           |   5   |\n   |           |       |\n2Ne-           +-------+\n   |           |       |\n   |           |   4   |\n   |           |       |\n Ne-   +-------+-------+-------+\n   |   |       |       |       |\n   |   |   1   |   2   |   3   |\n   |   |       |       |       |\n  0-   +-------+-------+-------+\n   |\n   +---|-------|-------|------|-> x1\n       0      Ne      2Ne    3Ne\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.cubedshellwarp","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.cubedshellwarp","text":"cubedshellwarp(a, b, c, R = max(abs(a), abs(b), abs(c)))\n\nGiven points (a, b, c) on the surface of a cube, warp the points out to a spherical shell of radius R based on the equiangular gnomonic grid proposed by Ronchi, Iacono, Paolucci (1996) https://doi.org/10.1006/jcph.1996.0047\n\n@article{RonchiIaconoPaolucci1996,\n  title={The ``cubed sphere'': a new method for the solution of partial\n         differential equations in spherical geometry},\n  author={Ronchi, C. and Iacono, R. and Paolucci, P. S.},\n  journal={Journal of Computational Physics},\n  volume={124},\n  number={1},\n  pages={93--114},\n  year={1996},\n  doi={10.1006/jcph.1996.0047}\n}\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Topologies.hasboundary","page":"Meshes","title":"ClimateMachine.Mesh.Topologies.hasboundary","text":"hasboundary(topology::AbstractTopology)\n\nquery function to check whether a topology has a boundary (i.e., not fully periodic)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#Grids-1","page":"Meshes","title":"Grids","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/#","page":"Meshes","title":"Meshes","text":"Grids specify the approximation within each element, and any necessary warping.","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#","page":"Meshes","title":"Meshes","text":"Grids.DiscontinuousSpectralElementGrid","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Grids.DiscontinuousSpectralElementGrid","page":"Meshes","title":"ClimateMachine.Mesh.Grids.DiscontinuousSpectralElementGrid","text":"DiscontinuousSpectralElementGrid(topology; FloatType, DeviceArray,\n                                 polynomialorder,\n                                 meshwarp = (x...)->identity(x))\n\nGenerate a discontinuous spectral element (tensor product, Legendre-Gauss-Lobatto) grid/mesh from a topology, where the order of the elements is given by polynomialorder. DeviceArray gives the array type used to store the data (CuArray or Array), and the coordinate points will be of FloatType.\n\nThe optional meshwarp function allows the coordinate points to be warped after the mesh is created; the mesh degrees of freedom are orginally assigned using a trilinear blend of the element corner locations.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#Filters-1","page":"Meshes","title":"Filters","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/#","page":"Meshes","title":"Meshes","text":"There are methods used to cleanup state vectors.","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#","page":"Meshes","title":"Meshes","text":"Filters.CutoffFilter\nFilters.ExponentialFilter\nFilters.TMARFilter","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Filters.CutoffFilter","page":"Meshes","title":"ClimateMachine.Mesh.Filters.CutoffFilter","text":"CutoffFilter(grid, Nc=polynomialorder(grid))\n\nReturns the spectral filter that zeros out polynomial modes greater than or equal to Nc.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Filters.ExponentialFilter","page":"Meshes","title":"ClimateMachine.Mesh.Filters.ExponentialFilter","text":"ExponentialFilter(grid, Nc=0, s=32, α=-log(eps(eltype(grid))))\n\nReturns the spectral filter with the filter function\n\nσ(η) = xp(-α η^s)\n\nwhere s is the filter order (must be even), the filter starts with polynomial order Nc, and alpha is a parameter controlling the smallest value of the filter function.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Filters.TMARFilter","page":"Meshes","title":"ClimateMachine.Mesh.Filters.TMARFilter","text":"TMARFilter()\n\nReturns the truncation and mass aware rescaling nonnegativity preservation filter.  The details of this filter are described in\n\n@article{doi:10.1175/MWR-D-16-0220.1,\n  author = {Light, Devin and Durran, Dale},\n  title = {Preserving Nonnegativity in Discontinuous Galerkin\n           Approximations to Scalar Transport via Truncation and Mass\n           Aware Rescaling (TMAR)},\n  journal = {Monthly Weather Review},\n  volume = {144},\n  number = {12},\n  pages = {4771-4786},\n  year = {2016},\n  doi = {10.1175/MWR-D-16-0220.1},\n}\n\nNote this needs to be used with a restrictive time step or a flux correction to ensure that grid integral is conserved.\n\nExamples\n\nThis filter can be applied to the 3rd and 4th fields of an MPIStateArray Q with the code\n\nFilters.apply!(Q, (3, 4), grid, TMARFilter())\n\nwhere grid is the associated DiscontinuousSpectralElementGrid.\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#Interpolation-1","page":"Meshes","title":"Interpolation","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/#Types-2","page":"Meshes","title":"Types","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/#","page":"Meshes","title":"Meshes","text":"Interpolation.InterpolationBrick\nInterpolation.InterpolationCubedSphere","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Interpolation.InterpolationBrick","page":"Meshes","title":"ClimateMachine.Mesh.Interpolation.InterpolationBrick","text":"InterpolationBrick{\nFT <: AbstractFloat,\nT <: Int,\nFTV <: AbstractVector{FT},\nFTVD <: AbstractVector{FT},\nTVD <: AbstractVector{T},\nFTA2 <: Array{FT, 2},\nUI8AD <: AbstractArray{UInt8, 2},\nUI16VD <: AbstractVector{UInt16},\nI32V <: AbstractVector{Int32},\n} <: InterpolationTopology\n\nThis interpolation data structure and the corresponding functions works for a brick, where stretching/compression happens only along the x1, x2 & x3 axis. Here x1 = X1(ξ1), x2 = X2(ξ2) and x3 = X3(ξ3).\n\nFields\n\nNel\nNumber of elements\nNp\nTotal number of interpolation points\nNpl\nTotal number of interpolation points on local process\npoly_order\nPolynomial order of spectral element approximation\nxbnd\nDomain bounds in x1, x2 and x3 directions\nx1g\nInterpolation grid in x1 direction\nx2g\nInterpolation grid in x2 direction\nx3g\nInterpolation grid in x3 direction\nξ1\nUnique ξ1 coordinates of interpolation points within each spectral element\nξ2\nUnique ξ2 coordinates of interpolation points within each spectral element\nξ3\nUnique ξ3 coordinates of interpolation points within each spectral element\nflg\nFlags when ξ1/ξ2/ξ3 interpolation point matches with a GLL point\nfac\nNormalization factor\nx1i\nx1 interpolation grid index of interpolation points within each element on the local process\nx2i\nx2 interpolation grid index of interpolation points within each element on the local process\nx3i\nx3 interpolation grid index of interpolation points within each element on the local process\noffset\nOffsets for each element\nm1_r\nGLL points\nm1_w\nGLL weights\nwb\nBarycentric weights\nNp_all\nNumber of interpolation points on each of the processes\nx1i_all\nx1 interpolation grid index of interpolation points within each element on all processes stored only on proc 0\nx2i_all\nx2 interpolation grid index of interpolation points within each element on all processes stored only on proc 0\nx3i_all\nx3 interpolation grid index of interpolation points within each element on all processes stored only on proc 0\n\nUsage\n\nInterpolationBrick(grid::DiscontinuousSpectralElementGrid{FT}, xbnd::Array{FT,2}, xres) where FT <: AbstractFloat\n\nThis interpolation structure and the corresponding functions works for a brick, where stretching/compression happens only along the x1, x2 & x3 axis. Here x1 = X1(ξ1), x2 = X2(ξ2) and x3 = X3(ξ3).\n\nArguments for the inner constructor\n\ngrid: DiscontinousSpectralElementGrid\nxbnd: Domain boundaries in x1, x2 and x3 directions\nxres: Resolution of the interpolation grid in x1, x2 and x3 directions\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Interpolation.InterpolationCubedSphere","page":"Meshes","title":"ClimateMachine.Mesh.Interpolation.InterpolationCubedSphere","text":"InterpolationCubedSphere{\nFT <: AbstractFloat,\nT <: Int,\nFTV <: AbstractVector{FT},\nFTVD <: AbstractVector{FT},\nTVD <: AbstractVector{T},\nUI8AD <: AbstractArray{UInt8, 2},\nUI16VD <: AbstractVector{UInt16},\nI32V <: AbstractVector{Int32},\n} <: InterpolationTopology\n\nThis interpolation structure and the corresponding functions works for a cubed sphere topology. The data is interpolated along a lat/long/rad grid.\n\n-90⁰  ≤ lat  ≤ 90⁰\n\n-180⁰ ≤ long ≤ 180⁰\n\nRᵢ ≤ r ≤ Rₒ\n\nFields\n\nNel\nNumber of elements\nNp\nNumber of interpolation points\nNpl\nNumber of interpolation points on local process\npoly_order\nPolynomial order of spectral element approximation\nn_rad\nNumber of interpolation points in radial direction\nn_lat\nNumber of interpolation points in lat direction\nn_long\nNumber of interpolation points in long direction\nrad_grd\nInterpolation grid in radial direction\nlat_grd\nInterpolation grid in lat direction\nlong_grd\nInterpolation grid in long direction\nξ1\nDevice array containing ξ1 coordinates of interpolation points within each element\nξ2\nDevice array containing ξ2 coordinates of interpolation points within each element\nξ3\nDevice array containing ξ3 coordinates of interpolation points within each element\nflg\nflags when ξ1/ξ2/ξ3 interpolation point matches with a GLL point\nfac\nNormalization factor\nradi\nRadial coordinates of interpolation points withing each element\nlati\nLatitude coordinates of interpolation points withing each element\nlongi\nLongitude coordinates of interpolation points withing each element\noffset\nOffsets for each element\nm1_r\nGLL points\nm1_w\nGLL weights\nwb\nBarycentric weights\nNp_all\nNumber of interpolation points on each of the processes\nradi_all\nRadial interpolation grid index of interpolation points within each element on all processes stored only on proc 0\nlati_all\nLatitude interpolation grid index of interpolation points within each element on all processes stored only on proc 0\nlongi_all\nLongitude interpolation grid index of interpolation points within each element on all processes stored only on proc 0\n\nUsage\n\nInterpolationCubedSphere(grid::DiscontinuousSpectralElementGrid, vert_range::AbstractArray{FT}, nhor::Int, lat_res::FT, long_res::FT, rad_res::FT) where {FT <: AbstractFloat}\n\nThis interpolation structure and the corresponding functions works for a cubed sphere topology. The data is interpolated along a lat/long/rad grid.\n\n-90⁰  ≤ lat  ≤ 90⁰\n\n-180⁰ ≤ long ≤ 180⁰\n\nRᵢ ≤ r ≤ Rₒ\n\nArguments for the inner constructor\n\ngrid: DiscontinousSpectralElementGrid\nvert_range: Vertex range along the radial coordinate\nlat_res: Resolution of the interpolation grid along the latitude coordinate in radians\nlong_res: Resolution of the interpolation grid along the longitude coordinate in radians\nrad_res: Resolution of the interpolation grid along the radial coordinate\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/Meshes/Mesh/#Functions-2","page":"Meshes","title":"Functions","text":"","category":"section"},{"location":"APIs/Numerics/Meshes/Mesh/#","page":"Meshes","title":"Meshes","text":"Interpolation.interpolate_local!\nInterpolation.project_cubed_sphere!\nInterpolation.accumulate_interpolated_data!","category":"page"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Interpolation.interpolate_local!","page":"Meshes","title":"ClimateMachine.Mesh.Interpolation.interpolate_local!","text":"interpolate_local!(intrp_brck::InterpolationBrick{FT},\n                           sv::AbstractArray{FT},\n                            v::AbstractArray{FT}) where {FT <: AbstractFloat}\n\nThis interpolation function works for a brick, where stretching/compression happens only along the x1, x2 & x3 axis. Here x1 = X1(ξ1), x2 = X2(ξ2) and x3 = X3(ξ3)\n\nArguments\n\nintrp_brck: Initialized InterpolationBrick structure\nsv: State Array consisting of various variables on the discontinuous Galerkin grid\nv:  Interpolated variables\n\n\n\n\n\ninterpolate_local!(intrp_cs::InterpolationCubedSphere{FT},\n                         sv::AbstractArray{FT},\n                          v::AbstractArray{FT}) where {FT <: AbstractFloat}\n\nThis interpolation function works for cubed spherical shell geometry.\n\nArguments\n\nintrp_cs: Initialized cubed sphere structure\nsv: Array consisting of various variables on the discontinuous Galerkin grid\nv:  Array consisting of variables on the interpolated grid\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Interpolation.project_cubed_sphere!","page":"Meshes","title":"ClimateMachine.Mesh.Interpolation.project_cubed_sphere!","text":"project_cubed_sphere!(intrp_cs::InterpolationCubedSphere{FT},\n                             v::AbstractArray{FT},\n                          uvwi::Tuple{Int,Int,Int}) where {FT <: AbstractFloat}\n\nThis function projects the velocity field along unit vectors in radial, lat and long directions for cubed spherical shell geometry.\n\nFields\n\nintrp_cs: Initialized cubed sphere structure\nv: Array consisting of x1, x2 and x3 components of the vector field\nuvwi:  Tuple providing the column numbers for x1, x2 and x3 components of vector field in the array.           These columns will be replaced with projected vector fields along unit vectors in rad, lat and long directions.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/Meshes/Mesh/#ClimateMachine.Mesh.Interpolation.accumulate_interpolated_data!","page":"Meshes","title":"ClimateMachine.Mesh.Interpolation.accumulate_interpolated_data!","text":"accumulate_interpolated_data!(intrp::InterpolationTopology,\n                                 iv::AbstractArray{FT,2},\n                                fiv::AbstractArray{FT,4}) where {FT <: AbstractFloat}\n\nThis interpolation function gathers interpolated data onto process # 0.\n\nFields\n\nintrp: Initialized interpolation topology structure\niv: Interpolated variables on local process\nfiv: Full interpolated variables accumulated on process # 0\n\n\n\n\n\n","category":"function"},{"location":"#ClimateMachine-1","page":"Home","title":"ClimateMachine","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The ClimateMachine is a software package that models the evolution of the Earth system over weeks to centuries. The ClimateMachine solves three-dimensional partial differential equations for the distributions of water, momentum, energy, and tracers such as carbon in the atmosphere, oceans, and on land.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The ClimateMachine will harness a wide range of Earth observations and data generated computationally to predict the evolution of Earth’s climate and features such as droughts, rainfall extremes, and high-impact storms.","category":"page"},{"location":"#Subcomponents-1","page":"Home","title":"Subcomponents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The ClimateMachine currently consists of three models for the subcomponents of the Earth system:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ClimateMachine.Atmos: A model of the fluid mechanics of the atmosphere and its interaction with solar radiation and phase changes of water that occur, for example, in clouds.\nClimateMachine.Ocean: A model for the fluid mechanics of the ocean and its distributions of heat, salinity, carbon, and other tracers.\nClimateMachine.Land: A model for the flow of energy and water in soils and on the land surface, for the biophysics of vegetation on land, and for the transfer and storage of carbon in the land biosphere.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The subcomponents will be coupled by exchanging water, momentum, energy, and tracers such as carbon dioxide across their boundaries.","category":"page"},{"location":"#Dynamical-core-1","page":"Home","title":"Dynamical core","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A dynamical core based on discontinuous Galerkin numerical methods is used to discretize the physical conservation laws that underlie each of the ClimateMachine's subcomponents.","category":"page"},{"location":"#Authors-1","page":"Home","title":"Authors","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The ClimateMachine is being developed by the Climate Modeling Alliance.","category":"page"},{"location":"HowToGuides/Numerics/Meshes/#Meshes-1","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"HowToGuides/Ocean/#Ocean-1","page":"Ocean","title":"Ocean","text":"","category":"section"},{"location":"generated/topo/#","page":"-","title":"-","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/topo.jl\"","category":"page"},{"location":"generated/topo/#","page":"-","title":"-","text":"using MPI\nusing ClimateMachine\nusing Logging\nusing ClimateMachine.Mesh.Topologies\nusing ClimateMachine.Mesh.Grids\nusing ClimateMachine.DGmethods\nusing ClimateMachine.DGmethods.NumericalFluxes\nusing ClimateMachine.MPIStateArrays\nusing ClimateMachine.LowStorageRungeKuttaMethod\nusing LinearAlgebra\nusing ClimateMachine.GenericCallbacks:\n    EveryXWallTimeSeconds, EveryXSimulationSteps\nusing ClimateMachine.ODESolvers\n\nMPI.Initialized() || MPI.Init()\nmpicomm = MPI.COMM_WORLD","category":"page"},{"location":"generated/topo/#","page":"-","title":"-","text":"set up domain","category":"page"},{"location":"generated/topo/#","page":"-","title":"-","text":"topl = StackedBrickTopology(\n    mpicomm,\n    (0:10, 0:10, 0:3);\n    periodicity = (false, false, false),\n    boundary = ((1, 1), (1, 2), (1, 2)),\n)\n\n@show MPI.Comm_rank(mpicomm) length(topl.realelems)","category":"page"},{"location":"generated/topo/#","page":"-","title":"-","text":"","category":"page"},{"location":"generated/topo/#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#Running-the-ClimateMachine-1","page":"Running","title":"Running the ClimateMachine","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"The ClimateMachine is composed of three models for the Earth system, a dynamical core, and a number of other components. These are put together to set up a simulation by a driver, for example the Held-Suarez atmospheric GCM, or the Rising Bubble atmospheric LES. The driver specifies:","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"the dimensions and resolution of the simulation domain,\nthe duration of the simulation,\nboundary conditions,\nsource terms,\na reference state,\nthe turbulence model,\nthe moisture model,\ndiagnostics of interest,\ninitial conditions,\netc.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"Additionally, the driver chooses the time integrator to be used to run the simulation and may specify the Courant number used to compute the timestep.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"Thus, running the ClimateMachine requires a driver. For example, the Held-Suarez atmospheric GCM is run with:","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"$ julia --project experiments/AtmosGCM/heldsuarez.jl","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#ClimateMachine-args-1","page":"Running","title":"Command line arguments","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"All drivers accept some common command line options. For example:","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"$ julia --project experiments/AtmosGCM/heldsuarez.jl --help\nusage: experiments/AtmosGCM/heldsuarez.jl [--disable-gpu]\n                        [--show-updates <interval>]\n                        [--diagnostics <interval>] [--vtk <interval>]\n                        [--monitor-timestep-duration <interval>]\n                        [--monitor-courant-numbers <interval>]\n                        [--checkpoint <interval>]\n                        [--checkpoint-keep-all] [--checkpoint-at-end]\n                        [--checkpoint-dir <path>]\n                        [--restart-from-num <number>]\n                        [--log-level <level>] [--output-dir <path>]\n                        [--integration-testing] [-h]\n\nClimate Machine: an Earth System Model that automatically learns from data\n\noptional arguments:\n  -h, --help            show this help message and exit\n\nClimateMachine:\n  --disable-gpu         do not use the GPU\n  --show-updates <interval>\n                        interval at which to show simulation updates\n                        (default: \"60secs\")\n  --diagnostics <interval>\n                        interval at which to collect diagnostics\n                        (default: \"never\")\n  --vtk <interval>      interval at which to output VTK (default:\n                        \"never\")\n  --monitor-timestep-duration <interval>\n                        interval in time-steps at which to output\n                        wall-clock time per time-step (default:\n                        \"never\")\n  --monitor-courant-numbers <interval>\n                        interval at which to output acoustic,\n                        advective, and diffusive Courant numbers\n                        (default: \"never\")\n  --checkpoint <interval>\n                        interval at which to create a checkpoint\n                        (default: \"never\")\n  --checkpoint-keep-all\n                        keep all checkpoints (instead of just the most\n                        recent)\n  --checkpoint-at-end   create a checkpoint at the end of the\n                        simulation\n  --checkpoint-dir <path>\n                        the directory in which to store checkpoints\n                        (default: \"checkpoint\")\n  --restart-from-num <number>\n                        checkpoint number from which to restart (in\n                        <checkpoint-dir>) (type: Int64, default: -1)\n  --fix-rng-seed        set RNG seed to a fixed value for\n                        reproducibility\n  --log-level <level>   set the log level to one of\n                        debug/info/warn/error (default: \"info\")\n  --output-dir <path>   directory for output data (default: \"output\")\n  --integration-testing\n                        enable integration testing\n\nAny <interval> unless otherwise stated may be specified as:\n    - 2hours or 10mins or 30secs => wall-clock time\n    - 9.5smonths or 3.3sdays or 1.5shours => simulation time\n    - 1000steps => simulation steps\n    - never => disable\n    - default => use experiment specified interval (only for diagnostics at\n      present)","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"There may also be driver-specific command line arguments.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#Environment-variables-1","page":"Running","title":"Environment variables","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"Currently, the ClimateMachine only looks at one environment variable – CLIMATEMACHINE_GPU, which if set to false, disables GPU use.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#Running-with-MPI-1","page":"Running","title":"Running with MPI","text":"","category":"section"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"Use MPI to start a distributed run of the ClimateMachine. For example:","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"mpiexec -np 4 julia --project experiments/AtmosGCM/heldsuarez.jl","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"will run the Held-Suarez experiment with four MPI ranks. If you are running on a cluster, you would use this command within a SLURM batch script (or the equivalent) that allocates four tasks. On a stand-alone machine, MPI will likely require that you have at least four cores.","category":"page"},{"location":"GettingStarted/RunningClimateMachine/#","page":"Running","title":"Running","text":"Note that unless GPU use is disabled as above, each ClimateMachine process will use GPU acceleration. If there are insufficient GPUs (four in the example above), the ClimateMachine processes will share the GPU resources available.","category":"page"},{"location":"DevDocs/AcceptableUnicode/#Acceptable-Unicode-characters-1","page":"Acceptable Unicode","title":"Acceptable Unicode characters","text":"","category":"section"},{"location":"DevDocs/AcceptableUnicode/#","page":"Acceptable Unicode","title":"Acceptable Unicode","text":"Using Unicode seems to be irresistible. However, we must ensure avoiding problematic Unicode usage.","category":"page"},{"location":"DevDocs/AcceptableUnicode/#","page":"Acceptable Unicode","title":"Acceptable Unicode","text":"Below is a list of acceptable Unicode characters.  All characters not listed below are forbidden. We forbid the use of accents (dot, hat, vec, etc.), because this can lead to visually ambiguous characters.","category":"page"},{"location":"DevDocs/AcceptableUnicode/#Acceptable-lower-case-Greek-letters-1","page":"Acceptable Unicode","title":"Acceptable lower-case Greek letters","text":"","category":"section"},{"location":"DevDocs/AcceptableUnicode/#","page":"Acceptable Unicode","title":"Acceptable Unicode","text":"α # (alpha)\nβ # (beta)\nδ # (delta)\nϵ # (epsilon)\nε # (varepsilon)\nγ # (gamma)\nκ # (kappa)\nλ # (lambda)\nμ # (mu)\nν # (nu)\nη # (eta)\nω # (omega)\nπ # (pi)\nρ # (rho)\nσ # (sigma)\nθ # (theta)\nχ # (chi)\nξ # (xi)\nζ # (zeta)\nϕ # (psi)\nφ # (varphi)","category":"page"},{"location":"DevDocs/AcceptableUnicode/#Acceptable-upper-case-Greek-letters-1","page":"Acceptable Unicode","title":"Acceptable upper-case Greek letters","text":"","category":"section"},{"location":"DevDocs/AcceptableUnicode/#","page":"Acceptable Unicode","title":"Acceptable Unicode","text":"Δ # (Delta)\n∑ # (Sigma)\nΓ # (Gamma)\nΩ # (Omega)\nΨ # (Psi)\n<!-- Φ # (Phi) removed in favor of lowercase psi -->","category":"page"},{"location":"DevDocs/AcceptableUnicode/#Acceptable-mathematical-symbols-1","page":"Acceptable Unicode","title":"Acceptable mathematical symbols","text":"","category":"section"},{"location":"DevDocs/AcceptableUnicode/#","page":"Acceptable Unicode","title":"Acceptable Unicode","text":"∫ # (int)\n∬ # (iint)\n∭ # (iiint)\n∞ # (infinity)\n≈ # (approx)\n∂ # (partial)\n∇ # (nabla/del), note that nabla and del are indistinguishable\n∀ # (forall)\n≥ # (greater than equal to)\n≤ # (less than equal to)\n<!-- ∈ # (in) removed in favor of epsilon -->","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#Atmospheric-temperature-profiles-1","page":"TemperatureProfiles","title":"Atmospheric temperature profiles","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"CurrentModule = ClimateMachine.TemperatureProfiles","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"Several temperature profiles are available in ClimateMachine.jl. Here, we plot each profile.","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#Usage-1","page":"TemperatureProfiles","title":"Usage","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"Using a profile involves passing two arguments:","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"param_set a parameter set, from CLIMAParameters.jl\nz altitude","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"to one of the temperature profile constructors.","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#IsothermalProfile-1","page":"TemperatureProfiles","title":"IsothermalProfile","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"using ClimateMachine.TemperatureProfiles\nusing ClimateMachine.MoistThermodynamics\nusing CLIMAParameters\nusing CLIMAParameters.Planet\nusing Plots\nstruct EarthParameterSet <: AbstractEarthParameterSet end;\nconst param_set = EarthParameterSet();\nFT = Float64;\ninclude(joinpath(@__DIR__, repeat([\"..\"], 4)...,\"test\", \"Common\", \"MoistThermodynamics\", \"profiles.jl\"))\nz, e_int, ρ, q_tot, q_pt, T, p, θ_liq_ice = tested_profiles(param_set, 50, FT);\n\nisothermal = IsothermalProfile(param_set, FT);\nargs = isothermal.(Ref(param_set), z)\nT = first.(args)\np = last.(args)\n\np1 = plot(T, z./10^3, xlabel=\"Temperature [K]\");\np2 = plot(p./10^3, z./10^3, xlabel=\"Pressure [kPa]\");\nplot(p1, p2, layout=(1,2), title=\"Isothermal\", ylabel=\"z [km]\")\nsavefig(\"isothermal.svg\")","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"(Image: )","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#DecayingTemperatureProfile-1","page":"TemperatureProfiles","title":"DecayingTemperatureProfile","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"using ClimateMachine.TemperatureProfiles\nusing ClimateMachine.MoistThermodynamics\nusing CLIMAParameters\nusing CLIMAParameters.Planet\nusing Plots\nstruct EarthParameterSet <: AbstractEarthParameterSet end;\nconst param_set = EarthParameterSet();\nFT = Float64;\ninclude(joinpath(@__DIR__, repeat([\"..\"], 4)...,\"test\", \"Common\", \"MoistThermodynamics\", \"profiles.jl\"))\nz, e_int, ρ, q_tot, q_pt, T, p, θ_liq_ice = tested_profiles(param_set, 50, FT);\n\ndecaying = DecayingTemperatureProfile{FT}(param_set);\nargs = decaying.(Ref(param_set), z)\nT = first.(args)\np = last.(args)\n\np1 = plot(T, z./10^3, xlabel=\"Temperature [K]\");\np2 = plot(p./10^3, z./10^3, xlabel=\"Pressure [kPa]\");\nplot(p1, p2, layout=(1,2), ylabel=\"z [km]\", title=\"Decaying\")\nsavefig(\"decaying.svg\")","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"(Image: )","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#DryAdiabaticProfile-1","page":"TemperatureProfiles","title":"DryAdiabaticProfile","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"using ClimateMachine.TemperatureProfiles\nusing ClimateMachine.MoistThermodynamics\nusing CLIMAParameters\nusing CLIMAParameters.Planet\nusing Plots\nstruct EarthParameterSet <: AbstractEarthParameterSet end;\nconst param_set = EarthParameterSet();\nFT = Float64;\ninclude(joinpath(@__DIR__, repeat([\"..\"], 4)...,\"test\", \"Common\", \"MoistThermodynamics\", \"profiles.jl\"))\nz, e_int, ρ, q_tot, q_pt, T, p, θ_liq_ice = tested_profiles(param_set, 50, FT);\n\ndry_adiabatic = DryAdiabaticProfile{FT}(param_set);\nargs = dry_adiabatic.(Ref(param_set), z)\nT = first.(args)\np = last.(args)\nθ_dry = dry_pottemp_given_pressure.(Ref(param_set), T, p)\n\np1 = plot(T, z./10^3, xlabel=\"Temperature [K]\");\np2 = plot(p./10^3, z./10^3, xlabel=\"Pressure [kPa]\");\np3 = plot(θ_dry, z./10^3, xlabel=\"Potential temperature [K]\");\nplot(p1, p2, p3, layout=(1,3), ylabel=\"z [km]\", title=\"Dry adiabatic\")\nsavefig(\"dry_adiabatic.svg\")","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"(Image: )","category":"page"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#Extending-1","page":"TemperatureProfiles","title":"Extending","text":"","category":"section"},{"location":"HowToGuides/Atmos/TemperatureProfiles/#","page":"TemperatureProfiles","title":"TemperatureProfiles","text":"Additional constructors, or additional profiles can be added to this module by adding a struct, containing parameters needed to construct the profile, and a functor to call the profile with a parameter set and altitude.","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#DG-Balance-Law-Method-1","page":"Balance Law","title":"DG Balance Law Method","text":"","category":"section"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"CurrentModule = ClimateMachine.DGmethods","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#The-balance-law-1","page":"Balance Law","title":"The balance law","text":"","category":"section"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"BalanceLaw","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.BalanceLaw","page":"Balance Law","title":"ClimateMachine.DGmethods.BalanceLaw","text":"BalanceLaw\n\nAn abstract type representing a PDE balance law of the form\n\nelements for balance laws of the form\n\nq_t + Σ_i=1d F_ii = s\n\nSubtypes L should define the methods below\n\n\n\n\n\n","category":"type"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#Continuous-Balance-Law-Formulation-1","page":"Balance Law","title":"Continuous Balance Law Formulation","text":"","category":"section"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"to be filled","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#Discontinuous-Galerkin-Method-Formulation-1","page":"Balance Law","title":"Discontinuous Galerkin Method Formulation","text":"","category":"section"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"to be filled","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#Examples-1","page":"Balance Law","title":"Examples","text":"","category":"section"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"attribution: Attribution\nThe style of examples we use here is heavily inspired by JuAFEM.jl","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"to be filled","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#Variable-specification-methods-1","page":"Balance Law","title":"Variable specification methods","text":"","category":"section"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"vars_state_conservative\nvars_state_auxiliary\nvars_state_gradient\nvars_integrals\nvars_reverse_integrals\nvars_state_gradient_flux","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.vars_state_conservative","page":"Balance Law","title":"ClimateMachine.DGmethods.vars_state_conservative","text":"vars_state_conservative(::L, FT)\n\na tuple of symbols containing the state variables given a float type FT.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.vars_state_auxiliary","page":"Balance Law","title":"ClimateMachine.DGmethods.vars_state_auxiliary","text":"vars_state_auxiliary(::L, FT)\n\na tuple of symbols containing the auxiliary variables given a float type FT.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.vars_state_gradient","page":"Balance Law","title":"ClimateMachine.DGmethods.vars_state_gradient","text":"vars_state_gradient(::L, FT)\n\na tuple of symbols containing the transformed variables of which gradients are computed given a float type FT.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.vars_integrals","page":"Balance Law","title":"ClimateMachine.DGmethods.vars_integrals","text":"vars_integrals(::L, FT)\n\na tuple of symbols containing variables to be integrated along a vertical stack, given a float type FT.\n\n\n\n\n\nvars_integrals(m::AtmosModel, FT)\n\n\n\n\n\nvars_integral(::HBModel)\n\nlocation to store integrands for bottom up integrals ∇hu = the horizontal divegence of u, e.g. dw/dz\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.vars_reverse_integrals","page":"Balance Law","title":"ClimateMachine.DGmethods.vars_reverse_integrals","text":"vars_reverse_integrals(::L, FT)\n\na tuple of symbols containing variables to be integrated along a vertical stack, in reverse, given a float type FT.\n\n\n\n\n\nvars_reverse_integrals(m::AtmosModel, FT)\n\n\n\n\n\nvars_reverse_integral(::HBModel)\n\nlocation to store integrands for top down integrals αᵀθ = density perturbation\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.vars_state_gradient_flux","page":"Balance Law","title":"ClimateMachine.DGmethods.vars_state_gradient_flux","text":"vars_state_gradient_flux(::L, FT)\n\na tuple of symbols containing the diffusive variables given a float type FT.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#Initial-condition-methods-1","page":"Balance Law","title":"Initial condition methods","text":"","category":"section"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"init_state_conservative!\ninit_state_auxiliary!","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.init_state_conservative!","page":"Balance Law","title":"ClimateMachine.DGmethods.init_state_conservative!","text":"init_state_conservative!(\n  ::L,\n  state_conservative::Vars,\n  state_auxiliary::Vars,\n  coords,\n  args...)\n\nInitialize the conservative state variables at t = 0\n\n\n\n\n\ninit_state_conservative!(\n    m::AtmosModel,\n    state::Vars,\n    aux::Vars,\n    coords,\n    t,\n    args...)\n\nInitialise state variables. args... provides an option to include configuration data (current use cases include problem constants, spline-interpolants)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.init_state_auxiliary!","page":"Balance Law","title":"ClimateMachine.DGmethods.init_state_auxiliary!","text":"init_state_auxiliary!(\n  ::L,\n  state_auxiliary::Vars,\n  coords,\n  args...)\n\nInitialize the auxiliary state, at t = 0\n\n\n\n\n\ninit_state_auxiliary!(\n    m::AtmosModel,\n    aux::Vars,\n    geom::LocalGeometry\n    )\n\nInitialise auxiliary variables for each AtmosModel subcomponent. Store Cartesian coordinate information in aux.coord.\n\n\n\n\n\nNo need to init, initialize by full model\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#Source-term-kernels-1","page":"Balance Law","title":"Source term kernels","text":"","category":"section"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"flux_first_order!\nflux_second_order!\nsource!","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.flux_first_order!","page":"Balance Law","title":"ClimateMachine.DGmethods.flux_first_order!","text":"flux_first_order!(\n    ::L,\n    flux::Grad,\n    state_conservative::Vars,\n    state_auxiliary::Vars,\n    t::Real\n)\n\nCompute first-order flux terms in balance law equation\n\n\n\n\n\nflux_first_order!(\n    m::AtmosModel,\n    flux::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real\n)\n\nComputes and assembles non-diffusive fluxes in the model equations.\n\n\n\n\n\nflux_first_order!(::HBModel)\n\ncalculates the hyperbolic flux contribution to state variables this computation is done pointwise at each nodal point\n\narguments:\n\nm -> model in this case HBModel F -> array of fluxes for each state variable Q -> array of state variables A -> array of aux variables t -> time, not used\n\ncomputations\n\n∂ᵗu = ∇⋅(g*η + g∫αᵀθdz + v⋅u) ∂ᵗθ = ∇⋅(vθ) where v = (u,v,w)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.flux_second_order!","page":"Balance Law","title":"ClimateMachine.DGmethods.flux_second_order!","text":"flux_second_order!(\n    ::L,\n    flux::Grad,\n    state_conservative::Vars,\n    state_gradient_flux::Vars,\n    hyperdiffusive::Vars,\n    state_auxiliary::Vars,\n    t::Real\n)\n\nCompute second-order flux terms in balance law equation\n\n\n\n\n\nflux_second_order!(\n    atmos::AtmosModel,\n    flux::Grad,\n    state::Vars,\n    diffusive::Vars,\n    hyperdiffusive::Vars,\n    aux::Vars,\n    t::Real\n)\n\nDiffusive fluxes in AtmosModel. Viscosity, diffusivity are calculated in the turbulence subcomponent and accessed within the diffusive flux function. Contributions from subcomponents are then assembled (pointwise).\n\n\n\n\n\nflux_second_order!(::HBModel)\n\ncalculates the parabolic flux contribution to state variables this computation is done pointwise at each nodal point\n\narguments:\n\nm: model in this case HBModel\nF: array of fluxes for each state variable\nQ: array of state variables\nD: array of diff variables\nA: array of aux variables\nt: time, not used\n\ncomputations\n\n∂ᵗu = -∇⋅(ν∇u) ∂ᵗθ = -∇⋅(κ∇θ)\n\n\n\n\n\nflux_second_order!(::HBModel)\n\ncalculates the parabolic flux contribution to state variables this computation is done pointwise at each nodal point\n\narguments:\n\nm: model in this case HBModel\nF: array of fluxes for each state variable\nQ: array of state variables\nD: array of diff variables\nA: array of aux variables\nt: time, not used\n\ncomputations\n\n∂ᵗu = -∇⋅(ν∇u) ∂ᵗθ = -∇⋅(κ∇θ)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.source!","page":"Balance Law","title":"ClimateMachine.DGmethods.source!","text":"source!(\n    ::L,\n    source::Vars,\n    state_conservative::Vars,\n    diffusive::Vars,\n    state_auxiliary::Vars,\n    t::Real\n)\n\nCompute non-conservative source terms in balance law equation\n\n\n\n\n\nsource!(\n    m::AtmosModel,\n    source::Vars,\n    state::Vars,\n    diffusive::Vars,\n    aux::Vars,\n    t::Real,\n    direction::Direction\n)\n\nComputes (and assembles) source terms S(Y) in:\n\n∂Y\n-- = - ∇ • F + S(Y)\n∂t\n\n\n\n\n\nsource!(::HBModel)\ncalculates the source term contribution to state variables\nthis computation is done pointwise at each nodal point\n\narguments:\nm -> model in this case HBModel\nF -> array of fluxes for each state variable\nQ -> array of state variables\nA -> array of aux variables\nt -> time, not used\n\ncomputations\n∂ᵗu = -f×u\n∂ᵗη = w|(z=0)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#Integral-kernels-1","page":"Balance Law","title":"Integral kernels","text":"","category":"section"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"integral_load_auxiliary_state!\nintegral_set_auxiliary_state!\nreverse_integral_load_auxiliary_state!\nreverse_integral_set_auxiliary_state!","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.integral_load_auxiliary_state!","page":"Balance Law","title":"ClimateMachine.DGmethods.integral_load_auxiliary_state!","text":"integral_load_auxiliary_state!\n\nSpecify how to compute integrands. Can be functions of the conservative state and auxiliary variables.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.integral_set_auxiliary_state!","page":"Balance Law","title":"ClimateMachine.DGmethods.integral_set_auxiliary_state!","text":"integral_set_auxiliary_state!\n\nSpecify which auxiliary variables are used to store the output of the integrals.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.reverse_integral_load_auxiliary_state!","page":"Balance Law","title":"ClimateMachine.DGmethods.reverse_integral_load_auxiliary_state!","text":"reverse_integral_load_auxiliary_state!\n\nSpecify auxiliary variables need their integrals reversed.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.reverse_integral_set_auxiliary_state!","page":"Balance Law","title":"ClimateMachine.DGmethods.reverse_integral_set_auxiliary_state!","text":"reverse_integral_set_auxiliary_state!\n\nSpecify which auxiliary variables are used to store the output of the reversed integrals.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#Gradient/Laplacian-kernels-1","page":"Balance Law","title":"Gradient/Laplacian kernels","text":"","category":"section"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"compute_gradient_flux!\ncompute_gradient_argument!\ntransform_post_gradient_laplacian!","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.compute_gradient_flux!","page":"Balance Law","title":"ClimateMachine.DGmethods.compute_gradient_flux!","text":"compute_gradient_flux!(\n    ::L,\n    state_gradient_flux::Vars,\n    ∇transformstate::Grad,\n    state_auxiliary::Vars,\n    t::Real\n)\n\ntransformation of gradients to the diffusive variables\n\n\n\n\n\ncompute_gradient_flux!(::TurbulenceClosure, _...)\n\nPost-gradient-transformed variables specific to turbulence models.\n\n\n\n\n\ncompute_gradient_flux!(::HBModel)\n\ncopy ∇u and ∇θ to var_diffusive this computation is done pointwise at each nodal point\n\narguments:\n\nm: model in this case HBModel\nD: array of diffusive variables\nG: array of gradient variables\nQ: array of state variables\nA: array of aux variables\nt: time, not used\n\n\n\n\n\ncompute_gradient_flux!(::LinearHBModel)\n\ncopy ν∇u and κ∇θ to var_diffusive this computation is done pointwise at each nodal point\n\narguments:\n\nm: model in this case HBModel\nD: array of diffusive variables\nG: array of gradient variables\nQ: array of state variables\nA: array of aux variables\nt: time, not used\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.compute_gradient_argument!","page":"Balance Law","title":"ClimateMachine.DGmethods.compute_gradient_argument!","text":"compute_gradient_argument!(\n    ::L,\n    transformstate::Vars,\n    state_conservative::Vars,\n    state_auxiliary::Vars,\n    t::Real\n)\n\ntransformation of state variables to variables of which gradients are computed\n\n\n\n\n\ncompute_gradient_argument!\n\nAssign pre-gradient-transform variables specific to turbulence models.\n\n\n\n\n\ncompute_gradient_argument!(::HBModel)\n\ncopy u and θ to var_gradient this computation is done pointwise at each nodal point\n\narguments:\n\nm: model in this case HBModel\nG: array of gradient variables\nQ: array of state variables\nA: array of aux variables\nt: time, not used\n\n\n\n\n\ncompute_gradient_argument!(::LinearHBModel)\n\ncopy u and θ to var_gradient this computation is done pointwise at each nodal point\n\narguments:\n\nm: model in this case HBModel\nG: array of gradient variables\nQ: array of state variables\nA: array of aux variables\nt: time, not used\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.transform_post_gradient_laplacian!","page":"Balance Law","title":"ClimateMachine.DGmethods.transform_post_gradient_laplacian!","text":"transform_post_gradient_laplacian!(\n    ::L,\n    Qhypervisc_div::Vars,\n    ∇Δtransformstate::Grad,\n    state_auxiliary::Vars,\n    t::Real\n)\n\ntransformation of laplacian gradients to the hyperdiffusive variables\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#Auxiliary-kernels-1","page":"Balance Law","title":"Auxiliary kernels","text":"","category":"section"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#","page":"Balance Law","title":"Balance Law","text":"wavespeed\nboundary_state!\nupdate_auxiliary_state!\nupdate_auxiliary_state_gradient!","category":"page"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.wavespeed","page":"Balance Law","title":"ClimateMachine.DGmethods.wavespeed","text":"wavespeed(\n    ::L,\n    n⁻,\n    state_conservative::Vars,\n    state_auxiliary::Vars,\n    t::Real\n)\n\nwavespeed\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.boundary_state!","page":"Balance Law","title":"ClimateMachine.DGmethods.boundary_state!","text":"boundary_state!(\n    ::NumericalFluxGradient,\n    ::L,\n    state_conservative⁺::Vars,\n    state_auxiliary⁺::Vars,\n    normal⁻,\n    state_conservative⁻::Vars,\n    state_auxiliary⁻::Vars,\n    bctype,\n    t\n)\nboundary_state!(\n    ::NumericalFluxFirstOrder,\n    ::L,\n    state_conservative⁺::Vars,\n    state_auxiliary⁺::Vars,\n    normal⁻,\n    state_conservative⁻::Vars,\n    state_auxiliary⁻::Vars,\n    bctype,\n    t\n)\nboundary_state!(\n    ::NumericalFluxSecondOrder,\n    ::L,\n    state_conservative⁺::Vars,\n    state_gradient_flux⁺::Vars,\n    state_auxiliary⁺:\n    Vars, normal⁻,\n    state_conservative⁻::Vars,\n    state_gradient_flux⁻::Vars,\n    state_auxiliary⁻::Vars,\n    bctype,\n    t\n)\n\nApply boundary conditions for\n\nNumericalFluxGradient numerical flux (internal method)\nNumericalFluxFirstOrder first-order unknowns\nNumericalFluxSecondOrder second-order unknowns\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.update_auxiliary_state!","page":"Balance Law","title":"ClimateMachine.DGmethods.update_auxiliary_state!","text":"update_auxiliary_state!(\n    dg::DGModel,\n    m::HBModel,\n    Q::MPIStateArray,\n    t::Real,\n    elems::UnitRange,\n)\n\nUpdate the auxiliary state variables\n\n\n\n\n\n","category":"function"},{"location":"APIs/Numerics/DGmethods/BalanceLawOverview/#ClimateMachine.DGmethods.update_auxiliary_state_gradient!","page":"Balance Law","title":"ClimateMachine.DGmethods.update_auxiliary_state_gradient!","text":"update_auxiliary_state_gradient!\n\nUpdate the auxiliary state gradient variables\n\n\n\n\n\n","category":"function"},{"location":"Theory/Atmos/Model/tracers/#Tracers-docs-1","page":"Tracers","title":"Tracers","text":"","category":"section"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"note: Note\nUsage: Enable tracers using a keyword argument in the AtmosModel specification\n- tracers = NoTracer()\n- tracers = NTracers{N, FT}(δ_χ) where N is the number of tracers required.\nFT is the float-type and delta_chi is an SVector of diffusivity scaling coefficients","category":"page"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"note: Note\nHyperdiffusion is currently not supported with tracers. Laplacian diffusion coefficients may still be specified. (See above)","category":"page"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"In tracers.jl, we define the equation sets governing tracer dynamics. Specifically, we address the the equations of tracer motion in conservation form,","category":"page"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"export NoTracers, NTracers","category":"page"},{"location":"Theory/Atmos/Model/tracers/#tracer-eqns-1","page":"Tracers","title":"Equations","text":"","category":"section"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"fracpartial rhochipartial t +  nabla cdot ( rhochi u) = nabla cdot (rhodelta_DchimathrmD_Tnablachi) + rho mathrmS","category":"page"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"where  chi represents the tracer species, mathrmS represents the tracer source terms and delta_Dchi mathrmD_T represents the scaled turbulent eddy diffusivity for each tracer.  Currently a default scaling of 1 is supported.  The equation as written above corresponds to a single scalar tracer, but can be extended to include multiple independent tracer species.","category":"page"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"We first define an abstract tracer type, and define the default function signatures. Two options are currently supported. NoTracers, and NTracers.","category":"page"},{"location":"Theory/Atmos/Model/tracers/#abstract-tracer-type-1","page":"Tracers","title":"Abstract Tracer Type","text":"","category":"section"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"Default stub functions for a generic tracer type are defined here.","category":"page"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"abstract type TracerModel <: BalanceLaw end\n\nvars_state_conservative(::TracerModel, FT) = @vars()\nvars_state_gradient(::TracerModel, FT) = @vars()\nvars_state_gradient_flux(::TracerModel, FT) = @vars()\nvars_state_auxiliary(::TracerModel, FT) = @vars()\n\nfunction atmos_init_aux!(\n    ::TracerModel,\n    ::AtmosModel,\n    aux::Vars,\n    geom::LocalGeometry,\n)\n    nothing\nend\nfunction atmos_nodal_update_auxiliary_state!(\n    ::TracerModel,\n    m::AtmosModel,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    nothing\nend\nfunction flux_tracers!(\n    ::TracerModel,\n    atmos::AtmosModel,\n    flux::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    nothing\nend\nfunction compute_gradient_flux!(\n    ::TracerModel,\n    diffusive::Vars,\n    ∇transform::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    nothing\nend\nfunction flux_second_order!(\n    ::TracerModel,\n    flux::Grad,\n    state::Vars,\n    diffusive::Vars,\n    aux::Vars,\n    t::Real,\n    D_t,\n)\n    nothing\nend\nfunction compute_gradient_argument!(\n    ::TracerModel,\n    transform::Vars,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    nothing\nend","category":"page"},{"location":"Theory/Atmos/Model/tracers/#no-tracers-1","page":"Tracers","title":"NoTracers","text":"","category":"section"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"The default tracer type in both the LES and GCM configurations is the no tracer model. (This means no state variables for tracers are being carried around). For the purposes of this model, moist variables are considered separately in moisture.jl.","category":"page"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"ClimateMachine.Atmos.NoTracers","category":"page"},{"location":"Theory/Atmos/Model/tracers/#ClimateMachine.Atmos.NoTracers","page":"Tracers","title":"ClimateMachine.Atmos.NoTracers","text":"NoTracers <: TracerModel\n\nNo tracers. Default model.\n\n\n\n\n\n","category":"type"},{"location":"Theory/Atmos/Model/tracers/#multiple-tracers-1","page":"Tracers","title":"NTracers","text":"","category":"section"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"Allows users to specify an integer corresponding to the number of tracers required.  Note that tracer naming is not currently supported, i.e. the user must track each tracer variable based on its numerical index. Sources can be added to each tracer based on the corresponding numerical vector index. Initial profiles must be specified using the init_state_conservative! hook at the experiment level.","category":"page"},{"location":"Theory/Atmos/Model/tracers/#","page":"Tracers","title":"Tracers","text":"ClimateMachine.Atmos.NTracers{N,FT}","category":"page"},{"location":"Theory/Atmos/Model/tracers/#ClimateMachine.Atmos.NTracers","page":"Tracers","title":"ClimateMachine.Atmos.NTracers","text":"NTracers{N, FT} <: TracerModel\n\nCurrently the simplest way to get n-tracers in an AtmosModel run using the existing machinery. Model input: SVector of diffusivity scaling coefficients. Length of SVector allows number of tracers to be inferred. Tracers are currently identified by indices.\n\nFields\n\n\n\nδ_χ\nN-component SVector with scaling ratios for tracer diffusivities\n\n\n\n\n\n","category":"type"},{"location":"APIs/Arrays/Arrays/#Arrays-1","page":"Arrays","title":"Arrays","text":"","category":"section"},{"location":"APIs/Arrays/Arrays/#","page":"Arrays","title":"Arrays","text":"CurrentModule = ClimateMachine.MPIStateArrays","category":"page"},{"location":"APIs/Arrays/Arrays/#MPIStateArrays-1","page":"Arrays","title":"MPIStateArrays","text":"","category":"section"},{"location":"APIs/Arrays/Arrays/#","page":"Arrays","title":"Arrays","text":"Storage for the state of a discretization.","category":"page"},{"location":"APIs/Arrays/Arrays/#","page":"Arrays","title":"Arrays","text":"MPIStateArray\nbegin_ghost_exchange!\nend_ghost_exchange!","category":"page"},{"location":"APIs/Arrays/Arrays/#ClimateMachine.MPIStateArrays.MPIStateArray","page":"Arrays","title":"ClimateMachine.MPIStateArrays.MPIStateArray","text":"MPIStateArray{FT, DATN<:AbstractArray{FT,3}, DAI1, DAV,\n              DAT2<:AbstractArray{FT,2}} <: AbstractArray{FT, 3}\n\n\n\n\n\n","category":"type"},{"location":"APIs/Arrays/Arrays/#ClimateMachine.MPIStateArrays.begin_ghost_exchange!","page":"Arrays","title":"ClimateMachine.MPIStateArrays.begin_ghost_exchange!","text":"begin_ghost_exchange!(Q::MPIStateArray; dependencies = nothing)\n\nBegin the MPI halo exchange of the data stored in Q.  A KernelAbstractions Event is returned that can be used as a dependency to end the exchange.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Arrays/Arrays/#ClimateMachine.MPIStateArrays.end_ghost_exchange!","page":"Arrays","title":"ClimateMachine.MPIStateArrays.end_ghost_exchange!","text":"end_ghost_exchange!(Q::MPIStateArray; dependencies = nothing)\n\nThis function blocks on the host until the ghost halo is received from MPI.  A KernelAbstractions Event is returned that can be waited on to indicate when the data is ready on the device.\n\n\n\n\n\n","category":"function"},{"location":"DevDocs/DiagnosticVariables/#CliMA-Diagnostic-Variable-List-1","page":"Diagnostic variable list","title":"CliMA Diagnostic Variable List","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/#","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"This document contains the diagnostic variables in CliMA.","category":"page"},{"location":"DevDocs/DiagnosticVariables/#LES-Diagnostics-1","page":"Diagnostic variable list","title":"LES Diagnostics","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/#default-1","page":"Diagnostic variable list","title":"default","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/#","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\nu x-velocity\nv y-velocity\nw z-velocity\navg_rho density\nrho (density-averaged) density\nqt total specific humidity\nql liquid water specific humidity\nqv water vapor specific humidity\nthd potential temperature\nthv virtual potential temperature\nthl liquid-ice potential temperature\net total specific energy\nei specific internal energy\nht total specific enthalpy\nhm specific enthalpy\nvar_u variance of x-velocity\nvar_v variance of y-velocity\nvar_w variance of z-velocity\nw3 the third moment of z-velocity\ntke turbulence kinetic energy\nvar_qt variance of total specific humidity\nvar_thl variance of liquid-ice potential temperature\nvar_ei variance of specific internal energy\ncov_w_u vertical eddy flux of x-velocity\ncov_w_v vertical eddy flux of y-velocity\ncov_w_rho vertical eddy flux of mass\ncov_w_qt vertical eddy flux of total specific humidity\ncov_w_ql vertical eddy flux of liuqid water specific humidity\ncov_w_qv vertical eddy flux of water vapor specific humidity\ncov_w_thd vertical eddy flux of potential temperature\ncov_w_thv vertical eddy flux of virtual temperature\ncov_w_thl vertical eddy flux of liquid-ice potential temperature\ncov_w_ei vertical eddy flux of specific internal energy\ncov_qt_thl covariance of total specific humidity and liquid-ice potential temperature\ncov_qt_ei covariance of total specific humidity and specific internal energy\nw_qt_sgs vertical sgs flux of total specific humidity\nw_ht_sgs vertical sgs flux of total specific enthalpy\ncld_frac cloud fraction\ncld_cover cloud cover\ncld_top cloud top\ncld_base cloud base\nlwp liquid water path","category":"page"},{"location":"DevDocs/DiagnosticVariables/#core-1","page":"Diagnostic variable list","title":"core","text":"","category":"section"},{"location":"DevDocs/DiagnosticVariables/#","page":"Diagnostic variable list","title":"Diagnostic variable list","text":"short name description\nu_core cloud core x-velocity\nv_core cloud core y-velocity\nw_core cloud core z-velocity\navg_rho_core cloud core density\nrho_core cloud core (density-averaged) density\nqt_core cloud core total specific humidity\nql_core cloud core liquid water specific humidity\nthv_core cloud core virtual potential temperature\nthl_core cloud core liquid-ice potential temperature\nei_core cloud core specific internal energy\nvar_u_core cloud core variance of x-velocity\nvar_v_core cloud core variance of y-velocity\nvar_w_core cloud core variance of z-velocity\nvar_qt_core cloud core variance of total specific humidity\nvar_thl_core cloud core variance of liquid-ice potential temperature\nvar_ei_core cloud core variance of specific internal energy\ncov_w_rho_core cloud core vertical eddy flux of mass\ncov_w_qt_core cloud core vertical eddy flux of total specific humidity\ncov_w_thl_core cloud core vertical eddy flux of liquid-ice potential temperature\ncov_w_ei_core cloud core vertical eddy flux of specific internal energy\ncov_qt_thl_core cloud core covariance of total specific humidity and liquid-ice potential temperature\ncov_qt_ei_core cloud core covariance of total specific humidity and specific internal energy\ncore_frac cloud core (q_liq > 0 and w > 0) fraction","category":"page"},{"location":"GettingStarted/Installation/#Installing-ClimateMachine-1","page":"Installation","title":"Installing ClimateMachine","text":"","category":"section"},{"location":"GettingStarted/Installation/#Install-Julia-1","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"The current release of the ClimateMachine is verified to work with Julia 1.3.1. Download it for your platform from Julia's old releases.","category":"page"},{"location":"GettingStarted/Installation/#Install-MPI-(optional)-1","page":"Installation","title":"Install MPI (optional)","text":"","category":"section"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"The ClimateMachine uses the Message Passing Interface (MPI) for distributed processing via the MPI.jl package. This package downloads and installs an MPI implementation for your platform. However, on high-performance computing systems, you will probably want to configure this package to use the system-provided MPI implementation. You can do so by setting the environment variable JULIA_MPI_BINARY=system.","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"Install MPI.jl in Julia using the built-in package manager (press ] at the Julia prompt):","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"julia> ]\n(v1.3) pkg> add MPI","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"The package should be installed and built without errors. You can verify that all is well with:","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"julia> ]\n(v1.3) pkg> test MPI","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"If you are having problems, see the MPI.jl documentation for help.","category":"page"},{"location":"GettingStarted/Installation/#Install-the-ClimateMachine-1","page":"Installation","title":"Install the ClimateMachine","text":"","category":"section"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"Download the ClimateMachine source (you will need Git):","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"$ git clone https://github.com/CliMA/ClimateMachine.jl.git","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"Now change into the ClimateMachine.jl directory and install all the packages required with:","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"$ julia --project -e 'using Pkg; pkg\"instantiate\"; pkg\"build MPI\"'","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"Pre-compile the packages to allow the ClimateMachine to start faster:","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"$ julia --project -e 'using Pkg; pkg\"precompile\"'","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"You can verify your installation with:","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"$ julia --project test/runtests.jl","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"This will take a while!","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"You are now ready to run one of the tutorials. For instance, the dry Rayleigh Benard tutorial:","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"$ julia --project tutorials/Atmos/dry_rayleigh_benard.jl","category":"page"},{"location":"GettingStarted/Installation/#","page":"Installation","title":"Installation","text":"The ClimateMachine is CUDA-enabled and will use GPU(s) if available. To run on the CPU, set the environment variable CLIMATEMACHINE_GPU to false.","category":"page"},{"location":"APIs/Common/SurfaceFluxes/#Surface-Fluxes-1","page":"Surface Fluxes","title":"Surface Fluxes","text":"","category":"section"},{"location":"APIs/Common/SurfaceFluxes/#","page":"Surface Fluxes","title":"Surface Fluxes","text":"CurrentModule = ClimateMachine.SurfaceFluxes","category":"page"},{"location":"APIs/Common/SurfaceFluxes/#Surface-Fluxes-2","page":"Surface Fluxes","title":"Surface Fluxes","text":"","category":"section"},{"location":"APIs/Common/SurfaceFluxes/#","page":"Surface Fluxes","title":"Surface Fluxes","text":"SurfaceFluxes","category":"page"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes","text":"SurfaceFluxes\n\nSurface flux functions, e.g., for buoyancy flux,   friction velocity, and exchange coefficients.\n\nSub-modules\n\nmodule Byun1990\nmodule Nishizawa2018\n\nInterface\n\ncompute_buoyancy_flux computes the buoyancy flux\nIn addition, each sub-module has the following functions:\nmonin_obukhov_len computes the Monin-Obukhov length\ncompute_friction_velocity computes the friction velocity\ncompute_exchange_coefficients computes the exchange coefficients\n\nReferences\n\n@article{nishizawa2018surface,   title={A Surface Flux Scheme Based on the Monin-Obukhov Similarity for Finite Volume Models},   author={Nishizawa, S and Kitamura, Y},   journal={Journal of Advances in Modeling Earth Systems},   volume={10},   number={12},   pages={3159–3175},   year={2018},   publisher={Wiley Online Library} }\n\n@article{byun1990analytical,   title={On the analytical solutions of flux-profile relationships for the atmospheric surface layer},   author={Byun, Daewon W},   journal={Journal of Applied Meteorology},   volume={29},   number={7},   pages={652–657},   year={1990} }\n\n\n\n\n\n","category":"module"},{"location":"APIs/Common/SurfaceFluxes/#Methods-1","page":"Surface Fluxes","title":"Methods","text":"","category":"section"},{"location":"APIs/Common/SurfaceFluxes/#","page":"Surface Fluxes","title":"Surface Fluxes","text":"compute_buoyancy_flux\nByun1990.monin_obukhov_len\nByun1990.compute_friction_velocity\nByun1990.compute_exchange_coefficients\nNishizawa2018.monin_obukhov_len\nNishizawa2018.compute_friction_velocity\nNishizawa2018.compute_exchange_coefficients","category":"page"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.compute_buoyancy_flux","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.compute_buoyancy_flux","text":"compute_buoyancy_flux(param_set, shf, lhf, T_b, q, α_0)\n\nComputes buoyancy flux given\n\nshf sensible heat flux\nlhf latent heat flux\nT_b surface boundary temperature\nq phase partition (see PhasePartition)\nα_0 specific volume\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.Byun1990.monin_obukhov_len","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.Byun1990.monin_obukhov_len","text":"monin_obukhov_len(param_set, u, flux)\n\nComputes the Monin-Obukhov length (Eq. 3)\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.Byun1990.compute_friction_velocity","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.Byun1990.compute_friction_velocity","text":"compute_friction_velocity(param_set, flux, z_0, z_1, β_m, γ_m, tol_abs, iter_max)\n\nComputes roots of friction velocity equation (Eq. 10)\n\nu_ave = u_* ( ln(z/z_0) - ψ_m(z/L, z_0/L) ) /κ\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.Byun1990.compute_exchange_coefficients","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.Byun1990.compute_exchange_coefficients","text":"compute_exchange_coefficients(param_set, Ri, z_b, z_0, γ_m, γ_h, β_m, β_h, Pr_0)\n\nComputes exchange transfer coefficients:\n\nC_D  momentum exchange coefficient      (Eq. 36)\nC_H  thermodynamic exchange coefficient (Eq. 37)\nL_mo Monin-Obukhov length               (re-arranged Eq. 3)\n\nTODO: Pr_0 should come from CLIMAParameters\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.Nishizawa2018.monin_obukhov_len","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.Nishizawa2018.monin_obukhov_len","text":"monin_obukhov_len(param_set, u, θ, flux)\n\nComputes Monin-Obukhov length. Eq. 3\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.Nishizawa2018.compute_friction_velocity","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.Nishizawa2018.compute_friction_velocity","text":"compute_friction_velocity(param_set, u_ave, θ, flux, Δz, z_0, a, Ψ_m_tol, tol_abs, iter_max)\n\nComputes friction velocity, in Eq. 12 in, by solving the non-linear equation:\n\nu_ave = ustar/κ * ( ln(Δz/z_0) - Ψ_m(Δz/L) + z_0/Δz * Ψ_m(z_0/L) + R_z0 [ψ_m(z_0/L) - 1] )\n\nwhere L is a non-linear function of ustar (see monin_obukhov_len).\n\n\n\n\n\n","category":"function"},{"location":"APIs/Common/SurfaceFluxes/#ClimateMachine.SurfaceFluxes.Nishizawa2018.compute_exchange_coefficients","page":"Surface Fluxes","title":"ClimateMachine.SurfaceFluxes.Nishizawa2018.compute_exchange_coefficients","text":"compute_exchange_coefficients(param_set, z, F_m, F_h, a, u_star, θ, flux, Pr)\n\nComputes exchange transfer coefficients:\n\nK_D  momentum exchange coefficient\nK_H  thermodynamic exchange coefficient\nL_mo Monin-Obukhov length\n\nTODO: Pr should come from CLIMAParameters\n\n\n\n\n\n","category":"function"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Contribution-Guide-for-Abstract-Time-stepping-Algorithms-1","page":"Time-integration","title":"Contribution Guide for Abstract Time-stepping Algorithms","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"CurrentModule = ClimateMachine.ODESolvers","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"This guide gives a brief overview on how time-stepping methods are implemented in ClimateMachine, and how one might contribute a new time-stepping method.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Currently, ClimateMachine supports a variety of time-stepping methods within the Runge-Kutta framework. For purely explicit time-integration, ClimateMachine supports the following methods:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"LSRK54CarpenterKennedy\nLSRK144NiegemannDiehlBusch\nSSPRK33ShuOsher\nSSPRK34SpiteriRuuth","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Methods 1 and 2 are implemented as low-storage Runge-Kutta methods, which uses a 2N storage scheme for the coefficient arrays of the given time-stepping method (known as the Butcher Tableau). All time-integration methods are part of a single module: ODESolvers.  Each Runge-Kutta method requires one struct, with a constructor.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Basic-Template-for-an-explicit-Runge-Kutta-Method-1","page":"Time-integration","title":"Basic Template for an explicit Runge-Kutta Method","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"A basic template for an explicit Runge-Kutta method is as follows:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"export MyExplicitRKMethod\n\nstruct MyExplicitRKMethod{T, RT, AT, Nstages} <: AbstractODESolver\n    \"time step size\"\n    dt::RT\n    \"rhs function\"\n    rhs!\n    \"Storage for the stage vectors\"\n    Qstage::AT\n    \"RK coefficient vector A (rhs scaling)\"\n    RKA::Array{RT, 2}\n    \"RK coefficient vector B (rhs accumulation scaling)\"\n    RKB::Array{RT, 1}\n    \"RK coefficient vector C (temporal scaling)\"\n    RKC::Array{RT, 1}\n    # May require more attributes depending on the type of RK method\n\n    # Constructor\n    function MyExplicitRKMethod(args...)\n        # Body of the constructor\n        ...\n        return MyExplicitRKMethod(dt, rhs, Qstage, RKA, RKB, RKC)\n    end\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Once MyExplicitRKMethod is defined, we require to implement an appropriate dostep! function, which defines how to step the state vector Q forward in time:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"function ODESolver.dostep!(Q, rkmethod::MyExplicitRKMethod, p,\n                           time::Real,...)\n    # Function body\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Once dostep! is implemented, MyExplicitRKMethod should be ready for use in ClimateMachine.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Basic-Template-for-an-IMEX/Additive-Runge-Kutta-Method-1","page":"Time-integration","title":"Basic Template for an IMEX/Additive Runge-Kutta Method","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"IMEX, or IMplicit-EXplicit, Runge-Kutta methods require a bit more attention. IMEX methods are typically constructed from Additively-partitioned Runge-Kutta (ARK) methods. For IMEX methods, the standard way is to consider an ARK method with two partitions: one explicit part, and one implicit part. The implicit part will require a linear solver.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"An ARK method with an explicit and implicit component will require two Butcher Tableaus: one for each of the partitioned components.  Additionally, a linear solver is required.  Currently, ClimateMachine supports the follow set of ARK methods for IMEX-based timestepping:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"ARK2GiraldoKellyConstantinescu\nARK548L2SA2KennedyCarpenter\nARK437L2SA1KennedyCarpenter","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"For example, consider the following:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"export MyIMEXMethod\n\nusing ..LinearSolvers\nconst LS = LinearSolvers\n\nstruct MyIMEXMethod{T, RT, AT, LT, V, VS, Nstages, Nstages_sq} <: AbstractODESolver\n    \"time step\"\n    dt::RT\n    \"rhs function\"\n    rhs!\n    \"rhs linear operator\"\n    rhs_linear!\n    \"implicit operator, pre-factorized\"\n    implicitoperator!\n    \"linear solver\"\n    linearsolver::LT\n    \"Stage vectors for the ARK method\"\n    Qstages::NTuple{Nstages, AT}\n    \"RK coefficient matrix A for the explicit scheme\"\n    RKA_explicit::SArray{NTuple{2, Nstages}, RT, 2, Nstages_sq}\n    \"RK coefficient matrix A for the implicit scheme\"\n    RKA_implicit::SArray{NTuple{2, Nstages}, RT, 2, Nstages_sq}\n    \"RK coefficient vector B (rhs accumulation scaling)\"\n    RKB::SArray{Tuple{Nstages}, RT, 1, Nstages}\n    \"RK coefficient vector C (temporal scaling)\"\n    RKC::SArray{Tuple{Nstages}, RT, 1, Nstages}\n\n    # May have more attributes depending on the method\n\n    # Constructor\n    function MyIMEXMethod(args...)\n        # Body of the constructor\n        ...\n        return MyIMEXMethod(dt, rhs, rhs_linear, implicitoperator,\n                            Qstages, RKA_explicit, RKA_implicit,\n                            RKB, RKC)\n    end","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"In addition to a dostep! function, IMEX methods also require functions related to the implicitoperator, which should be interpreted as a matrix operator representing the implicit components. Depending on the coefficients in RKA_implicit, a linear solve may be required at each stage of the ARK method, or only a subset of the total stages. If the implicit operator is changing with each stage, then it will need to be updated via a function updatedt!:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"function updatedt!(ark::MyIMEXMethod, dt::Real)\n    # Function body\n    ark.implicitoperator! = prefactorize(...)\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"For information on the function prefactorize, see the module ClimateMachine.LinearSolvers.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#The-Struct-and-its-Constructor-1","page":"Time-integration","title":"The Struct and its Constructor","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"The Struct defining important quantities for a given time-integrator is a subset of an AbstractODESolver. For simplicity, we assume a standard Runge-Kutta method:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"struct MyRKMethod{T, RT, AT, Nstages} <: AbstractODESolver\n    \"time step size\"\n    dt::RT\n    \"rhs function\"\n    rhs!\n    \"Storage for the stage vectors\"\n    Qstage::AT\n    \"RK coefficient vector A (rhs scaling)\"\n    RKA::Array{RT, 2}\n    \"RK coefficient vector B (rhs accumulation scaling)\"\n    RKB::Array{RT, 1}\n    \"RK coefficient vector C (temporal scaling)\"\n    RKC::Array{RT, 1}\n    # May require more attributes depending on the type of RK method\n\n    # Constructor\n    function MyRKMethod(args...)\n        # Body of the constructor\n        ...\n        return MyRKMethod(constructor_args...)\n    end\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Since time-integration methods are often complex and drastically different from one another, the Struct and its Constructor, MyRKMethod(args...), will often look quite different, i.e. explicit and IMEX time-integrators have different Struct attributes and Constructor arguments.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"As a general rule of thumb, all Runge-Kutta-based methods will need to keep track of the time-step size dt as wells as the Butcher tableau coefficients. If your time-integrator has an implicit component (semi-implicit) or is fully implicit, the Struct will need to know about the implicitoperator and the corresponding linearsolver.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#The-dostep!-function-1","page":"Time-integration","title":"The dostep! function","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"No matter the type of time-integration method, all time-steppers require the implementation of the dostep! function. Suppose we have some time-stepper, say MyTimeIntegrator. Then the arguments to the dostep! function will be:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"function dostep!(\n    Q,\n    rkmethod::MyTimeIntegrator,\n    p,\n    time,\n    slow_δ = nothing,\n    slow_rv_dQ = nothing,\n    in_slow_scaling = nothing,\n)\n    # Function body\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Where Q is the state vector, time denotes the time for the next time-step, the time-integrator, and slow_δ, slow_rv_dQ, in_slow_scaling are optional arguments contributing to additional terms in the ODE right-hand side. More information on those argument will be covered in a later section. Note that the argument p should be interpreted as a context manager for more sophisticated time-stepping methods (for example, schemes with multiple RK methods); typical Runge-Kutta schemes will generally not need to worry about the argument p.  The argument rkmethod is used for multiple dispatch, and Q is an array that gets overwritten with field values at the next time-step.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Multirate-Runge-Kutta-Methods-1","page":"Time-integration","title":"Multirate Runge-Kutta Methods","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Multirate time-integration is a popular approach for weather and climate simulations. The core idea is that the ODE in question can be expressed as the sum of a fast and slow component. In the atmosphere, fast dynamics include the modes associated with acoustic waves (assuming a compressible or pseudo-compressible model of the atmosphere), typically on the order of 300 m/s, while dynamics associated with advection, diffusion, and radiation represent slow dynamics. The core idea behind a multirate method is to step each component (fast and slow) forward in time at a different rate (hence the name \"Multi-Rate\").","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"There are several different approaches for multirate methods. In ClimateMachine, a multirate time-stepper is provided as MultirateRungeKutta, which takes a given number of Runge-Kutta methods (one for each rate).","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Implementation-Considerations-1","page":"Time-integration","title":"Implementation Considerations","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Generally speaking, a multirate method requires composing several different time-stepping methods for different components of the ODE. Therefore, the Struct and its Constructor may look something like:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"export MyMultirateMethod\n\nstruct MyMultirateMethod{SS, FS, RT} <: AbstractODESolver\n    \"slow solver\"\n    slow_solver::SS\n    \"fast solver\"\n    fast_solver::FS\n    # May require more attributes depending on implementation\n\n    # Constructor\n    function MyMultirateMethod(args...)\n        # Body of constructor\n        ...\n        return MyMultirateMethod(constructor_args...)\n    end\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"One can imagine a scenario where several rates are operating in tandem. There are a number of possible approaches for handling this. One example is to recursively nest multiple MyMultirateMethod instances:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"function MyMultirateMethod(solvers::Tuple, Q; dt::Real)\n    # Take a tuple of solvers and defined a nested\n    # multirate method\n    fast_solver = MyMultirateMethod(solvers[2:end], Q; dt = dt)\n    slow_solver = solver[1]\n    return MyMultirateMethod(slow_solver, fast_solver, Q; dt = dt)\nend","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Note that this example assumes the solvers Tuple is ordered in such a way that the first element is the slowest solver, while all subsequent solvers are faster than the previous.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Just like all other previously mentioned time-integrators, the dostep! function will need to be implemented, taking into account the nesting of several solvers.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Writing-Tests-1","page":"Time-integration","title":"Writing Tests","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Testing is critical for the success and sustainability of any software project. Therefore, it is absolutely imperative for all newly added time-integrator to have a corresponding regression test.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"The standard way is to consider an ODE with an analytic solution. A given time-integrator will have a known convergence rate, and thus a good regression test would be to verify temporal convergence in the computed solution. Several examples can be found in ClimateMachine.jl/test/ODESolvers.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#Performance-Checks-1","page":"Time-integration","title":"Performance Checks","text":"","category":"section"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Timing performance of a time-integrator can be done using standard guidelines for CPU and GPU architectures. Certain factors that impact the performance of a time-integrator includes the following:","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Memory management – how much memory is a given method using, in","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"particular, storing stage vectors for RK methods. For IMEX methods, using direct solvers (LU factorization, for example) often has a significant impact on memory usage.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Right-hand side evaluations – for explicit methods, the total number","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"of function evaluations contributes to most of the arithmetic intensity of the time-integrator. More evaluates require more compute resources.","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"Solving linear systems – for IMEX or implicit methods, solving a linear","category":"page"},{"location":"HowToGuides/Numerics/ODESolvers/Timestepping/#","page":"Time-integration","title":"Time-integration","text":"system of equations is required. This is arguably the most expensive part of any IMEX/implicit time-integrator. Things to consider include: iterative methods, preconditioning, and parallel scalability.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#Contribution-Guide-for-Abstract-Iterative-Solvers-1","page":"Iterative Solvers","title":"Contribution Guide for Abstract Iterative Solvers","text":"","category":"section"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"An abstract iterative solver is a module that needs one struct, one constructor, and two functions in order to interface with the rest of ClimateMachine. In what follows we will describe in detail the function signatures, return values, and struct properties necessary to build with ClimateMachine.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"We have the following concrete implementations:","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"GMRES\nConjugate Residual\nConjugate Gradient\nBatched GMRES","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#Basic-Template-for-an-Iterative-Solver-1","page":"Iterative Solvers","title":"Basic Template for an Iterative Solver","text":"","category":"section"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"A basic template of an iterative solver could be as follows:","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"module MyIterativeMethodSolver\n\nexport MyIterativeMethod\n\nusing ..LinearSolvers\nconst LS = LinearSolvers\n\n# struct\nstruct MyIterativeMethod{FT} <: LS.AbstractIterativeLinearSolver\n    # minimum\n    rtol::FT\n    atol::FT\n    # Add more structure if necessary\nend\n\n# constructor\nfunction MyIterativeMethod(args...)\n    # body of constructor\n    return MyIterativeMethod(contructor_args...)\nend\n\n# initialize function (1)\nfunction LS.initialize!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, args...)\n    # body of initialize function in abstract iterative solver\n    return Bool, Int\nend\n\n# iteration function (2)\nfunction LS.doiteration!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, threshold, args...)\n    # body of iteration\n    return Bool, Int, Float\nend\n\nend # end of module","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"MyIterativeMethod and function bodies would need to be replaced appropriately for a particular implementation. We will describe each component in detail in subsequent sections.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#Struct-1","page":"Iterative Solvers","title":"Struct","text":"","category":"section"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"A subset of AbstractIterativeLinearSolver needs at least two members: atol and rtol. The former represents an absolute tolerance and the latter is a relative tolerance. Both can be used to terminate the iteration to determine the convergence criteria. An example struct could be","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"struct MyIterativeMethod{FT} <: LS.AbstractIterativeLinearSolver\n    atol::FT\n    rtol::FT\nend","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"but often has more depending on the kind of iterative solver being used.  For example, in a Krylov subspace method one would need to store a number of vectors which constitute the Krylov subspace.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#Constructor-1","page":"Iterative Solvers","title":"Constructor","text":"","category":"section"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The constructor for the struct can be defined any number of ways depending on the needs of the struct itself. Often times this is just used to allocate memory or convergence thresholds. This can also be a good place to define structures that make the iterative solver easier to work with. For example, for a columnwise solver one would want an easy array structure to work with vectors in a columnwise fashion.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"In Basic Template for an Iterative Solver we used an outer constructor, e.g.,","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"# constructor\nfunction MyIterativeMethod(args...)\n    # body of constructor\n    return MyIterativeMethod(contructor_args...)\nend","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"but we could have also used an inner constructor if desired.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#Initialize-Function-1","page":"Iterative Solvers","title":"Initialize Function","text":"","category":"section"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The initialize function needs the following signature","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"function LS.initialize!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, args...)\n    # body of initialize function in abstract iterative solver\n    return Bool, Int\nend","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The intialize function has the following arguments:","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"linearoperator! (function)\nQ    (array) [OVERWRITTEN]\nQrhs (array)\nsolver (struct) used for dispatch\nargs... passed to linearoperator! function","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The linearoperator! function is assumed to have the following signature:","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"linearoperator!(y, x, args...)\n    # body of linear operator\n    return nothing\nend","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"It represents action of a linear operator L on a vector x, that stores the value in the vector y, i.e. Lx = y. The last argument (the args...) is necessary due to how linear operators are defined within ClimateMachine.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The Q and Qrhs function arguments are supposed to represent the solution of the linear system LQ = Qrhs where L is the linear operator implicitly defined by linearoperator!.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The initialize function must have 2 return values:","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"convergence (bool)\niterations (int)","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The return values keep track of whether or not the iterative algorithm has converged as well as how many times the linear operator was applied.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#Iteration-Function-1","page":"Iterative Solvers","title":"Iteration Function","text":"","category":"section"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The iteration function needs the following signature","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"function LS.doiteration!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, threshold, args...)\n    # body of iteration\n    return Bool, Int, Float\nend","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The iteration function has the following arguments:","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"linearoperator! (function)\nQ (array) [OVERWRITTEN]\nQrhs (array)\nsolver (struct). used for dispatch\nthreshold (float). for the convergence criteria\nargs... passed into the linearoperator! function","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The linearoperator! function is assumed to have the following signature:","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"linearoperator!(y, x, args...)\n    # body of linear operator\n    return nothing\nend","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"It represents action of a linear operator L on a vector x, that stores the value in the vector y, i.e. Lx = y. The last argument (the args...) is necessary due to how linear operators are defined within ClimateMachine.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The Q and Qrhs function arguments are supposed to represent the solution of the linear system LQ = Qrhs where L is the linear operator implicitly defined by linearoperator!.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The iteration function must have 3 return values:","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"converged (bool)\niterations (int)\nresidual_norm (float64)","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The return values keep track of whether or not the iterative algorithm has converged as well as how many times the linear operator was applied. The residual norm is useful since it is often used to determine a stopping criteria.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#ClimateMachine-Specific-Considerations-1","page":"Iterative Solvers","title":"ClimateMachine Specific Considerations","text":"","category":"section"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"An MPIStateArray Q in 3D, has the following structure by default:","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"size(Q) = (n_ijk, n_s, n_e)","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"where","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"n_ijk is the number of Gauss-Lobatto points per element\nn_s is the number of states\nn_e is the number of elements","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"In three dimensions, if one wants to operate in a column-wise fashion (with a stacked-brick topology) it is easiest to reshape the array into the following form","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"alias_Q = reshape(Q, (n_i, n_j, n_k, n_s, n_ev, n_eh))","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"where","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"n_i is the number of Gauss-Lobatto points per element within","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"element that are aligned with one of the horizontal directions.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"n_j is the number of Gauss-Lobatto points per element within","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"element that are aligned with another one of the horizontal directions.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"n_k is the number of Gauss-Lobatto points within element that","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"are aligned with the vertical direction.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"n_s is the number of states\nn_ev is the number of elements in the vertical direction\nn_eh is the number of elements in the horizontal direction","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"Note: n_i x n_j x n_k = n_ijk and n_ev x n_eh = n_e.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"Thus if one wants to operate on a column for a fixed state index (let's say the int s) and a fixed horizontal coordinate (let's say fixed ints i, j, eh), then one could operator on the state:","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"one_column = alias_Q[i, j, :, s, :, eh]","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"which are the third and fifth argument in the MPIStateArray.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"Some extra tips are:","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"Since GPUs have limited memory, don't take up too much memory.\nIf possible define a preconditioner. Iterative methods are typically","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"very slow otherwise.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#Preconditioners-1","page":"Iterative Solvers","title":"Preconditioners","text":"","category":"section"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The code needs to be slightly restructured to allow for preconditioners.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#Writing-Tests-1","page":"Iterative Solvers","title":"Writing Tests","text":"","category":"section"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"Test on small systems where answers can be checked analytically. Check with matrices with easily computable inverses, i.e., the identity matrix or a diagonal matrix. Test with diverse matrix structures. Test with different array types: Arrays, CuArrays, MPIStateArrays, etc. Also test with balance laws to make sure that it can actually be run with IMEX solvers on the CPU/GPU and their distributed analogues.","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#Performance-Checks-1","page":"Iterative Solvers","title":"Performance Checks","text":"","category":"section"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"Timing performance can be done with general CPU/GPU guidelines","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#Conventions-1","page":"Iterative Solvers","title":"Conventions","text":"","category":"section"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The name of the module is the name of the struct but with solver appended\nQ refers to the initial guess for the iterative solver that gets","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"overwritten with the final solution","category":"page"},{"location":"HowToGuides/Numerics/LinearSolvers/IterativeSolvers/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"Qrhs refers to the right hand side of the linear system","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#MoistThermodynamics-docs-1","page":"MoistThermodynamics","title":"MoistThermodynamics Module","text":"","category":"section"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"MoistThermodynamics.jl provides all thermodynamic functions needed for the atmosphere and functions shared across model components. The functions are general for a moist atmosphere that includes suspended cloud condensate in the working fluid; the special case of a dry atmosphere is obtained for zero specific humidities (or simply by omitting the optional specific humidity arguments in the functions that are needed for a dry atmosphere). The general formulation assumes that there are tracers for specific humidity q, partitioned into","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"q.tot total water specific humidity\nq.liq liquid specific humidity\nq.ice ice specific humidity","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"to characterize the thermodynamic state and composition of moist air.","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"There are several types of functions:","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"Equation of state (ideal gas law):\nair_pressure\nSpecific gas constant and isobaric and isochoric specific heats of moist air:\ngas_constant_air\ncp_m\ncv_m\nSpecific latent heats of vaporization, fusion, and sublimation:\nlatent_heat_vapor\nlatent_heat_fusion\nlatent_heat_sublim\nSaturation vapor pressure and specific humidity over liquid and ice:\nsat_vapor_press_liquid\nsat_vapor_press_ice\nsat_shum\nFunctions computing energies and inverting them to obtain temperatures\ntotal_energy\ninternal_energy\nair_temperature\nFunctions to compute temperatures and partitioning of water into phases in thermodynamic equilibrium (when Gibbs' phase rule implies that the entire thermodynamic state of moist air, including the liquid and ice specific humidities, can be calculated from the 3 thermodynamic state variables, such as energy, pressure, and total specific humidity)\nliquid_fraction (fraction of condensate that is liquid)\nsaturation_adjustment (compute temperature from energy, density, and total specific humidity)\nAuxiliary functions for diagnostic purposes, e.g., other thermodynamic","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"quantities     * liquid_ice_pottemp (liquid-ice potential temperature)","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"A moist dynamical core that assumes equilibrium thermodynamics can be obtained from a dry dynamical core with total energy as a prognostic variable by including a tracer for the total specific humidity q.tot, using the functions, e.g., for the energies in the module, and computing the temperature T and the liquid and ice specific humidities (q.liq and q.ice) from the internal energy e_int by saturation adjustment.","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#Usage-1","page":"MoistThermodynamics","title":"Usage","text":"","category":"section"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"Users are encouraged to first establish a thermodynamic state with one of our Thermodynamic State Constructors. For example, we would construct a moist thermodynamic state using","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"ts = PhaseEquil(param_set, e_int, ρ, q_tot);","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"here, ρ is the density of the moist air, and the internal energy e_int = e_tot - e_kin - geopotential is the total energy e_tot minus kinetic energy e_kin and potential energy geopotential (all energies per unit mass). Once we've established a thermodynamic state, we can call Thermodynamic state methods that support thermodynamic states:","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"T = air_temperature(ts);\nq = PhasePartition(ts);","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"No changes to the \"right-hand sides\" of the dynamical equations are needed for a moist dynamical core that supports clouds, as long as they do not precipitate. Additional source-sink terms arise from precipitation.","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"Schematically, the workflow in such a core would look as follows:","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"# initialize\ngeopotential = grav * z\nq_tot          = ...\nρ            = ...\n\n(u, v, w)    = ...\ne_kin           = 0.5 * (u^2 + v^2 + w^2)\n\ne_tot        = total_energy(e_kin, geopotential, T, q_tot)\n\ndo timestep   # timestepping loop\n\n  # advance dynamical variables by a timestep (temperature typically\n  # appears in terms on the rhs, such as radiative transfer)\n  advance(u, v, w, ρ, e_tot, q_tot)\n\n  # compute internal energy from dynamic variables\n  e_int = e_tot - 0.5 * (u^2 + v^2 + w^2) - geopotential\n\n  # compute temperature, pressure and condensate specific humidities,\n  ts = PhaseEquil(param_set, e_int, ρ, q_tot);\n  T = air_temperature(ts);\n  q = PhasePartition(ts);\n  p = air_pressure(ts);\n\nend","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"For a dynamical core that additionally uses the liquid and ice specific humidities q.liq and q.ice as prognostic variables, and thus explicitly allows the presence of non-equilibrium phases such as supercooled water, the saturation adjustment in the above workflow is replaced calling a non-equilibrium moist thermodynamic state:","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"q_tot, q_liq, q_ice = ...\nts = PhaseNonEquil(param_set, e_int, ρ, PhasePartition(q_tot, q_liq, q_ice));\nT = air_temperature(ts);\np = air_pressure(ts);","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#Extending-1","page":"MoistThermodynamics","title":"Extending","text":"","category":"section"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"If MoistThermodynamics.jl does not have a particular thermodynamic constructor that is needed, you can implement a new one in src/Common/MoistThermodynamics/states.jl. In this constructor, you must add whichever arguments you wish to offer as inputs, then translate this thermodynamic state into one of:","category":"page"},{"location":"HowToGuides/Common/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"PhaseDry a dry thermodynamic state, uniquely determined by two independent thermodynamic properties\nPhaseEquil a moist thermodynamic state in thermodynamic equilibrium, uniquely determined by three independent thermodynamic properties\nPhaseNonEquil a moist thermodynamic state in thermodynamic non-equilibrium, uniquely determined by four independent thermodynamic properties","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Land/Heat/heat_equation.jl\"","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Heat-equation-tutorial-1","page":"Heat Equation","title":"Heat equation tutorial","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"In this tutorial, we'll be solving the heat equation:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"frac ρcT t +   (-α ρcT) = 0","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"where","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"t is time\nα is the thermal diffusivity\nT is the temperature\nρ is the density\nc is the heat capacity\nρcT is the thermal energy","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"To put this in the form of ClimateMachine's BalanceLaw, we'll re-write the equation as:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"frac ρcT t +   (F(α ρcT t)) = 0","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"where","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"F(α ρcT t) = -α ρcT is the second-order flux","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"with boundary conditions","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Fixed temperature T_surface at z_min (non-zero Dirichlet)\nNo thermal flux at z_min (zero Neumann)","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Solving these equations is broken down into the following steps:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Preliminary configuration\nPDEs\nSpace discretization\nTime discretization\nSolver hooks / callbacks\nSolve\nPost-processing","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Preliminary-configuration-1","page":"Heat Equation","title":"Preliminary configuration","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#Loading-code-1","page":"Heat Equation","title":"Loading code","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"First, we'll load our pre-requisites:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"load external packages:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"using MPI\nusing OrderedCollections\nusing Plots\nusing StaticArrays","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"load CLIMAParameters and set up to use it:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"using CLIMAParameters\nstruct EarthParameterSet <: AbstractEarthParameterSet end\nconst param_set = EarthParameterSet()","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"load necessary ClimateMachine modules:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"using ClimateMachine\nusing ClimateMachine.Mesh.Topologies\nusing ClimateMachine.Mesh.Grids\nusing ClimateMachine.Writers\nusing ClimateMachine.DGmethods\nusing ClimateMachine.DGmethods.NumericalFluxes\nusing ClimateMachine.DGmethods: BalanceLaw, LocalGeometry\nusing ClimateMachine.MPIStateArrays\nusing ClimateMachine.GenericCallbacks\nusing ClimateMachine.ODESolvers\nusing ClimateMachine.VariableTemplates\nusing ClimateMachine.SingleStackUtils","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"import necessary ClimateMachine modules: (importing enables us to","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"provide implementations of these structs/methods)","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"import ClimateMachine.DGmethods:\n    vars_state_auxiliary,\n    vars_state_conservative,\n    vars_state_gradient,\n    vars_state_gradient_flux,\n    source!,\n    flux_second_order!,\n    flux_first_order!,\n    compute_gradient_argument!,\n    compute_gradient_flux!,\n    update_auxiliary_state!,\n    nodal_update_auxiliary_state!,\n    init_state_auxiliary!,\n    init_state_conservative!,\n    boundary_state!","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Initialization-1","page":"Heat Equation","title":"Initialization","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Define the float type (Float64 or Float32)","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"FT = Float64;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Initialize ClimateMachine for CPU.","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"ClimateMachine.init(; disable_gpu = true);\n\nconst clima_dir = dirname(dirname(pathof(ClimateMachine)));\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Load some helper functions for plotting","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"include(joinpath(clima_dir, \"docs\", \"plothelpers.jl\"));\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Define-the-set-of-Partial-Differential-Equations-(PDEs)-1","page":"Heat Equation","title":"Define the set of Partial Differential Equations (PDEs)","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#Define-the-model-1","page":"Heat Equation","title":"Define the model","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Model parameters can be stored in the particular BalanceLaw, in this case, a HeatModel:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Base.@kwdef struct HeatModel{FT} <: BalanceLaw\n    \"Parameters\"\n    param_set::AbstractParameterSet = param_set\n    \"Heat capacity\"\n    ρc::FT = 1\n    \"Thermal diffusivity\"\n    α::FT = 0.01\n    \"Initial conditions for temperature\"\n    initialT::FT = 295.15\n    \"Bottom boundary value for temperature (Dirichlet boundary conditions)\"\n    T_bottom::FT = 300.0\n    \"Top flux (α∇ρcT) at top boundary (Neumann boundary conditions)\"\n    flux_top::FT = 0.0\nend","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Create an instance of the HeatModel:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"m = HeatModel{FT}();\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"This model dictates the flow control, using Dynamic Multiple Dispatch, for which kernels are executed.","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Define-the-variables-1","page":"Heat Equation","title":"Define the variables","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"All of the methods defined in this section were imported in # Loading code to let us provide implementations for our HeatModel as they will be used by the solver.","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Specify auxiliary variables for HeatModel","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"vars_state_auxiliary(::HeatModel, FT) = @vars(z::FT, T::FT);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Specify state variables, the variables solved for in the PDEs, for HeatModel","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"vars_state_conservative(::HeatModel, FT) = @vars(ρcT::FT);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Specify state variables whose gradients are needed for HeatModel","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"vars_state_gradient(::HeatModel, FT) = @vars(ρcT::FT);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Specify gradient variables for HeatModel","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"vars_state_gradient_flux(::HeatModel, FT) = @vars(α∇ρcT::SVector{3, FT});\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Define-the-compute-kernels-1","page":"Heat Equation","title":"Define the compute kernels","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Specify the initial values in aux::Vars, which are available in init_state_conservative!. Note that","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"this method is only called at t=0\naux.z and aux.T are available here because we've specified z and T","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"in vars_state_auxiliary","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"function init_state_auxiliary!(m::HeatModel, aux::Vars, geom::LocalGeometry)\n    aux.z = geom.coord[3]\n    aux.T = m.initialT\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Specify the initial values in state::Vars. Note that","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"this method is only called at t=0\nstate.ρcT is available here because we've specified ρcT in","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"vars_state_conservative","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"function init_state_conservative!(\n    m::HeatModel,\n    state::Vars,\n    aux::Vars,\n    coords,\n    t::Real,\n)\n    state.ρcT = m.ρc * aux.T\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"The remaining methods, defined in this section, are called at every time-step in the solver by the BalanceLaw framework.","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Overload update_auxiliary_state! to call heat_eq_nodal_update_aux!, or any other auxiliary methods","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"function update_auxiliary_state!(\n    dg::DGModel,\n    m::HeatModel,\n    Q::MPIStateArray,\n    t::Real,\n    elems::UnitRange,\n)\n    nodal_update_auxiliary_state!(heat_eq_nodal_update_aux!, dg, m, Q, t, elems)\n    return true # TODO: remove return true\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Compute/update all auxiliary variables at each node. Note that","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"aux.T is available here because we've specified T in","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"vars_state_auxiliary","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"function heat_eq_nodal_update_aux!(\n    m::HeatModel,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    aux.T = state.ρcT / m.ρc\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Since we have second-order fluxes, we must tell ClimateMachine to compute the gradient of ρcT. Here, we specify how ρcT is computed. Note that","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"transform.ρcT is available here because we've specified ρcT in","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"vars_state_gradient","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"function compute_gradient_argument!(\n    m::HeatModel,\n    transform::Vars,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    transform.ρcT = state.ρcT\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Specify where in diffusive::Vars to store the computed gradient from compute_gradient_argument!. Note that:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"diffusive.α∇ρcT is available here because we've specified α∇ρcT in","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"vars_state_gradient_flux","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"∇transform.ρcT is available here because we've specified ρcT  in","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"vars_state_gradient","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"function compute_gradient_flux!(\n    m::HeatModel,\n    diffusive::Vars,\n    ∇transform::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    diffusive.α∇ρcT = -m.α * ∇transform.ρcT\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"We have no sources, nor non-diffusive fluxes.","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"function source!(m::HeatModel, _...) end;\nfunction flux_first_order!(\n    m::HeatModel,\n    flux::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n) end;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Compute diffusive flux (F(α ρcT t) = -α ρcT in the original PDE). Note that:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"diffusive.α∇ρcT is available here because we've specified α∇ρcT in","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"vars_state_gradient_flux","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"function flux_second_order!(\n    m::HeatModel,\n    flux::Grad,\n    state::Vars,\n    diffusive::Vars,\n    hyperdiffusive::Vars,\n    aux::Vars,\n    t::Real,\n)\n    flux.ρcT += diffusive.α∇ρcT\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Boundary-conditions-1","page":"Heat Equation","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Second-order terms in our equations, (F) where F = -αρcT, are internally reformulated to first-order unknowns. Boundary conditions must be specified for all unknowns, both first-order and second-order unknowns which have been reformulated.","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"The boundary conditions for ρcT (first order unknown)","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"function boundary_state!(\n    nf,\n    m::HeatModel,\n    state⁺::Vars,\n    aux⁺::Vars,\n    n⁻,\n    state⁻::Vars,\n    aux⁻::Vars,\n    bctype,\n    t,\n    _...,\n)\n    if bctype == 1 # bottom\n        state⁺.ρcT = m.ρc * m.T_bottom\n    elseif bctype == 2 # top\n        nothing\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"The boundary conditions for ρcT are specified here for second-order unknowns","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"function boundary_state!(\n    nf,\n    m::HeatModel,\n    state⁺::Vars,\n    diff⁺::Vars,\n    aux⁺::Vars,\n    n⁻,\n    state⁻::Vars,\n    diff⁻::Vars,\n    aux⁻::Vars,\n    bctype,\n    t,\n    _...,\n)\n    if bctype == 1 # bottom\n        state⁺.ρcT = m.ρc * m.T_bottom\n    elseif bctype == 2 # top\n        diff⁺.α∇ρcT = n⁻ * m.flux_top\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Spatial-discretization-1","page":"Heat Equation","title":"Spatial discretization","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Prescribe polynomial order of basis functions in finite elements","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"N_poly = 5;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Specify the number of vertical elements","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"nelem_vert = 10;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Specify the domain height","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"zmax = FT(1);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Establish a ClimateMachine single stack configuration","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"driver_config = ClimateMachine.SingleStackConfiguration(\n    \"HeatEquation\",\n    N_poly,\n    nelem_vert,\n    zmax,\n    param_set,\n    m,\n    numerical_flux_first_order = CentralNumericalFluxFirstOrder(),\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Time-discretization-1","page":"Heat Equation","title":"Time discretization","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Specify simulation time (SI units)","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"t0 = FT(0)\ntimeend = FT(40)","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"We'll define the time-step based on the Fourier number","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Δ = min_node_distance(driver_config.grid)\n\ngiven_Fourier = FT(0.08);\nFourier_bound = given_Fourier * Δ^2 / m.α;\ndt = Fourier_bound","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Configure-a-ClimateMachine-solver.-1","page":"Heat Equation","title":"Configure a ClimateMachine solver.","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"This initializes the state vector and allocates memory for the solution in space (dg has the model m, which describes the PDEs as well as the function used for initialization). This additionally initializes the ODE solver, by default an explicit Low-Storage Runge-Kutta method.","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"solver_config =\n    ClimateMachine.SolverConfiguration(t0, timeend, driver_config, ode_dt = dt);\ngrid = solver_config.dg.grid;\nQ = solver_config.Q;\naux = solver_config.dg.state_auxiliary;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Inspect-the-initial-conditions-1","page":"Heat Equation","title":"Inspect the initial conditions","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Let's export a plot of the initial state","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"output_dir = @__DIR__;\n\nmkpath(output_dir);\n\nz_scale = 100 # convert from meters to cm\nz_key = \"z\"\nz_label = \"z [cm]\"\nz = get_z(grid, z_scale)\nstate_vars = SingleStackUtils.get_vars_from_nodal_stack(\n    grid,\n    Q,\n    vars_state_conservative(m, FT),\n)\naux_vars = SingleStackUtils.get_vars_from_nodal_stack(\n    grid,\n    aux,\n    vars_state_auxiliary(m, FT),\n)\nall_vars = OrderedDict(state_vars..., aux_vars...);\nexport_plot_snapshot(\n    z,\n    all_vars,\n    (\"ρcT\",),\n    joinpath(output_dir, \"initial_condition.png\"),\n    z_label,\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"(Image: )","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"It matches what we have in init_state_conservative!(m::HeatModel, ...), so let's continue.","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Solver-hooks-/-callbacks-1","page":"Heat Equation","title":"Solver hooks / callbacks","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Define the number of outputs from t0 to timeend","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"const n_outputs = 5;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"This equates to exports every ceil(Int, timeend/n_outputs) time-step:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"const every_x_simulation_time = ceil(Int, timeend / n_outputs);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Create a nested dictionary to store the solution:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"all_data = Dict([k => Dict() for k in 0:n_outputs]...)\nall_data[0] = all_vars # store initial condition at ``t=0``","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"The ClimateMachine's time-steppers provide hooks, or callbacks, which allow users to inject code to be executed at specified intervals. In this callback, the state and aux variables are collected, combined into a single OrderedDict and written to a NetCDF file (for each output step step).","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"step = [1];\ncallback = GenericCallbacks.EveryXSimulationTime(\n    every_x_simulation_time,\n    solver_config.solver,\n) do (init = false)\n    state_vars = SingleStackUtils.get_vars_from_nodal_stack(\n        grid,\n        Q,\n        vars_state_conservative(m, FT),\n    )\n    aux_vars = SingleStackUtils.get_vars_from_nodal_stack(\n        grid,\n        aux,\n        vars_state_auxiliary(m, FT);\n        exclude = [z_key],\n    )\n    all_vars = OrderedDict(state_vars..., aux_vars...)\n    all_data[step[1]] = all_vars\n\n    step[1] += 1\n    nothing\nend;\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Solve-1","page":"Heat Equation","title":"Solve","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"This is the main ClimateMachine solver invocation. While users do not have access to the time-stepping loop, code may be injected via user_callbacks, which is a Tuple of GenericCallbacks.","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"ClimateMachine.invoke!(solver_config; user_callbacks = (callback,));\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#Post-processing-1","page":"Heat Equation","title":"Post-processing","text":"","category":"section"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Our solution is stored in the nested dictionary all_data whose keys are the output interval. The next level keys are the variable names, and the values are the values along the grid:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"To get T at t=0, we can use T_at_t_0 = all_data[0][\"T\"][:]","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"@show keys(all_data[0])","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"Let's plot the solution:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"export_plot(\n    z,\n    all_data,\n    (\"ρcT\",),\n    joinpath(output_dir, \"solution_vs_time.png\"),\n    z_label,\n);\nnothing #hide","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"(Image: )","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"The results look as we would expect: a fixed temperature at the bottom is resulting in heat flux that propagates up the domain. To run this file, and inspect the solution in all_data, include this tutorial in the Julia REPL with:","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"include(joinpath(\"tutorials\", \"Land\", \"Heat\", \"heat_equation.jl\"))","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"","category":"page"},{"location":"generated/Land/Heat/heat_equation/#","page":"Heat Equation","title":"Heat Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/Diagnostics/InputOutput/#InputOutput-1","page":"Input/Output","title":"InputOutput","text":"","category":"section"},{"location":"APIs/Diagnostics/InputOutput/#","page":"Input/Output","title":"Input/Output","text":"CurrentModule = ClimateMachine","category":"page"},{"location":"APIs/Diagnostics/InputOutput/#VTK-1","page":"Input/Output","title":"VTK","text":"","category":"section"},{"location":"APIs/Diagnostics/InputOutput/#Functions-1","page":"Input/Output","title":"Functions","text":"","category":"section"},{"location":"APIs/Diagnostics/InputOutput/#","page":"Input/Output","title":"Input/Output","text":"VTK.writevtk\nVTK.writevtk_helper","category":"page"},{"location":"APIs/Diagnostics/InputOutput/#ClimateMachine.VTK.writevtk","page":"Input/Output","title":"ClimateMachine.VTK.writevtk","text":"writevtk(prefix, Q::MPIStateArray, dg::DGModel [, fieldnames])\n\nWrite a vtk file for all the fields in the state array Q using geometry and connectivity information from dg.grid. The filename will start with prefix which may also contain a directory path. The names used for each of the fields in the vtk file can be specified through the collection of strings fieldnames; if not specified the fields names will be \"Q1\" through \"Qk\" where k is the number of states in Q, i.e., k = size(Q,2).\n\n\n\n\n\nwritevtk(prefix, Q::MPIStateArray, dg::DGModel, fieldnames,\n         state_auxiliary::MPIStateArray, auxfieldnames)\n\nWrite a vtk file for all the fields in the state array Q and auxiliary state state_auxiliary using geometry and connectivity information from dg.grid. The filename will start with prefix which may also contain a directory path. The names used for each of the fields in the vtk file can be specified through the collection of strings fieldnames and auxfieldnames.\n\nIf fieldnames === nothing then the fields names will be \"Q1\" through \"Qk\" where k is the number of states in Q, i.e., k = size(Q,2).\n\nIf auxfieldnames === nothing then the fields names will be \"aux1\" through \"auxk\" where k is the number of states in state_auxiliary, i.e., k = size(state_auxiliary,2).\n\n\n\n\n\nwritegrid(prefix, grid::DiscontinuousSpectralElementGrid)\n\nWrite a vtk file for the grid.  The filename will start with prefix which may also contain a directory path.\n\n\n\n\n\n","category":"function"},{"location":"APIs/Diagnostics/InputOutput/#ClimateMachine.VTK.writevtk_helper","page":"Input/Output","title":"ClimateMachine.VTK.writevtk_helper","text":"writevtk_helper(prefix, vgeo::Array, Q::Array, grid, fieldnames)\n\nInternal helper function for writevtk\n\n\n\n\n\n","category":"function"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Numerics/LinearSolvers/cg.jl\"","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#Conjugate-Gradient-1","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"","category":"section"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"In this tutorial we describe the basics of using the conjugate gradient iterative solvers At the end you should be able to","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Use Conjugate Gradient to solve a linear system\nKnow when to not use it\nContruct a column-wise linear solver with Conjugate Gradient","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#What-is-it?-1","page":"Conjugate Gradient","title":"What is it?","text":"","category":"section"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Conjugate Gradient is an iterative method for solving special kinds of linear systems:","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":" Ax = b","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"via iterative methods.","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"warning: Warning\nThe linear operator need to be symmetric positive definite and the preconditioner must be symmetric.","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"See the wikipedia for more details.","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#Basic-Example-1","page":"Conjugate Gradient","title":"Basic Example","text":"","category":"section"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"First we must load a few things","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"using ClimateMachine,\n    ClimateMachine.LinearSolvers, ClimateMachine.ConjugateGradientSolver\nusing LinearAlgebra, Random","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Next we define a 3x3 symmetric positive definite linear system. (In the ClimateMachine code a symmetric positive definite system could arise from treating diffusion implicitly.)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"A = [\n    2.0 -1.0 0.0\n    -1.0 2.0 -1.0\n    0.0 -1.0 2.0\n];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We define the matrix A here as a global variable for convenience later.","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We can see that it is symmetric. We can check that it is positive definite by checking the spectrum","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"eigvals(A)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The linear operators that are passed into the abstract iterative solvers need to be defined as functions that act on vectors. Let us do that with our matrix. We are using function closures for type stability.","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"function closure_linear_operator!(A)\n    function linear_operator!(x, y)\n        mul!(x, A, y)\n    end\n    return linear_operator!\nend;\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We now define our linear operator using the function closure","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"linear_operator! = closure_linear_operator!(A)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We now define our b in the linear system","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"b = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The exact solution to the system Ax = b is","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"x_exact = [1.5, 2.0, 1.5];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now we can set up the ConjugateGradient struct","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"linearsolver = ConjugateGradient(b);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"and an initial guess for the iterative solver.","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"x = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"To solve the linear system we just need to pass to the linearsolve! function","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters = linearsolve!(linear_operator!, linearsolver, x, b)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The variable x gets overwitten during the linear solve The norm of the error is","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"norm(x - x_exact) / norm(x_exact)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The relative norm of the residual is","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"norm(A * x - b) / norm(b)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The number of iterations is","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Conjugate Gradient is guaranteed to converge in 3 iterations with perfect arithmetic in this case.","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#Non-Example-1","page":"Conjugate Gradient","title":"Non-Example","text":"","category":"section"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Conjugate Gradient is not guaranteed to converge with nonsymmetric matrices. Consider","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"A = [\n    2.0 -1.0 0.0\n    0.0 2.0 -1.0\n    0.0 0.0 2.0\n];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We define the matrix A here as a global variable for convenience later.","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We can see that it is not symmetric, but it does have all positive eigenvalues","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"eigvals(A)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The linear operators that are passed into the abstract iterative solvers need to be defined as functions that act on vectors. Let us do that with our matrix. We are using function closures for type stability.","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"function closure_linear_operator!(A)\n    function linear_operator!(x, y)\n        mul!(x, A, y)\n    end\n    return linear_operator!\nend;\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We define the linear operator using our function closure","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"linear_operator! = closure_linear_operator!(A)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We now define our b in the linear system","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"b = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The exact solution to the system Ax = b is","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"x_exact = [0.875, 0.75, 0.5];\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now we can set up the ConjugateGradient struct","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"linearsolver = ConjugateGradient(b, max_iter = 100);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We also passed in the keyword argument \"max_iter\" for the maximum number of iterations of the iterative solver. By default it is assumed to be the size of the vector. As before we need to define an initial guess","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"x = ones(typeof(1.0), 3);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"To (not) solve the linear system we just need to pass to the linearsolve! function","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters = linearsolve!(linear_operator!, linearsolver, x, b)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The variable x gets overwitten during the linear solve The norm of the error is","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"norm(x - x_exact) / norm(x_exact)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The relative norm of the residual is","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"norm(A * x - b) / norm(b)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The number of iterations is","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Conjugate Gradient is guaranteed to converge in 3 iterations with perfect arithmetic for a symmetric positive definite matrix. Here we see that the matrix is not symmetric and it didn't converge even after 100 iterations.","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#More-Complex-Example-1","page":"Conjugate Gradient","title":"More Complex Example","text":"","category":"section"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Here we show how to construct a column-wise iterative solver similar to what is is in the ClimateMachine code. The following is not for the faint of heart. We must first define a linear operator that acts like one in the ClimateMachine","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"function closure_linear_operator!(A, tup)\n    function linear_operator!(y, x)\n        alias_x = reshape(x, tup)\n        alias_y = reshape(y, tup)\n        for i6 in 1:tup[6]\n            for i4 in 1:tup[4]\n                for i2 in 1:tup[2]\n                    for i1 in 1:tup[1]\n                        tmp = alias_x[i1, i2, :, i4, :, i6][:]\n                        tmp2 = A[i1, i2, i4, i6] * tmp\n                        alias_y[i1, i2, :, i4, :, i6] .=\n                            reshape(tmp2, (tup[3], tup[5]))\n                    end\n                end\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now that we have this function, we can define a linear system that we will solve columnwise First we define the structure of our array as tup in a manner that is similar to a stacked brick topology","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"tup = (3, 4, 7, 2, 20, 2);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"where","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"tup[1] is the number of Gauss–Lobatto points in the x-direction\ntup[2] is the number of Gauss–Lobatto points in the y-direction\ntup[3] is the number of Gauss–Lobatto points in the z-direction\ntup[4] is the number of states\ntup[5] is the number of elements in the vertical direction\ntup[6] is the number of elements in the other directions","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now we define our linear operator as a random matrix.","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Random.seed!(1235);\nB = [\n    randn(tup[3] * tup[5], tup[3] * tup[5])\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\ncolumnwise_A = [\n    B[i1, i2, i4, i6] * B[i1, i2, i4, i6]' + 10I\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\ncolumnwise_inv_A = [\n    inv(columnwise_A[i1, i2, i4, i6])\n    for i1 in 1:tup[1], i2 in 1:tup[2], i4 in 1:tup[4], i6 in 1:tup[6]\n];\ncolumnwise_linear_operator! = closure_linear_operator!(columnwise_A, tup);\ncolumnwise_inverse_linear_operator! =\n    closure_linear_operator!(columnwise_inv_A, tup);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"We define our x and b with matrix structures similar to an MPIStateArray","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"mpi_tup = (tup[1] * tup[2] * tup[3], tup[4], tup[5] * tup[6]);\nb = randn(mpi_tup);\nx = randn(mpi_tup);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now we solve the linear system columnwise","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"linearsolver = ConjugateGradient(\n    x,\n    max_iter = tup[3] * tup[5],\n    dims = (3, 5),\n    reshape_tuple = tup,\n);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The keyword arguments dims is the reduction dimension for the linear solver. In this case dims = (3,5) are the ones associated with a column. The reshape_tuple argument is to convert the shapes of the array x in the a form that is more easily usable for reductions in the linear solver","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"Now we can solve it","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters = linearsolve!(columnwise_linear_operator!, linearsolver, x, b);\nx_exact = copy(x);\ncolumnwise_inverse_linear_operator!(x_exact, b);\nnothing #hide","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The norm of the error is","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"norm(x - x_exact) / norm(x_exact)","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The number of iterations is","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"iters","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The algorithm converges within tup[3]*tup[5] = 140 iterations","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#Tips-1","page":"Conjugate Gradient","title":"Tips","text":"","category":"section"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"The convergence criteria should be changed, machine precision is too small and the maximum iterations is often too large\nUse a preconditioner if possible\nMake sure that the linear system really is symmetric and positive-definite","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"","category":"page"},{"location":"generated/Numerics/LinearSolvers/cg/#","page":"Conjugate Gradient","title":"Conjugate Gradient","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"EditURL = \"https://github.com/CliMA/ClimateMachine.jl/blob/master/tutorials/Microphysics/ex_2_Kessler.jl\"","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"include(\"KinematicModel.jl\")\n\nfunction vars_state_conservative(m::KinematicModel, FT)\n    @vars begin\n        ρ::FT\n        ρu::SVector{3, FT}\n        ρe::FT\n        ρq_tot::FT\n        ρq_liq::FT\n        ρq_ice::FT\n        ρq_rai::FT\n    end\nend\n\nfunction vars_state_auxiliary(m::KinematicModel, FT)\n    @vars begin","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"defined in initstateauxiliary","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"        p::FT\n        z::FT","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"defined in update_aux","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"        u::FT\n        w::FT\n        q_tot::FT\n        q_vap::FT\n        q_liq::FT\n        q_ice::FT\n        q_rai::FT\n        e_tot::FT\n        e_kin::FT\n        e_pot::FT\n        e_int::FT\n        T::FT\n        S::FT\n        RH::FT\n        rain_w::FT","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"uncomment below for more diagnostics","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"        #src_cloud_liq::FT\n        #src_cloud_ice::FT\n        #src_acnv::FT\n        #src_accr::FT\n        #src_rain_evap::FT\n        #flag_rain::FT\n        #flag_cloud_liq::FT\n        #flag_cloud_ice::FT\n    end\nend\n\nfunction init_kinematic_eddy!(eddy_model, state, aux, (x, y, z), t)\n    FT = eltype(state)\n    _grav::FT = grav(param_set)\n\n    dc = eddy_model.data_config","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"density","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    q_pt_0 = PhasePartition(dc.qt_0)\n    R_m, cp_m, cv_m, γ = gas_constants(param_set, q_pt_0)\n    T::FT = dc.θ_0 * (aux.p / dc.p_1000)^(R_m / cp_m)\n    ρ::FT = aux.p / R_m / T\n    state.ρ = ρ","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"moisture","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    state.ρq_tot = ρ * dc.qt_0\n    state.ρq_liq = ρ * q_pt_0.liq\n    state.ρq_ice = ρ * q_pt_0.ice\n    state.ρq_rai = ρ * FT(0)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"velocity (derivative of streamfunction)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    ρu::FT =\n        dc.wmax * dc.xmax / dc.zmax *\n        cos(π * z / dc.zmax) *\n        cos(2 * π * x / dc.xmax)\n    ρw::FT = 2 * dc.wmax * sin(π * z / dc.zmax) * sin(2 * π * x / dc.xmax)\n    state.ρu = SVector(ρu, FT(0), ρw)\n    u::FT = ρu / ρ\n    w::FT = ρw / ρ","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"energy","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    e_kin::FT = 1 // 2 * (u^2 + w^2)\n    e_pot::FT = _grav * z\n    e_int::FT = internal_energy(param_set, T, q_pt_0)\n    e_tot::FT = e_kin + e_pot + e_int\n    state.ρe = ρ * e_tot\n\n    return nothing\nend\n\nfunction kinematic_model_nodal_update_auxiliary_state!(\n    m::KinematicModel,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    FT = eltype(state)\n    _grav::FT = grav(param_set)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"velocity","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    aux.u = state.ρu[1] / state.ρ\n    aux.w = state.ρu[3] / state.ρ","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"water","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    aux.q_tot = state.ρq_tot / state.ρ\n    aux.q_liq = state.ρq_liq / state.ρ\n    aux.q_ice = state.ρq_ice / state.ρ\n    aux.q_rai = state.ρq_rai / state.ρ\n    aux.q_vap = aux.q_tot - aux.q_liq - aux.q_ice","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"energy","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    aux.e_tot = state.ρe / state.ρ\n    aux.e_kin = 1 // 2 * (aux.u^2 + aux.w^2)\n    aux.e_pot = _grav * aux.z\n    aux.e_int = aux.e_tot - aux.e_kin - aux.e_pot","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"supersaturation","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    q = PhasePartition(aux.q_tot, aux.q_liq, aux.q_ice)\n    aux.T = air_temperature(param_set, aux.e_int, q)\n    ts_neq = TemperatureSHumNonEquil(param_set, aux.T, state.ρ, q)\n    aux.S = max(0, aux.q_vap / q_vap_saturation(ts_neq) - FT(1)) * FT(100)\n    aux.RH = aux.q_vap / q_vap_saturation(ts_neq) * FT(100)\n\n    aux.rain_w = terminal_velocity(param_set, aux.q_rai, state.ρ)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"uncomment below for more diagnostics","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    #ts_eq = TemperatureSHumEquil(param_set, aux.T, state.ρ, aux.q_tot)\n    #q_eq = PhasePartition(ts_eq)\n    #aux.src_cloud_liq = conv_q_vap_to_q_liq(q_eq, q)\n    #aux.src_cloud_ice = conv_q_vap_to_q_ice(q_eq, q)\n    #aux.src_acnv = conv_q_liq_to_q_rai_acnv(aux.q_liq)\n    #aux.src_accr = conv_q_liq_to_q_rai_accr(aux.q_liq, aux.q_rai, state.ρ)\n    #aux.src_rain_evap = conv_q_rai_to_q_vap(aux.q_rai, q, aux.T, aux.p, state.ρ)\n    #aux.flag_cloud_liq = FT(0)\n    #aux.flag_cloud_ice = FT(0)\n    #aux.flag_rain = FT(0)\n    #if (aux.q_liq >= FT(0))","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"aux.flagcloudliq = FT(1)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    #end\n    #if (aux.q_ice >= FT(0))","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"aux.flagcloudice = FT(1)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    #end\n    #if (aux.q_rai >= FT(0))","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"aux.flag_rain = FT(1)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    #end\nend\n\nfunction boundary_state!(\n    ::RusanovNumericalFlux,\n    m::KinematicModel,\n    state⁺,\n    aux⁺,\n    n,\n    state⁻,\n    aux⁻,\n    bctype,\n    t,\n    args...,\n)\n    #state⁺.ρu -= 2 * dot(state⁻.ρu, n) .* SVector(n)\n    state⁺.ρq_rai = -state⁻.ρq_rai\nend\n\n@inline function wavespeed(\n    m::KinematicModel,\n    nM,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    FT = eltype(state)\n    u = state.ρu / state.ρ\n    rain_w = terminal_velocity(param_set, state.ρq_rai / state.ρ, state.ρ)\n    nu = nM[1] * u[1] + nM[3] * max(u[3], rain_w, u[3] - rain_w)\n\n    return abs(nu)\nend\n\n@inline function flux_first_order!(\n    m::KinematicModel,\n    flux::Grad,\n    state::Vars,\n    aux::Vars,\n    t::Real,\n)\n    FT = eltype(state)\n    rain_w = terminal_velocity(param_set, state.ρq_rai / state.ρ, state.ρ)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"advect moisture ...","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    flux.ρq_tot = SVector(\n        state.ρu[1] * state.ρq_tot / state.ρ,\n        FT(0),\n        state.ρu[3] * state.ρq_tot / state.ρ,\n    )\n    flux.ρq_liq = SVector(\n        state.ρu[1] * state.ρq_liq / state.ρ,\n        FT(0),\n        state.ρu[3] * state.ρq_liq / state.ρ,\n    )\n    flux.ρq_ice = SVector(\n        state.ρu[1] * state.ρq_ice / state.ρ,\n        FT(0),\n        state.ρu[3] * state.ρq_ice / state.ρ,\n    )\n    flux.ρq_rai = SVector(\n        state.ρu[1] * state.ρq_rai / state.ρ,\n        FT(0),\n        (state.ρu[3] / state.ρ - rain_w) * state.ρq_rai,\n    )","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"... energy ...","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    flux.ρe = SVector(\n        state.ρu[1] / state.ρ * (state.ρe + aux.p),\n        FT(0),\n        state.ρu[3] / state.ρ * (state.ρe + aux.p),\n    )","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"... and don't advect momentum (kinematic setup)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"end\n\nfunction source!(\n    m::KinematicModel,\n    source::Vars,\n    state::Vars,\n    diffusive::Vars,\n    aux::Vars,\n    t::Real,\n    direction,\n)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"TODO - ensure positive definite","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    FT = eltype(state)\n    _grav::FT = grav(param_set)\n    _e_int_v0::FT = e_int_v0(param_set)\n    _cv_v::FT = cv_v(param_set)\n    _cv_d::FT = cv_d(param_set)\n    _T_0::FT = T_0(param_set)\n\n    e_tot = state.ρe / state.ρ\n    q_tot = state.ρq_tot / state.ρ\n    q_liq = state.ρq_liq / state.ρ\n    q_ice = state.ρq_ice / state.ρ\n    q_rai = state.ρq_rai / state.ρ\n    u = state.ρu[1] / state.ρ\n    w = state.ρu[3] / state.ρ\n    e_int = e_tot - 1 // 2 * (u^2 + w^2) - _grav * aux.z\n\n    q = PhasePartition(q_tot, q_liq, q_ice)\n    T = air_temperature(param_set, e_int, q)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"equilibrium state at current T","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    ts_eq = TemperatureSHumEquil(param_set, T, state.ρ, q_tot)\n    q_eq = PhasePartition(ts_eq)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"zero out the source terms","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    source.ρq_tot = FT(0)\n    source.ρq_liq = FT(0)\n    source.ρq_ice = FT(0)\n    source.ρq_rai = FT(0)\n    source.ρe = FT(0)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"cloud water and ice condensation/evaporation","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    source.ρq_liq += state.ρ * conv_q_vap_to_q_liq(param_set, q_eq, q)\n    source.ρq_ice += state.ρ * conv_q_vap_to_q_ice(param_set, q_eq, q)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"tendencies from rain","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    src_q_rai_acnv = conv_q_liq_to_q_rai_acnv(param_set, q_liq)\n    src_q_rai_accr = conv_q_liq_to_q_rai_accr(param_set, q_liq, q_rai, state.ρ)\n    src_q_rai_evap = conv_q_rai_to_q_vap(param_set, q_rai, q, T, aux.p, state.ρ)\n\n    src_q_rai_tot = src_q_rai_acnv + src_q_rai_accr + src_q_rai_evap\n\n    source.ρq_liq -= state.ρ * (src_q_rai_acnv + src_q_rai_accr)\n    source.ρq_rai += state.ρ * src_q_rai_tot\n    source.ρq_tot -= state.ρ * src_q_rai_tot\n    source.ρe -=\n        state.ρ * src_q_rai_tot * (_e_int_v0 - (_cv_v - _cv_d) * (T - _T_0))\nend\n\nfunction main()","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"Working precision","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    FT = Float64","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"DG polynomial order","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    N = 4","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"Domain resolution and size","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    Δx = FT(20)\n    Δy = FT(1)\n    Δz = FT(20)\n    resolution = (Δx, Δy, Δz)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"Domain extents","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    xmax = 1500\n    ymax = 10\n    zmax = 1500","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"initial configuration","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    wmax = FT(0.6)  # max velocity of the eddy  [m/s]\n    θ_0 = FT(289) # init. theta value (const) [K]\n    p_0 = FT(101500) # surface pressure [Pa]\n    p_1000 = FT(100000) # reference pressure in theta definition [Pa]\n    qt_0 = FT(7.5 * 1e-3) # init. total water specific humidity (const) [kg/kg]\n    z_0 = FT(0) # surface height","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"time stepping","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    t_ini = FT(0)\n    t_end = FT(30 * 60)\n    dt = FT(5)\n    #CFL = FT(1.75)\n    filter_freq = 1\n    output_freq = 72\n\n    driver_config = config_kinematic_eddy(\n        FT,\n        N,\n        resolution,\n        xmax,\n        ymax,\n        zmax,\n        wmax,\n        θ_0,\n        p_0,\n        p_1000,\n        qt_0,\n        z_0,\n    )\n    solver_config = ClimateMachine.SolverConfiguration(\n        t_ini,\n        t_end,\n        driver_config;\n        ode_dt = dt,\n        init_on_cpu = true,\n        #Courant_number = CFL,\n    )\n\n    model = driver_config.bl\n\n    mpicomm = MPI.COMM_WORLD","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"get state variables indices for filtering","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    ρq_liq_ind = varsindex(vars_state_conservative(model, FT), :ρq_liq)\n    ρq_ice_ind = varsindex(vars_state_conservative(model, FT), :ρq_ice)\n    ρq_rai_ind = varsindex(vars_state_conservative(model, FT), :ρq_rai)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"get aux variables indices for testing","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    q_tot_ind = varsindex(vars_state_auxiliary(model, FT), :q_tot)\n    q_vap_ind = varsindex(vars_state_auxiliary(model, FT), :q_vap)\n    q_liq_ind = varsindex(vars_state_auxiliary(model, FT), :q_liq)\n    q_ice_ind = varsindex(vars_state_auxiliary(model, FT), :q_ice)\n    q_rai_ind = varsindex(vars_state_auxiliary(model, FT), :q_rai)\n    S_ind = varsindex(vars_state_auxiliary(model, FT), :S)\n    rain_w_ind = varsindex(vars_state_auxiliary(model, FT), :rain_w)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"filter out negative values","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    cb_tmar_filter =\n        GenericCallbacks.EveryXSimulationSteps(filter_freq) do (init = false)\n            Filters.apply!(\n                solver_config.Q,\n                (ρq_liq_ind[1], ρq_ice_ind[1], ρq_rai_ind[1]),\n                solver_config.dg.grid,\n                TMARFilter(),\n            )\n            nothing\n        end","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"output for paraview","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"initialize base output prefix directory from rank 0","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    vtkdir = abspath(joinpath(ClimateMachine.Settings.output_dir, \"vtk\"))\n    if MPI.Comm_rank(mpicomm) == 0\n        mkpath(vtkdir)\n    end\n    MPI.Barrier(mpicomm)\n\n    step = [0]\n    cb_vtk =\n        GenericCallbacks.EveryXSimulationSteps(output_freq) do (init = false)\n            out_dirname = @sprintf(\n                \"new_ex_2_mpirank%04d_step%04d\",\n                MPI.Comm_rank(mpicomm),\n                step[1]\n            )\n            out_path_prefix = joinpath(vtkdir, out_dirname)\n            @info \"doing VTK output\" out_path_prefix\n            writevtk(\n                out_path_prefix,\n                solver_config.Q,\n                solver_config.dg,\n                flattenednames(vars_state_conservative(model, FT)),\n                solver_config.dg.state_auxiliary,\n                flattenednames(vars_state_auxiliary(model, FT)),\n            )\n            step[1] += 1\n            nothing\n        end","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"call solve! function for time-integrator","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    result = ClimateMachine.invoke!(\n        solver_config;\n        user_callbacks = (cb_tmar_filter, cb_vtk),\n        check_euclidean_distance = true,\n    )","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"supersaturation in the model","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    max_S = maximum(abs.(solver_config.dg.state_auxiliary[:, S_ind, :]))\n    @test max_S < FT(0.25)\n    @test max_S > FT(0)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"qt < reference number","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    max_q_tot = maximum(abs.(solver_config.dg.state_auxiliary[:, q_tot_ind, :]))\n    @test max_q_tot < FT(0.0077)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"no ice","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    max_q_ice = maximum(abs.(solver_config.dg.state_auxiliary[:, q_ice_ind, :]))\n    @test isequal(max_q_ice, FT(0))","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"q_liq ∈ reference range","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    max_q_liq = max(solver_config.dg.state_auxiliary[:, q_liq_ind, :]...)\n    min_q_liq = min(solver_config.dg.state_auxiliary[:, q_liq_ind, :]...)\n    @test max_q_liq < FT(1e-3)\n    @test abs(min_q_liq) < FT(1e-5)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"q_rai ∈ reference range","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    max_q_rai = max(solver_config.dg.state_auxiliary[:, q_rai_ind, :]...)\n    min_q_rai = min(solver_config.dg.state_auxiliary[:, q_rai_ind, :]...)\n    @test max_q_rai < FT(3e-5)\n    @test abs(min_q_rai) < FT(3e-8)","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"terminal velocity ∈ reference range","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"    max_rain_w = max(solver_config.dg.state_auxiliary[:, rain_w_ind, :]...)\n    min_rain_w = min(solver_config.dg.state_auxiliary[:, rain_w_ind, :]...)\n    @test max_rain_w < FT(4)\n    @test isequal(min_rain_w, FT(0))\nend\n\nmain()","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"","category":"page"},{"location":"generated/Microphysics/ex_2_Kessler/#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"newcommandparamT1       text1\nnewcommandhyperparamT1text1\nnewcommandsimparamT1  text1\n\nnewcommandexp1mathrmexpleft(1right)\nnewcommandatan1mathrmatanleft(1right)\nnewcommandsign1mathrmsignleft(1right)\nnewcommanderf1mathrmerfleft(1right)\nnewcommanderfinv1mathrmerfinvleft(1right)\n\nnewcommandparam1     1\nnewcommandhyperparam11\nnewcommandsimparam1  1\n\nnewcommandCROSStimes\nnewcommandGRADnabla\nnewcommandDOTbullet\nnewcommandPDpartial\nnewcommandPDFzfracPDPD z\nnewcommandDM1langle 1 rangle\nnewcommandiEnve\nnewcommandSD2overline1_2\nnewcommandSDi1SD1i\nnewcommandSDj1SD1j\nnewcommandSDe1SD1iEnv\nnewcommandSDiog21_2\nnewcommandSDio1SDiog1i\nnewcommandSDjo1SDiog1j\nnewcommandSDeo1SDiog1iEnv\nnewcommandaSD21_2\nnewcommandaSDi1aSD1i\nnewcommandaSDj1aSD1j\nnewcommandaSDe1aSD1iEnv\nnewcommandotherDefswhere additional variable definitions are in\n\nnewcommandIntraCVSDi2overline1_i      2_i      \nnewcommandIntraCVSDj2overline1_j      2_j      \nnewcommandIntraCVSDe2overline1_iEnv2_iEnv\n\nnewcommandInterCVSDi2overline1_i      overline2_i      \nnewcommandInterCVSDj2overline1_j      overline2_j      \nnewcommandInterCVSDe2overline1_iEnvoverline2_iEnv\n\nnewcommandTCV2langle 1^*2^* rangle\n\nnewcommandBC11_z_min\nnewcommandBCT11_z_max\nnewcommandBCB11_z_min\nnewcommandBCG11_z_boundary\n\nnewcommandKmK^m\nnewcommandKhK^h\nnewcommandTEquilibT_mathrmiterated\nnewcommandPhasePartitionq\nnewcommandExnerDPi_dry\nnewcommandExnerMPi_moist\nnewcommandWindSpeedu\nnewcommandLayerThicknessparamDelta z\nnewcommandSurfaceRoughness1paramz_01\nnewcommandSensibleSurfaceHeatFluxF_mathrmsensible\nnewcommandLatentSurfaceHeatFluxF_mathrmlatent\nnewcommandFrictionVelocityu_*\nnewcommandBuoyancyb\nnewcommandBuoyancyGradPD_z Buoyancy\nnewcommandBuoyancyFluxIntraCVSDiwb\nnewcommandTemperatureScaletheta_*\nnewcommandSurfaceMomentumFluxBCoverlinewu\nnewcommandSurfaceHeatFluxBCoverlinewtheta\nnewcommandSurfaceBuoyancyFluxBCIntraCVSDiwtheta\nnewcommandConvectiveVelocityw_*  Convective velocity near the surface\nnewcommandInversionHeightz_*\nnewcommandMOLenLambda_M-O\nnewcommandzLLparamz_  z at the first surface level (we should make this grid-independent)\n\nnewcommandqtq_mathrmtot\nnewcommandqrq_mathrmrain\nnewcommandqlq_mathrmliq\nnewcommandqiq_mathrmice\nnewcommandqvq_mathrmvap\nnewcommandqvsatq_mathrmvap^*\nnewcommandpvsatp_mathrmvap^*\nnewcommandqcq_mathrmcon\nnewcommandThetaVaptheta_mathrmvap\nnewcommandThetaVirttheta_mathrmvirt\nnewcommandThetaRhotheta_rho\nnewcommandThetaLiqtheta_mathrmliq\nnewcommandThetaLiqIcetheta_mathrmliq-ice\nnewcommandThetaLiqIceSattheta^*_mathrmliq-ice\nnewcommandThetaDrytheta_mathrmdry\nnewcommandTDryT_dry\nnewcommandeinte_mathrmint\nnewcommandetote_mathrmtot\n\nnewcommandTRefT_0\nnewcommandalphaRefalpha_0\nnewcommandrhoRefrho_0\nnewcommandpRefp_0\nnewcommandHeavisidemathcal H\n\nnewcommandalphaLLalphaRef_zLL\nnewcommanduHsimparammathbfu_h\n\nnewcommandCoriolisParamhyperparammathrmcoriolis_param\nnewcommandSubsidenceParamhyperparammathrmsubsidence\nnewcommandbetaMhyperparambeta_m\nnewcommandbetaHhyperparambeta_h\nnewcommandgammaMhyperparamgamma_m\nnewcommandgammaHhyperparamgamma_h\n\nnewcommandPTildeparamtildep\nnewcommandVKConstparamkappa_mathrmVon-Karman\nnewcommandNsdhyperparamN_sd\nnewcommandgravparamg\nnewcommandTZeroparamT_0\nnewcommandRefHintVparameint_v0\nnewcommandRefHintIparameint_i0\n\nnewcommandEpsDVparamvarepsilon_dv\nnewcommandEpsVDparamvarepsilon_vd\nnewcommandRmR_m\nnewcommandCpmc_pm\nnewcommandCvmc_vm\nnewcommandRdparamR_d\nnewcommandRvparamR_v\nnewcommandCp1paramc_p1\nnewcommandCv1paramc_v1\nnewcommandCvdCvd\nnewcommandCvvCvv\nnewcommandCvlCvl\nnewcommandCviCvi\n\nnewcommandDeltaCpparamDelta c_p\nnewcommandTTripleparamT_mathrmtr\nnewcommandPTripleparamp_mathrmtr\nnewcommandTFreezeparamT_mathrmfreeze\n\nnewcommandRefLHvparamL_v0\nnewcommandRefLHsparamL_s0\nnewcommandRefLHfparamL_f0\nnewcommandLatentHeatV1L_vap(1)\nnewcommandLatentHeatS1L_sub(1)\nnewcommandLatentHeatF1L_fus(1)","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Eddy-Diffusivity-Mass-Flux-(EDMF)-equations-1","page":"EDMF equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"This document is concerned with defining the set of equations solved in the atmospheric turbulence convection model: the EDMF equations. Color-coding is used to indicate:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"paramTConstant parameters that are fixed in space and time (eg those defined in CLIMAParametersjl)\nsimparamTSingle column (SC) inputs (eg variables that are fed into the SC model from the dynamical core (eg horizontal velocity))\nhyperparamTTunable hyper-parameters that will need to be changeable but will only include single numbers (eg Float64)","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Domain-decomposition-1","page":"EDMF equations","title":"Domain decomposition","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"While our model is 1D along z and there is no spatial discretization in the horizontal directions (x and y), the horizontal space is broken into Nsd (sim 5-10) \"bins\", or \"subdomains\" (SDs), denoted by subscript i, where 1 le i le Nsd. One of the subdomains, the \"environment\", is treated different compared to others, termed \"updrafts\". This environment subdomain is denoted with a special index iEnv (which we usually set to 1). For dummy variables phi and psi, we use several domain and SD representations of interest:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\n  SDiphi                                                                                   quad  texthorizontal mean of variable phi over SD i \n  SDiphi = phi_i - SDiphi                                                            quad  textfluctuations of phi about the SD mean \n  IntraCVSDiphipsi                                                                      quad  textintra subdomain covariance \n  DMphi = sum_i aSDia SDiphi                                                       quad  texthorizontal mean of phi over the total domain \n  SDiphi^* = SDiphi - DMphi                                                        quad  textdifference between SD  domain means \n  InterCVSDiphipsi                                                                      quad  textinter subdomain covariance among SD means \n  phi^* = phi - DMphi                                                                    quad  textdifference between SD  domain means \n  TCVphipsi = sum_forall i a_i IntraCVSDiphipsi +\n  sum_forall i sum_forall j  aSDia aSDja SDiphi(SDipsi - SDjpsi)     quad  texttotal covariance\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Here, SDiphi and SDipsi are a dummy variables for the following 7 unknowns:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\n  SDiw                    quad textvertical velocity \n  SDieint                quad textinternal energy  \n  SDiqt                  quad texttotal water specific humidity  \n  SDiTKE                  quad textturbulent kinetic energy (05(IntraCVSDiuu+IntraCVSDivv+IntraCVSDiww))  \n  IntraCVSDieinteint  quad textintra subdomain covariance of eint and eint  \n  IntraCVSDiqtqt      quad textintra subdomain covariance of qt and qt \n  IntraCVSDieintqt    quad textintra subdomain covariance of eint and qt\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"From the large-scale model perspective, DMphi represents the resolved grid-scale (GS) mean, and TCVphipsi represents the SGS fluxes and (co)-variances of scalars that need to be parameterized. Equations in the following sections, \\eqref{eq:AreaFracGov}, \\eqref{eq:1stMoment} and \\eqref{eq:2ndMoment}, are solved on z_min le z le z_max and t ge 0. There are 8 Nsd equations in total.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Domain-averaged-equations-1","page":"EDMF equations","title":"Domain averaged equations","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"The EDMF model can be used in the context of a stand-alone single column, or integrated with a dynamical core. Either way, the EDMF model relies on domain-averaged variables, which may be prescribed or solved for. Taking an area fraction-weighted average of the SD equations yields the domain-averaged equations (which should be consistent with variables in the dynamical core).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"The domain-averaged equations for DMphi in w qt eint uH are:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nPD_t (rhoRef DMphi)\n+ PD_z (rhoRef DMw DMphi)\n+ nabla_h DOT left( rhoRef DMphi otimes DMphi right)\n= \n  DMS_textdiff^DMphi\n+ DMS_textpress\n+ DMS_textcoriolis\n+ DMS_textsubsidence\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nDMS_textdiff^DMphi  = PD_z (rhoRef aSDea SDeKm PD_z DMphi)   labeleqgm_diffusion \nDMS_textdiff^w          = PD_z (rhoRef aSDea SDeKm PD_z DMw)      labeleqgm_diffusion_w \nDMS_textpress             = - GRAD_h DMp                                       labeleqgm_pressure \nDMS_textcoriolis          = CoriolisParam DMphi CROSS mathbfk             labeleqgm_coriolis \nDMS_textsubsidence        = - SubsidenceParam GRAD phi                          labeleqgm_subsidence \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Sub-domain-equations:-Area-fraction-1","page":"EDMF equations","title":"Sub-domain equations: Area fraction","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"The EDMF equations take the form of advection-diffusion equations. The size of these SDs are tracked by solving an equation governing the area fraction in the ith SD (aSDia), given by:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"begingather\n  PD_t (rhoRef aSDia)\n  + PD_z (rhoRef aSDia SDiw)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH)\n  =\n  SDiS^a\n   quad i ne iEnv labeleqAreaFracGov \n  aSDia = 1 - sum_jneiEnv aSDja quad i = iEnv labeleqAreaFracConserve \n  qquad 0  aSDia  1 labeleqAreaFracConstraint\nendgather","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Here, rhoRef SDiw uH is fluid density, mean vertical velocity along z, and domain-mean of the horizontal velocity respectively. The area fraction constraints are necessary to ensure the system of equations is well-posed. All source terms (SDiS^a) will be discussed in later sections.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"note: Note\nThe greater than zero constraint must be satisfied at every step of the solution process, since it is necessary to avoid division by zero in the mean field equations.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS^a = SDiS_epsilondelta^a\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Source-term-definitions-1","page":"EDMF equations","title":"Source term definitions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"We note that the net exchange is zero sum_i SDiS_epsilondelta^a = 0. Therefore, we may define the environment source term as the negative sum of all updraft source terms. The entrainment-detrainment source is:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS_epsilondelta^a =\nbegincases\n  rho a_i SDiw left( -delta_i + epsilon_i right)  i ne iEnv \n  0 - sum_j ne iEnv SDjS_epsilondelta^a  i = iEnv \nendcases\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_i) and (delta_i).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Sub-domain-equations:-1st-moment-1","page":"EDMF equations","title":"Sub-domain equations: 1st moment","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"The 1st moment sub-domain equations are:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleq1stMoment\n  PD_t (rhoRef aSDia SDiphi)\n  + PD_z (rhoRef aSDia SDiw SDiphi)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH SDiphi)\n  =\n  SDiS^phi\n   quad forall i \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Here, SDiS^phi are source terms, including diffusion, and many other sub-grid-scale (SGS) physics. In general, SDiS^phi and SDiS^a may depend on SDjphi and or aSDja for any j.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Source-terms-per-equation-1","page":"EDMF equations","title":"Source terms per equation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"The source terms common to all unknowns are:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS^phi =\n  SDiS_epsilondelta^phi\n+ SDiS_textturb-transp^phi quad forall phi\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Additional source terms exist in other equations:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS^w =\n  SDiS_epsilondelta^w\n+ SDiS_textturb-transp^w\n+ SDiS_textbuoy\n+ SDiS_textnh-press\n+ SDiS_textcoriolis \nSDiS^eint =\n  SDiS_epsilondelta^eint\n+ SDiS_textturb-transp^eint\n+ SDiS_textMP-MSS^eint\n+ SDiS_textrad \nSDiS^qt =\n  SDiS_epsilondelta^qt\n+ SDiS_textturb-transp^qt\n+ SDiS_textMP-MSS^qt\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Source-term-definitions-2","page":"EDMF equations","title":"Source term definitions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Note: The sum of the total pressure and gravity are recast into the sum of the non-hydrostatic pressure and buoyancy sources.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS_epsilondelta^phi =\nbegincases\n  rhoRef a_i SDiw left( -delta_i SDiphi + epsilon_i SDephi right)  i ne iEnv \n  0 - sum_j ne iEnv SDjS_epsilondelta^phi  i=iEnv \nendcases \nSDiS_textturb-transp^phi  =  -PD_z (rhoRef a_i IntraCVSDiwphi) \n  = PD_z (rhoRef a_i SDiKm PD_z SDiphi) \nSDiS_textnh-press = -rhoRef aSDia left( alpha_b SDib  + alpha_d frac(SDiw - SDew)  SDiw - SDew  r_d aSDia^12 right) \nalpha_b = 13 quad alpha_d = 0375 quad r_d      = 500 m \nSDiS_textbuoy = rhoRef aSDia SDib \nSDiS_textcoriolis  = f(SDimathbfu - SDimathbfu_textgeo-wind) \nSDiS_textrad  = left( PD_t SDieint right)_radiation \nSDiS_textMP-MSS^qt  = \nSDiS_textMP-MSS^eint  = \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_i) and (delta_i).\nBuoyancy (Buoyancy).\nEddy diffusivity (Km Kh).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Sub-domain-equations:-2nd-moment-1","page":"EDMF equations","title":"Sub-domain equations: 2nd moment","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"The 2nd moment sub-domain equations are of the exact same form as the 1st moment equations (equation \\eqref{eq:1stMoment}):","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleq2ndMoment\n  PD_t (rhoRef aSDia SDiphi)\n  + PD_z (rhoRef aSDia SDiw SDiphi)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH SDiphi)\n  =\n  SDiS^phi\n   quad forall i \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Here, SDiS^phi are source terms, including diffusion, and many other sub-grid-scale (SGS) physics. In general, SDiS^phi and SDiS^a may depend on SDjphi and or aSDja for any j.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Source-terms-per-equation-2","page":"EDMF equations","title":"Source terms per equation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"The source terms common to all unknowns are:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS^phipsi =\n  SDiS_epsilondelta^phipsi\n+ SDiS_textx-grad flux^phipsi\n+ SDiS_textturb-transp^phipsi\nquad forall phi psi\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Additional source terms exist in other equations:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS^TKE =\n  SDiS_epsilondelta^TKE\n+ SDiS_textx-grad flux^TKE\n+ SDiS_textturb-transp^TKE\n+ SDiS_textdissip\n+ SDiS_textpress\n+ SDiS_textbuoyancy \nSDiS^phipsi =\n  SDiS_epsilondelta^phipsi\n+ SDiS_textx-grad flux^phipsi\n+ SDiS_textturb-transp^phipsi\n+ SDiS_textdissip^phipsi\n+ SDiS_textMP-MSS^phipsi\nquad phipsi in qtqt einteint eint qt\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Source-term-definitions-3","page":"EDMF equations","title":"Source term definitions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nSDiS_epsilondelta^phipsi =\nbegincases\n  rhoRef a_i SDiw left -delta_i IntraCVSDiphipsi + epsilon_i\nleft(\nIntraCVSDephipsi + (SDephi - SDiphi)(SDepsi - SDipsi)\nright) right  i ne iEnv \n  0 - sum_jne iEnv SDjS_epsilondelta^phipsi  i=iEnv \nendcases \nSDiS_epsilondelta^TKE =\nbegincases\n  rhoRef a_i SDiw left -delta_i SDiTKE + epsilon_i\nleft(\nSDeTKE + frac12 (SDew - SDiw)^2\nright) right  i ne iEnv \n  0 - sum_jne iEnv SDjS_epsilondelta^TKE  i=iEnv \nendcases \nSDiS_textx-grad flux^phipsi\n =\n- rhoRef a_i IntraCVSDiwpsi PD_z SDiphi\n- rhoRef a_i IntraCVSDiwphi PD_z SDipsi \n =\n 2 rhoRef a_i SDiKh PD_z SDipsi PD_z SDiphi \nSDiS_textx-grad flux^TKE\n =\nrhoRef a_i SDiKm left left(PD_zDMuright)^2 + left(PD_zDMvright)^2 + left(PD_zDMwright)^2 right \nSDiS_textturb-transp^phipsi  = - PD_z (rhoRef a_i overlinew_iphi_ipsi_i) \n = PD_z (rhoRef a_i SDiKh PD_z IntraCVSDiphipsi) \nSDiS_textturb-transp^TKE  = PD_z (rhoRef a_i SDiKm PD_z SDiTKE) \nSDiS_textdissip\n = - rhoRef a_i c_e IntraCVSDiphipsi fracSDiTKE^12SDiol_mix quad textEquation 38 in Tan et al \nc_e  = 2 \nSDiS_textpress\n = - aSDia left IntraCVSDiu(partial_x p^dagger) +\n                      IntraCVSDiv(partial_y p^dagger) +\n                      IntraCVSDiw(partial_z p^dagger)right  \n = 0 qquad textfor now need to derive correct formulation \nSDiS_textbuoyancy^TKE  = rhoRef aSDia BuoyancyFlux \nSDiS_textMP-MSSP^qtqt\n = \nSDiS_textMP-MSSP^einteint\n = \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_i) and (delta_i).\nEddy diffusivity (Km Kh).\nMixing length (l_mix).\nBuoyancy flux (BuoyancyFlux).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#EDMF-variable-definitions-1","page":"EDMF equations","title":"EDMF variable definitions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"The following definitions are ordered in a dependency fashion; all variables are defined from variables already defined in previous subsections.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Constants-1","page":"EDMF equations","title":"Constants","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nc_K  = 01 \ntexttol_InversionHeightmathrm-stable  = 001 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Phase-partition-1","page":"EDMF equations","title":"Phase partition","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nPhasePartition = qv ql qi \nqv = qt - ql - qi \npvsat(T) = PTriple left( fracTTTriple right)^fracDeltaCpRv expfracRefLHv - DeltaCp TZeroRv left( frac1TTriple - frac1T right) labeleqpvsat \nqvsat(T rho) = fracpvsat(T)rho Rv T                                                                                                                            labeleqqvsat \nqc = max(qt - qvsat 0)                                                                                                                                               labeleqqc \nql = lambda qc                                                                                                                                                         labeleqql \nqi = (1-lambda) qc                                                                                                                                                     labeleqqi \nlambda(T) = Heaviside(T-TFreeze)                                                                                                                                       labeleqlambda \nHeaviside = textHeaviside function \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Functionally,","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nPhasePartition  = PhasePartition(qt T rho) \nqvsat  = qvsat(T rho) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Gas-constants-1","page":"EDMF equations","title":"Gas constants","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nEpsDV  = fracRvRd approx 161 \nEpsVD  = fracRdRv approx 062 \nRm  = Rd left1 + (EpsDV-1) qt - EpsDV (ql+qi) right \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Specific-heats-1","page":"EDMF equations","title":"Specific heats","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nCvm = (1 - SDiqt) Cvd + SDiqv Cvv + SDiql Cvl + SDiqi Cvi \nCpm = (1 - SDiqt) Cpd + SDiqt Cpv \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Latent-heat-1","page":"EDMF equations","title":"Latent heat","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nLatentHeatVT = RefLHv + (Cpv - Cpl) (T - TTriple) \nLatentHeatST = RefLHs + (Cpv - Cpi) (T - TTriple) \nLatentHeatFT = RefLHf + (Cpl - Cpi) (T - TTriple) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Exner-functions-1","page":"EDMF equations","title":"Exner functions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nExnerD(pRef)    = left(fracpRefPTilde right)^RdCpd \nExnerM(pRef PhasePartition) = left(fracpRefPTilde right)^RmCpm \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Specific heats Cpm and Cvm.\nGas constants (Rm).\nPhase partition PhasePartition qt qv ql qi qvsat.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Temperature-1","page":"EDMF equations","title":"Temperature","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Note that, while temperature may be computed using different thermodynamic formulations, ThermodynamicState's are immediately converted to the (qt eint rhoRef)-formulation.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Dry-temperature-1","page":"EDMF equations","title":"Dry temperature","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nTDry  = ThetaLiqIce ExnerD \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Exner functions ExnerD and ExnerM.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Functionally,","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nTDry  = TDry(ThetaLiqIce pRef) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#(\\qt,-\\eint,-\\rhoRef{})-formulation-1","page":"EDMF equations","title":"(qt eint rhoRef)-formulation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Here, T conditionally satisfies the non-linear set of equations, which can be solved using a standard root solver (e.g., Secant method):","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nT =\nbegincases\nmathrmsatisfies  eint(T) = Cvm (T - TZero)  + qv RefHintV - qi RefHintI  qt  qvsat(T rhoRef) \n TZero + fraceint(T)(1-qt)Cvd + qt Cvv + qt RefHintV  textotherwise \nendcases\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Phase partition PhasePartition qt qv ql qi qvsat.\nSpecific heats Cpm and Cvm.\nReference state profiles (pRef, rhoRef, and alphaRef).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Functionally,","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nT  = T(qt eint rhoRef) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#(\\qt,-\\ThetaLiqIce,-\\rhoRef,-\\pRef)-formulation-1","page":"EDMF equations","title":"(qt ThetaLiqIce rhoRef pRef)-formulation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Here, T conditionally satisfies the non-linear set of equations, which can be solved using a standard root solver (e.g., Secant method):","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nT =\nbegincases\nmathrmsatisfies  ThetaLiqIce ExnerM = T left(1 - frac RefLHv ql + RefLHs qiCpm T right)  qt  qvsat(T rhoRef) \n TDry  textotherwise \nendcases\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Dry temperature TDry.\nPhase partition PhasePartition qt qv ql qi qvsat.\nSpecific heats Cpm and Cvm.\nExner functions ExnerD and ExnerM.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Functionally,","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nT  = T(qt ThetaLiqIce rhoRef pRef) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Reference-state-profiles-1","page":"EDMF equations","title":"Reference state profiles","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Using the hydrostatic balance, PD_z pRef = - rhoRef grav, and the ideal gas law, pRef = rhoRef Rm TRef, the reference state profiles are computed as:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nPD_z pRef  = - grav fracpRefTRef Rm \nint_BCpRef^pRef fracTDry(BCDMThetaLiqIce pRef)pRef PD pRef  = - fracgravBCDMRm int_z_min^z PD z \nrhoRef(pRef)  = fracpRefTDry(BCDMThetaLiqIce pRef) BCDMRm \nalphaRef  = frac1rhoRef(pRef) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Temperature (T and TDry).\nGas constants (Rm).\nSpecific heats Cpm and Cvm.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Mixing-ratios-1","page":"EDMF equations","title":"Mixing ratios","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqMixingRatios\nr_con  = fracqt+ql1 - qt \nr_vap  = fracqt-ql    - qi1 - qt \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Potential-temperatures-1","page":"EDMF equations","title":"Potential temperatures","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Fix: which virtual potential temperature is used","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqTheta\nThetaDry     = TExnerD \nThetaLiqIce  = ThetaDry (1 - (RefLHv ql + RefLHs qi)(Cpm T)) \nThetaVirt    = ThetaDry (1 - r_con + 061 r_vap) \nThetaVirt    = theta left(1 + 061 qr - ql right) \nThetaRho     = T RmExnerD \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nExner functions (ExnerM).\nMixing ratios (r_con, r_vap).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Shear-production-1","page":"EDMF equations","title":"Shear production","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqShearProduction\nS^2 = (PD_z DMu)^2 + (PD_z DMv)^2 + (PD_z SDew)^2 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Buoyancy-1","page":"EDMF equations","title":"Buoyancy","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqBuoyancy\nSDib^dagger  = grav (SDialpha - alphaRef)alphaRef \nSDib  = SDib^dagger - sum_j a_j SDjb^dagger \nalpha_i  = fracSDiRm SDiTpRef \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nPhase partition PhasePartition qt qv ql qi qvsat.\nTemperature (T and TDry).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Buoyancy-gradient-1","page":"EDMF equations","title":"Buoyancy gradient","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#(\\qt,-\\ThetaLiqIce,-\\pRef,-\\rhoRef)-formulation-1","page":"EDMF equations","title":"(qt ThetaLiqIce pRef rhoRef)-formulation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqBuoyancyGradLong\nSDiBuoyancyGrad  = PD_z SDiThetaLiqIce\nleft (1-f_c) PD_ThetaLiqIce b _d  + f_c PD_ThetaLiqIce b _s right +\nPD_z SDiqt      left (1-f_c) PD_qt b _d + f_c PD_qt b _s right \nf_c = 0 qquad textgood for simple cases need to confirm for more complex cases \nPD_ThetaLiqIce b _d  = fracgravDMThetaVirt left 1 + left( fracRvRd - 1 right) SDiqt right \nPD_ThetaLiqIce b _s = fracgravDMThetaVirt left 1 + fracRvRd left(1 + fracLatentHeatVSDiTRv SDiT right) SDiqvsat - SDiqt right left( 1 + fracLatentHeatVSDiT^2Cpm Rv SDiT^2 SDiqvsat right)^-1 \nPD_qt b _d = fracgravDMThetaVirt left( fracRvRd - 1 right) SDiThetaDry \nPD_qt b _s = left( fracLatentHeatVSDiTCpm SDiT PD_ThetaLiqIce b _s - fracgravDMThetaVirt right) SDiThetaDry \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nPotential temperatures (ThetaDry, ThetaVirt).\nPhase partition PhasePartition qt qv ql qi qvsat.\nLatent heat (LatentHeatVT).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#(\\qt,-\\eint,-\\rhoRef{})-formulation-2","page":"EDMF equations","title":"(qt eint rhoRef)-formulation","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Pending.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Surface-fluxes-1","page":"EDMF equations","title":"Surface fluxes","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"todo: Todo\nAdd definitions for universal functions (e.g., Psi_m).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Variables in this section must be computed simultaneously because it requires the solution of a non-linear equation.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Monin-Obhukov-length-1","page":"EDMF equations","title":"Monin-Obhukov length","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqMOLen\nMOLen = begincases\n- fracFrictionVelocity^3 thetaVKConst grav SurfaceHeatFlux  SurfaceHeatFlux  0 \n0  textotherwise \nendcases \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Friction-velocity-1","page":"EDMF equations","title":"Friction velocity","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Knowns: u_mathrmave = sqrtDMu^2+DMv^2 LayerThickness SurfaceRoughnessm\nUnknowns: FrictionVelocity MOLen, and SurfaceMomentumFlux","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqFrictionVelocity\nu_mathrmave      = fracFrictionVelocityVKConst    left logleft(fracLayerThicknessSurfaceRoughnessmright) - Psi_mleft(fracLayerThicknessMOLenright) + fracSurfaceRoughnessmLayerThickness Psi_mleft(fracSurfaceRoughnessmMOLenright) + R_z0m left psi_mleft(fracSurfaceRoughnessmMOLenright) - 1 right right \nR_z0m               = 1 - SurfaceRoughnesshLayerThickness \nSurfaceMomentumFlux  = -FrictionVelocity^2                 labeleqSurfaceMomentumFlux  \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where Psi_m is defined in Appendix A, equations A6 in Nishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin‐Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Temperature-scale-1","page":"EDMF equations","title":"Temperature scale","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Knowns: theta_mathrmave theta_s LayerThickness SurfaceRoughnessh\nUnknowns: FrictionVelocity MOLen, and SurfaceHeatFlux","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqTemperatureScale\ntheta_mathrmave - theta_s  = fracPr TemperatureScaleVKConst left logleft(fracLayerThicknessSurfaceRoughnesshright) - Psi_hleft(fracLayerThicknessMOLenright) + fracSurfaceRoughnesshLayerThickness Psi_mleft(fracSurfaceRoughnesshMOLenright) + R_z0h left psi_hleft(fracSurfaceRoughnesshMOLenright) - 1 right right \nR_z0h                           = 1 - SurfaceRoughnesshLayerThickness \nSurfaceHeatFlux                  = -FrictionVelocityTemperatureScale  labeleqSurfaceHeatFlux  \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where Psi_h is defined in Appendix A, equation A6 in Nishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin‐Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Prandtl-number-1","page":"EDMF equations","title":"Prandtl number","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqPrandtlNumber\nPr_neut = 074 \nPr(z) = begincases\n    Pr_neut  MOLen  0 \n    Pr_neut left frac1 + omega_2 R_g - sqrt-4 R_g + (1+omega_2 R_g)^22 R_g right  textotherwise \nendcases \nomega_2 = omega_1+1 \nomega_1 = frac4013 \nR_g = fracBuoyancyGradS^2 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Shear production (S).\nMonin-Obhukov length (MOLen).\nBuoyancy gradient (BuoyancyGrad).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Mixing-length-1","page":"EDMF equations","title":"Mixing length","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"note: Note\nThese mixing length have been tested for the environment, not the updrafts","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqMixingLength\nSDiol_mix^m = fracsum_j l_j e^-l_jsum_j e^-l_j qquad j = 123 \nl_1 = fracsqrtc_wSDeTKESDeN \nc_w = 04 \nSDeN = fracgrav PD_z SDeThetaVirtSDeThetaVirt  qquad text(buoyancy frequency of environment) \nl_2 = fracVKConst zc_K kappa^* phi_m(zMOLen) \nphi_m(xi) = left( 1 + a_l xi right)^-b_l \n(a_l b_l) =\nbegincases\n  (-100 02)  MOLen  0 \n  (27 -1)  textotherwise \nendcases \nkappa^* = fracFrictionVelocitysqrtSDeTKE \nl_3 = sqrtfracc_varepsilonc_K sqrtSDeTKE\nleft max(S^2 - frac1Pr(z) BuoyancyGrad 0) right^-12 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Constants.\nShear production (S).\nMonin-Obhukov length (MOLen).\nFriction velocity (FrictionVelocity).\nBuoyancy gradient (BuoyancyGrad).\nPotential temperatures (ThetaDry, ThetaVirt).\nPrandtl number (Pr).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Smoothing function is provided in python file. The Prandtl number was used from Eq. 75 in Dan Li 2019 \"Turbulent Prandtl number in the atmospheric BL - where are we now\".","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Eddy-diffusivity-1","page":"EDMF equations","title":"Eddy diffusivity","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqEddyDiffusivity\nSDiKm  = begincases\nc_K SDiol_mix sqrtSDiTKE  i = iEnv \n0  textotherwise\nendcases \nSDiKh  = fracSDiKmPr \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Constants.\nMixing length (l_mix).\nPrandtl number (Pr).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Buoyancy-flux-1","page":"EDMF equations","title":"Buoyancy flux","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"todo: Todo\nCurrently, BuoyancyFlux is hard-coded from the first expression (which was used in SCAMPy), however, this value should be computed from the SurfaceFluxes section.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqBuoyancyFlux\nSurfaceBuoyancyFlux  = fracgrav BCalphaRefCpm BCSDiT (SensibleSurfaceHeatFlux + (EpsDV - 1) Cpm BCSDiT LatentSurfaceHeatFlux  LatentHeatVBCSDiT) \nBuoyancyFlux  = - SDiKh SDiBuoyancyGrad \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Eddy diffusivity (Km Kh).\nLatent heat (LatentHeatVT).\nBuoyancy gradient (BuoyancyGrad).\nSpecific heats Cpm and Cvm.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Entrainment-Detrainment-1","page":"EDMF equations","title":"Entrainment-Detrainment","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Entrainment (epsilon_i)","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqEntrainment\nepsilon_i = c_epsilon fracmax(SDib 0)SDiw^2 \nc_epsilon = 012 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Detrainment (delta_j):","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqDetrainment\ndelta_i = c_delta fracmin(SDib 0)SDiw^2 + delta_B Heaviside(SDiql) \nc_delta = c_delta0 + Gamma(aSDia) \nGamma(aSDia) = 0 \nc_delta0 = c_epsilon = 012 \ndelta_B = 0004 m^-1 \nHeaviside = textHeaviside function \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nTemperature (T and TDry).\nBuoyancy (Buoyancy).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Inversion-height-1","page":"EDMF equations","title":"Inversion height","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqInversionHeight\nSDioInversionHeight =\nbegincases\n  left (PD_z ThetaRho)^-1 (BCThetaRho - ThetaRho_z_1) + z_1 right  simparamBCDMu^2 + simparamBCDMv^2 = texttol_InversionHeightmathrm-stable \n  left (PD_z Ri_bulk)^-1 (hyperparamRi_bulk crit - Ri_bulk_z_2) + z_2 right  textotherwise \nendcases \nz_1 = min_z (ThetaRho(z)  BCThetaRho) \nz_2 = min_z (Ri_bulk(z)  hyperparamRi_bulk crit) \nRi_bulk = grav z frac(ThetaRhoBCThetaRho - 1)simparamDMu^2 + simparamDMv^2 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Potential temperatures (theta).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Convective-velocity-1","page":"EDMF equations","title":"Convective velocity","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqConvectiveVelocity\nSDioConvectiveVelocity = (max(BuoyancyFlux SDioInversionHeight 0))^13 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Inversion height (SDioInversionHeight).\nBuoyancy flux (BuoyancyFlux).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Non-local-mixing-length-1","page":"EDMF equations","title":"Non-local mixing length","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalignlabeleqMixingLengthOld\nSDiol_mix = (l_A^-1 + l_B^-1)^-1 \nl_A = VKConst z left( 1 + a_l fraczMOLen right)^b_l \nSDiol_B = SDiotau SDiTKE \n(a_l b_l) =\nbegincases\n  (-100 02)  MOLen  0 \n  (27 -1)  textotherwise \nendcases \nSDiotau = SDioInversionHeightSDioConvectiveVelocity \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Inversion height (SDioInversionHeight).\nMonin-Obhukov length (MOLen).\nConvective velocity (SDioConvectiveVelocity).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Boundary-Conditions-1","page":"EDMF equations","title":"Boundary Conditions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Here, we specify boundary conditions (BCs) by their type, Dirichlet (D) or Neumann (N), and their value.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#BC-functions-1","page":"EDMF equations","title":"BC functions","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nGamma_phi(F_1 F_2)\n = begincases\n    4 fracF_1 F_2FrictionVelocity^2 (1 - 83zLLMOLen)^-23  MOLen  0 \n    4 fracF_1 F_2FrictionVelocity^2  textotherwise\nendcases \nGamma_TKE\n = begincases\n    375 FrictionVelocity^2 + 02 ConvectiveVelocity^2 + FrictionVelocity^2 (-zLLMOLen)^23  MOLen  0 \n    375 FrictionVelocity^2  textotherwise\nendcases \nSensibleSurfaceHeatFlux  = BCTCVweint Cpm rhoRef \nLatentSurfaceHeatFlux    = BCTCVwqt  LatentHeatVT rhoRef \nF_eint(SensibleSurfaceHeatFlux)   = fracSensibleSurfaceHeatFluxCpm       = BCTCVweint rhoRef \nF_qt(LatentSurfaceHeatFlux)       = fracLatentSurfaceHeatFluxLatentHeatVT = BCTCVwqt   rhoRef \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nMonin-Obhukov length (MOLen).\nConvective velocity (SDioConvectiveVelocity).\nFriction velocity (FrictionVelocity).\nLatent heat (LatentHeatVT).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"and equation \\eqref{eq:TopPercentile} represents the mean of the top x-fraction of a standard normal distribution (Neggers et al., 2009).","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nPhi^-1(x)  = textinverse cumulative distribution function labeleqInverseCDF \nmathcal D(x) = frac1sqrt2pi x exp- frac12 (Phi^-1(1-x))^2   labeleqTopPercentile \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#Area-fraction-1","page":"EDMF equations","title":"Area fraction","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nc_frac = 01 quad\nBCBaSDia =\nbegincases\n    1-c_frac  i = iEnv \n  fracc_fracNsd  i ne iEnv\nendcases quad\nBCTaSDia =\nbegincases\n    1-c_frac  i = iEnv \n  fracc_fracNsd  i ne iEnv\nendcases\nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#st-order-moments-1","page":"EDMF equations","title":"1st order moments","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Top boundary","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nBCTSDiw           = 0 \nPD_z BCTSDiqt   = 0 \nPD_z BCTSDieint = 0 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Bottom boundary","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"todo: Todo\nNeed value for C_eint.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nBCBSDiw     = 0 \n- SDiKh PD_z BCBSDiqt   = TCVwqt   + mathcal D(aSDia) sqrtC_qt^2   WindSpeed^2Gamma_phi(TCVwqt   TCVwqt   ) \n- SDiKh PD_z BCBSDieint = TCVweint + mathcal D(aSDia) sqrtC_eint^2 WindSpeed^2Gamma_phi(TCVweint TCVweint ) \nC_qt = 0001133 \nC_ThetaLiqIce = 0001094 \nC_eint =  \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable/function definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"BC functions mathcal D.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#nd-order-moments-1","page":"EDMF equations","title":"2nd order moments","text":"","category":"section"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Top boundary","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nBCTSDiTKE                          = 0 \nPD_z BCTIntraCVSDiqtqt        = 0 \nPD_z BCTIntraCVSDieinteint    = 0 \nPD_z BCTIntraCVSDieintqt      = 0 \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"todo: Todo\nCurrently, we only account for the intra sub-domain covariance, but we would like to also account for the inter sub-domain covariance for all but the TKE.","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"Bottom boundary","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"beginalign\nBCBSDiTKE                    = Gamma_TKE \nBCBIntraCVSDiqtqt        = Gamma_phi(TCVwqt   TCVwqt   ) \nBCBIntraCVSDieinteint    = Gamma_phi(TCVwqt   TCVweint ) \nBCBIntraCVSDieintqt      = Gamma_phi(TCVweint TCVweint ) \nendalign","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"where additional variable/function definitions are in:","category":"page"},{"location":"Theory/Atmos/EDMFEquations/#","page":"EDMF equations","title":"EDMF equations","text":"BC functions Gamma_TKE, Gamma_phi, F_eint, SensibleSurfaceHeatFlux, F_qt, LatentSurfaceHeatFlux.","category":"page"},{"location":"Contributing/#Contributing-1","page":"Contribution guide","title":"Contributing","text":"","category":"section"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"Thank you for considering contributing to the ClimateMachine! We encourage Pull Requests (PRs). Please do not hesitate to ask as questions if you're unsure about how to help.","category":"page"},{"location":"Contributing/#What-to-contribute?-1","page":"Contribution guide","title":"What to contribute?","text":"","category":"section"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"The easiest way to contribute is by running the ClimateMachine, identifying problems and opening issues.\nYou can tackle an existing issue. We have a list of good first issues.\nWrite an example or tutorial.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature if you need it to use the ClimateMachine.","category":"page"},{"location":"Contributing/#Using-git-1","page":"Contribution guide","title":"Using git","text":"","category":"section"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"If you are unfamiliar with git and version control, the following guides will be helpful:","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"Atlassian (bitbucket) git tutorials. A set of tips and tricks for getting started with git.\nGitHub's git tutorials. A set of resources from GitHub to learn git.","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"We provide a brief guide here.","category":"page"},{"location":"Contributing/#Identity-1","page":"Contribution guide","title":"Identity","text":"","category":"section"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"First make sure git knows your name and email address:","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"$ git config --global user.name \"A. Climate Developer\"\n$ git config --global user.email \"a.climate.developer@eg.com\"","category":"page"},{"location":"Contributing/#Forks-and-branches-1","page":"Contribution guide","title":"Forks and branches","text":"","category":"section"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"Create your own fork of the ClimateMachine on GitHub and check out your copy:","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"$ git clone https://github.com/<username>/ClimateMachine.jl.git\n$ cd ClimateMachine.jl\n$ git remote add upstream https://github.com/CliMA/ClimateMachine.jl.git","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"Now you have two remote repositories – origin, which is your fork of the ClimateMachine, and upstream, which is the main ClimateMachine.jl repository.","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"Create a branch for your feature; this will hold your contribution:","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"$ git checkout -b <branchname>","category":"page"},{"location":"Contributing/#Develop-your-feature-1","page":"Contribution guide","title":"Develop your feature","text":"","category":"section"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"Follow the coding style we use. Make sure you add tests for your code in test/ and appropriate documentation in the code and/or in docs/.","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"When your PR is ready for review, clean up your commit history by squashing and make sure your code is current with ClimateMachine master by rebasing.","category":"page"},{"location":"Contributing/#Squash-and-rebase-1","page":"Contribution guide","title":"Squash and rebase","text":"","category":"section"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"Use git rebase (not git merge) to sync your work:","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"$ git fetch upstream\n$ git rebase upstream/master","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"You might find it easier to squash your commits first.","category":"page"},{"location":"Contributing/#Continuous-integration-1","page":"Contribution guide","title":"Continuous integration","text":"","category":"section"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"It's time to click the button to open your PR! Fill out the template and provide a clear summary of what your PR does. When a PR is created or updated, a set of automated tests are run on the PR in our continuous integration (CI) system.","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"A ClimateMachine developer will look at your PR and provide feedback!","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"We use bors to manage the ClimateMachine repo. If you're a collaborator and have the necessary permissions, you can type bors try in a comment on a PR to have some additional tests run on that PR, or bors r+ to try and merge the code.","category":"page"},{"location":"Contributing/#Contributing-Documentation-1","page":"Contribution guide","title":"Contributing Documentation","text":"","category":"section"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"Documentation is written in Julia-flavored markdown and generated from two sources:","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"$CLIMATEMACHINE_HOME/docs/src","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"And Literate.jl tutorials:","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"$CLIMATEMACHINE_HOME/tutorials","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"To locally build the documentation you need to create a new docs project to build and install the documentation related dependencies:","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"cd $CLIMATEMACHINE_HOME\njulia --project=docs/ -e 'using Pkg; Pkg.instantiate()'\njulia --project=docs docs/make.jl","category":"page"},{"location":"Contributing/#","page":"Contribution guide","title":"Contribution guide","text":"The makefile script will generate the appropriate markdown files and static html from both the docs/src and tutorials/ directories, saving the output in docs/src/generated.","category":"page"}]
}
