<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Meshes Â· ClimateMachine</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.svg" alt="ClimateMachine logo"/></a><div class="docs-package-name"><span class="docs-autofit">ClimateMachine</span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../GettingStarted/Installation/">Installation</a></li><li><a class="tocitem" href="../../../../GettingStarted/RunningClimateMachine/">Running</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Defaults</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../GettingStarted/Atmos/">Atmosphere model configurations</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/Atmos/heldsuarez/">Dry Idealized GCM</a></li><li><a class="tocitem" href="../../../../generated/Atmos/risingbubble/">Rising Thermal Bubble</a></li></ul></li><li><span class="tocitem">Ocean</span></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Land</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-3-1"><span class="docs-label">Heat</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/Land/Heat/heat_equation/">Heat Equation</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-4-1" type="checkbox"/><label class="tocitem" for="menuitem-3-4-1"><span class="docs-label">LinearSolvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/Numerics/LinearSolvers/cg/">Conjugate Gradient</a></li><li><a class="tocitem" href="../../../../generated/Numerics/LinearSolvers/bgmres/">Batched Generalized Minimal Residual</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../generated/literate_markdown/">Notes on Literate</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to-guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../HowToGuides/Common/MoistThermodynamics/">MoistThermodynamics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../HowToGuides/Atmos/TemperatureProfiles/">TemperatureProfiles</a></li></ul></li><li><span class="tocitem">Ocean</span></li><li><span class="tocitem">Land</span></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><span class="tocitem">Meshes</span></li><li><input class="collapse-toggle" id="menuitem-4-5-2" type="checkbox"/><label class="tocitem" for="menuitem-4-5-2"><span class="docs-label">DG methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../HowToGuides/Numerics/DGmethods/how_to_make_a_balance_law/">How to make a balance law</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5-3" type="checkbox"/><label class="tocitem" for="menuitem-4-5-3"><span class="docs-label">ODE Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../HowToGuides/Numerics/ODESolvers/Timestepping/">Time-integration</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5-4" type="checkbox"/><label class="tocitem" for="menuitem-4-5-4"><span class="docs-label">Linear Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../HowToGuides/Numerics/LinearSolvers/IterativeSolvers/">Iterative Solvers</a></li></ul></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">APIs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Atmos/AtmosModel/">AtmosModel</a></li><li><a class="tocitem" href="../../../Atmos/Microphysics/">Microphysics</a></li></ul></li><li><span class="tocitem">Ocean</span></li><li><span class="tocitem">Land</span></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Common/SurfaceFluxes/">Surface Fluxes</a></li></ul></li><li><a class="tocitem" href="../../../Arrays/Arrays/">Arrays</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Diagnostics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Diagnostics/Diagnostics/">List of variables</a></li><li><a class="tocitem" href="../../../Diagnostics/InputOutput/">Input/Output</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox" checked/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">Numerics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Meshes</a><ul class="internal"><li><a class="tocitem" href="#Topologies-1"><span><code>Topologies</code></span></a></li><li><a class="tocitem" href="#Grids-1"><span><code>Grids</code></span></a></li><li><a class="tocitem" href="#Filters-1"><span><code>Filters</code></span></a></li><li><a class="tocitem" href="#Interpolation-1"><span><code>Interpolation</code></span></a></li></ul></li><li><a class="tocitem" href="../../LinearSolvers/LinearSolvers/">LinearSolvers</a></li><li><a class="tocitem" href="../../ODESolvers/ODESolvers/">ODESolvers</a></li><li><a class="tocitem" href="../../DGmethods/BalanceLawOverview/">Balance Law</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../../Contributing/">Contribution guide</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">Common</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../Theory/Common/SurfaceFluxes/">SurfaceFluxes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Atmos</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../Theory/Atmos/AtmosModel/">AtmosModel</a></li><li><a class="tocitem" href="../../../../Theory/Atmos/Microphysics/">Microphysics</a></li><li><a class="tocitem" href="../../../../Theory/Atmos/EDMFEquations/">EDMF equations</a></li><li><a class="tocitem" href="../../../../Theory/Atmos/Model/turbulence/">Turbulence</a></li><li><a class="tocitem" href="../../../../Theory/Atmos/Model/tracers/">Tracers</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Developer docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../DevDocs/CodeStyle/">Coding style</a></li><li><a class="tocitem" href="../../../../DevDocs/AcceptableUnicode/">Acceptable Unicode</a></li><li><a class="tocitem" href="../../../../DevDocs/VariableList/">Variable list</a></li><li><a class="tocitem" href="../../../../DevDocs/DiagnosticVariables/">Diagnostic variable list</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">APIs</a></li><li><a class="is-disabled">Numerics</a></li><li class="is-active"><a href>Meshes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Meshes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimateMachine.jl/blob/master/docs/src/APIs/Numerics/Meshes/Mesh.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Meshing-Stuff-1"><a class="docs-heading-anchor" href="#Meshing-Stuff-1">Meshing Stuff</a><a class="docs-heading-anchor-permalink" href="#Meshing-Stuff-1" title="Permalink"></a></h1><h2 id="Topologies-1"><a class="docs-heading-anchor" href="#Topologies-1"><code>Topologies</code></a><a class="docs-heading-anchor-permalink" href="#Topologies-1" title="Permalink"></a></h2><p>Topologies encode the connectivity of the elements, spatial domain interval and MPI communication.</p><h3 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.AbstractTopology" href="#ClimateMachine.Mesh.Topologies.AbstractTopology"><code>ClimateMachine.Mesh.Topologies.AbstractTopology</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractTopology{dim}</code></pre><p>Represents the connectivity of individual elements, with local dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.BoxElementTopology" href="#ClimateMachine.Mesh.Topologies.BoxElementTopology"><code>ClimateMachine.Mesh.Topologies.BoxElementTopology</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoxElementTopology{dim, T} &lt;: AbstractTopology{dim}</code></pre><p>The local topology of a larger MPI-distributed topology, represented by <code>dim</code>-dimensional box elements.</p><p>This contains the necessary information for the connectivity elements of the elements on the local process, along with &quot;ghost&quot; elements from neighbouring processes.</p><p><strong>Fields</strong></p><ul><li><p><code>mpicomm</code></p><p>MPI communicator for communicating with neighbouring processes.</p></li></ul><ul><li><p><code>elems</code></p><p>Range of element indices</p></li></ul><ul><li><p><code>realelems</code></p><p>Range of real (aka nonghost) element indices</p></li></ul><ul><li><p><code>ghostelems</code></p><p>Range of ghost element indices</p></li></ul><ul><li><p><code>ghostfaces</code></p><p>Ghost element to face is received; <code>ghostfaces[f,ge] == true</code> if face <code>f</code> of ghost element <code>ge</code> is received.</p></li></ul><ul><li><p><code>sendelems</code></p><p>Array of send element indices</p></li></ul><ul><li><p><code>sendfaces</code></p><p>Send element to face is sent; <code>sendfaces[f,se] == true</code> if face <code>f</code> of send element <code>se</code> is sent.</p></li></ul><ul><li><p><code>interiorelems</code></p><p>Array of real elements that do not have a ghost element as a neighbor.</p></li></ul><ul><li><p><code>exteriorelems</code></p><p>Array of real elements that have at least on ghost element as a neighbor.</p><p>Note that this is different from <code>sendelems</code> because <code>sendelems</code> duplicates elements that need to be sent to multiple neighboring processes.</p></li></ul><ul><li><p><code>elemtocoord</code></p><p>Element to vertex coordinates; <code>elemtocoord[d,i,e]</code> is the <code>d</code>th coordinate of corner <code>i</code> of element <code>e</code></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>currently coordinates always are of size 3 for <code>(x1, x2, x3)</code></p></div></div></li></ul><ul><li><p><code>elemtoelem</code></p><p>Element to neighboring element; <code>elemtoelem[f,e]</code> is the number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoelem[f,e] == e</code>.</p></li></ul><ul><li><p><code>elemtoface</code></p><p>Element to neighboring element face; <code>elemtoface[f,e]</code> is the face number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoface[f,e] == f</code>.&quot;</p></li></ul><ul><li><p><code>elemtoordr</code></p><p>element to neighboring element order; <code>elemtoordr[f,e]</code> is the ordering number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoordr[f,e] == 1</code>.</p></li></ul><ul><li><p><code>elemtobndy</code></p><p>Element to boundary number; <code>elemtobndy[f,e]</code> is the boundary number of face <code>f</code> of element <code>e</code>.  If there is a neighboring element then <code>elemtobndy[f,e] == 0</code>.</p></li></ul><ul><li><p><code>nabrtorank</code></p><p>List of the MPI ranks for the neighboring processes</p></li></ul><ul><li><p><code>nabrtorecv</code></p><p>Range in ghost elements to receive for each neighbor</p></li></ul><ul><li><p><code>nabrtosend</code></p><p>Range in <code>sendelems</code> to send for each neighbor</p></li></ul><ul><li><p><code>origsendorder</code></p><p>original order in partitioning</p></li></ul><ul><li><p><code>hasboundary</code></p><p>boolean for whether or not this topology has a boundary</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L24-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.BrickTopology" href="#ClimateMachine.Mesh.Topologies.BrickTopology"><code>ClimateMachine.Mesh.Topologies.BrickTopology</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BrickTopology{dim, T} &lt;: AbstractTopology{dim}</code></pre><p>A simple grid-based topology. This is a convenience wrapper around <a href="#ClimateMachine.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.StackedBrickTopology" href="#ClimateMachine.Mesh.Topologies.StackedBrickTopology"><code>ClimateMachine.Mesh.Topologies.StackedBrickTopology</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StackedBrickTopology{dim, T} &lt;: AbstractTopology{dim}</code></pre><p>A simple grid-based topology, where all elements on the trailing dimension are stacked to be contiguous. This is a convenience wrapper around <a href="#ClimateMachine.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L239-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.CubedShellTopology" href="#ClimateMachine.Mesh.Topologies.CubedShellTopology"><code>ClimateMachine.Mesh.Topologies.CubedShellTopology</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CubedShellTopology{T} &lt;: AbstractTopology{2}</code></pre><p>A cube-shell topology. This is a convenience wrapper around <a href="#ClimateMachine.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L226-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology" href="#ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology"><code>ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StackedCubedSphereTopology{3, T} &lt;: AbstractTopology{3}</code></pre><p>A cube-sphere topology. All elements on the same &quot;vertical&quot; dimension are stacked to be contiguous. This is a convenience wrapper around <a href="#ClimateMachine.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L255-L261">source</a></section></article><h3 id="Constructors-1"><a class="docs-heading-anchor" href="#Constructors-1">Constructors</a><a class="docs-heading-anchor-permalink" href="#Constructors-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.BrickTopology-Tuple{Any,Any}" href="#ClimateMachine.Mesh.Topologies.BrickTopology-Tuple{Any,Any}"><code>ClimateMachine.Mesh.Topologies.BrickTopology</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)</code></pre><p>Generate a brick mesh topology with coordinates given by the tuple <code>elemrange</code> and the periodic dimensions given by the <code>periodicity</code> tuple.</p><p>The elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.</p><p>By default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in <code>boundary</code>.  This will mark the nonperiodic brick faces with the given boundary number.</p><p><strong>Examples</strong></p><p>We can build a 3 by 2 element two-dimensional mesh that is periodic in the <span>$x2$</span>-direction with</p><pre><code class="language-julia">
using ClimateMachine.Topologies
using MPI
MPI.Init()
topology = BrickTopology(MPI.COMM_SELF, (2:5,4:6);
                         periodicity=(false,true),
                         boundary=((1,2),(3,4)))</code></pre><p>This returns the mesh structure for</p><pre><code class="language-none">         x2

          ^
          |
         6-  +-----+-----+-----+
          |  |     |     |     |
          |  |  3  |  4  |  5  |
          |  |     |     |     |
         5-  +-----+-----+-----+
          |  |     |     |     |
          |  |  1  |  2  |  6  |
          |  |     |     |     |
         4-  +-----+-----+-----+
          |
          +--|-----|-----|-----|--&gt; x1
             2     3     4     5</code></pre><p>For example, the (dimension by number of corners by number of elements) array <code>elemtocoord</code> gives the coordinates of the corners of each element.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtocoord
2Ã4Ã6 Array{Int64,3}:
[:, :, 1] =
 2  3  2  3
 4  4  5  5

[:, :, 2] =
 3  4  3  4
 4  4  5  5

[:, :, 3] =
 2  3  2  3
 5  5  6  6

[:, :, 4] =
 3  4  3  4
 5  5  6  6

[:, :, 5] =
 4  5  4  5
 5  5  6  6

[:, :, 6] =
 4  5  4  5
 4  4  5  5</code></pre><p>Note that the corners are listed in Cartesian order.</p><p>The (number of faces by number of elements) array <code>elemtobndy</code> gives the boundary number for each face of each element.  A zero will be given for connected faces.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtobndy
4Ã6 Array{Int64,2}:
 1  0  1  0  0  0
 0  0  0  0  2  2
 0  0  0  0  0  0
 0  0  0  0  0  0</code></pre><p>Note that the faces are listed in Cartesian order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L275-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.StackedBrickTopology-Tuple{Any,Any}" href="#ClimateMachine.Mesh.Topologies.StackedBrickTopology-Tuple{Any,Any}"><code>ClimateMachine.Mesh.Topologies.StackedBrickTopology</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">StackedBrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)</code></pre><p>Generate a stacked brick mesh topology with coordinates given by the tuple <code>elemrange</code> and the periodic dimensions given by the <code>periodicity</code> tuple.</p><p>The elements are stacked such that the elements associated with range <code>elemrange[dim]</code> are contiguous in the element ordering.</p><p>The elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.  Further, stacks are not split at MPI boundaries.</p><p>By default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in <code>boundary</code>.  This will mark the nonperiodic brick faces with the given boundary number.</p><p><strong>Examples</strong></p><p>We can build a 3 by 2 element two-dimensional mesh that is periodic in the <span>$x2$</span>-direction with</p><pre><code class="language-julia">
using ClimateMachine.Topologies
using MPI
MPI.Init()
topology = StackedBrickTopology(MPI.COMM_SELF, (2:5,4:6);
                                periodicity=(false,true),
                                boundary=((1,2),(3,4)))</code></pre><p>This returns the mesh structure stacked in the <span>$x2$</span>-direction for</p><pre><code class="language-none">         x2

          ^
          |
         6-  +-----+-----+-----+
          |  |     |     |     |
          |  |  2  |  4  |  6  |
          |  |     |     |     |
         5-  +-----+-----+-----+
          |  |     |     |     |
          |  |  1  |  3  |  5  |
          |  |     |     |     |
         4-  +-----+-----+-----+
          |
          +--|-----|-----|-----|--&gt; x1
             2     3     4     5</code></pre><p>For example, the (dimension by number of corners by number of elements) array <code>elemtocoord</code> gives the coordinates of the corners of each element.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtocoord
2Ã4Ã6 Array{Int64,3}:
[:, :, 1] =
 2  3  2  3
 4  4  5  5

[:, :, 2] =
 2  3  2  3
 5  5  6  6

[:, :, 3] =
 3  4  3  4
 4  4  5  5

[:, :, 4] =
 3  4  3  4
 5  5  6  6

[:, :, 5] =
 4  5  4  5
 4  4  5  5

[:, :, 6] =
 4  5  4  5
 5  5  6  6</code></pre><p>Note that the corners are listed in Cartesian order.</p><p>The (number of faces by number of elements) array <code>elemtobndy</code> gives the boundary number for each face of each element.  A zero will be given for connected faces.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtobndy
4Ã6 Array{Int64,2}:
 1  0  1  0  0  0
 0  0  0  0  2  2
 0  0  0  0  0  0
 0  0  0  0  0  0</code></pre><p>Note that the faces are listed in Cartesian order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L423-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.CubedShellTopology-Tuple{Any,Any,Any}" href="#ClimateMachine.Mesh.Topologies.CubedShellTopology-Tuple{Any,Any,Any}"><code>ClimateMachine.Mesh.Topologies.CubedShellTopology</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CubedShellTopology(mpicomm, Nelem, T) &lt;: AbstractTopology{dim}</code></pre><p>Generate a cubed shell mesh with the number of elements along each dimension of the cubes being <code>Nelem</code>. This topology actual creates a cube mesh, and the warping should be done after the grid is created using the <code>cubedshellwarp</code> function. The coordinates of the points will be of type <code>T</code>.</p><p>The elements of the shell are partitioned equally across the MPI ranks based on a space-filling curve.</p><p>Note that this topology is logically 2-D but embedded in a 3-D space</p><p><strong>Examples</strong></p><p>We can build a cubed shell mesh with 10 elements on each cube, total elements is <code>10 * 10 * 6 = 600</code>, with</p><pre><code class="language-julia">using ClimateMachine.Topologies
using MPI
MPI.Init()
topology = CubedShellTopology(MPI.COMM_SELF, 10, Float64)

# Typically the warping would be done after the grid is created, but the cell
# corners could be warped with...

# Shell radius = 1
x1, x2, x3 = ntuple(j-&gt;topology.elemtocoord[j, :, :], 3)
for n = 1:length(x1)
   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])
end

# Shell radius = 10
x1, x2, x3 = ntuple(j-&gt;topology.elemtocoord[j, :, :], 3)
for n = 1:length(x1)
  x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n], 10)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L712-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology-Tuple{Any,Any,Any}" href="#ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology-Tuple{Any,Any,Any}"><code>ClimateMachine.Mesh.Topologies.StackedCubedSphereTopology</code></a> â <span class="docstring-category">Method</span></header><section><div><p>StackedCubedSphereTopology(mpicomm, Nhorz, Rrange;                               boundary=(1,1)) &lt;: AbstractTopology{3}</p><p>Generate a stacked cubed sphere topology with <code>Nhorz</code> by <code>Nhorz</code> cells for each horizontal face and <code>Rrange</code> is the radius edges of the stacked elements.  This topology actual creates a cube mesh, and the warping should be done after the grid is created using the <code>cubedshellwarp</code> function. The coordinates of the points will be of type <code>eltype(Rrange)</code>. The inner boundary condition type is <code>boundary[1]</code> and the outer boundary condition type is <code>boundary[2]</code>.</p><p>The elements are stacked such that the vertical elements are contiguous in the element ordering.</p><p>The elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve. Further, stacks are not split at MPI boundaries.</p><p><strong>Examples</strong></p><p>We can build a cubed sphere mesh with 10 x 10 x 5 elements on each cube, total elements is <code>10 * 10 * 5 * 6 = 3000</code>, with</p><pre><code class="language-julia">using ClimateMachine.Topologies
using MPI
MPI.Init()
Nhorz = 10
Nstack = 5
Rrange = Float64.(accumulate(+,1:Nstack+1))
topology = StackedCubedSphereTopology(MPI.COMM_SELF, Nhorz, Rrange)

x1, x2, x3 = ntuple(j-&gt;reshape(topology.elemtocoord[j, :, :],
                            2, 2, 2, length(topology.elems)), 3)
for n = 1:length(x1)
   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])
end</code></pre><p>Note that the faces are listed in Cartesian order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L1014-L1051">source</a></section></article><h3 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.cubedshellmesh" href="#ClimateMachine.Mesh.Topologies.cubedshellmesh"><code>ClimateMachine.Mesh.Topologies.cubedshellmesh</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cubedshellmesh(T, Ne; part=1, numparts=1)</code></pre><p>Generate a cubed mesh with each of the &quot;cubes&quot; has an <code>Ne X Ne</code> grid of elements.</p><p>The mesh can optionally be partitioned into <code>numparts</code> and this returns partition <code>part</code>.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.</p><p>This mesh returns the cubed spehere in a flatten fashion for the vertex values, and a remapping is needed to embed the mesh in a 3-D space.</p><p>The mesh structures for the cubes is as follows:</p><pre><code class="language-none">x2
   ^
   |
4Ne-           +-------+
   |           |       |
   |           |   6   |
   |           |       |
3Ne-           +-------+
   |           |       |
   |           |   5   |
   |           |       |
2Ne-           +-------+
   |           |       |
   |           |   4   |
   |           |       |
 Ne-   +-------+-------+-------+
   |   |       |       |       |
   |   |   1   |   2   |   3   |
   |   |       |       |       |
  0-   +-------+-------+-------+
   |
   +---|-------|-------|------|-&gt; x1
       0      Ne      2Ne    3Ne</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L814-L856">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.cubedshellwarp" href="#ClimateMachine.Mesh.Topologies.cubedshellwarp"><code>ClimateMachine.Mesh.Topologies.cubedshellwarp</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cubedshellwarp(a, b, c, R = max(abs(a), abs(b), abs(c)))</code></pre><p>Given points <code>(a, b, c)</code> on the surface of a cube, warp the points out to a spherical shell of radius <code>R</code> based on the equiangular gnomonic grid proposed by Ronchi, Iacono, Paolucci (1996) <a href="https://doi.org/10.1006/jcph.1996.0047">https://doi.org/10.1006/jcph.1996.0047</a></p><pre><code class="language-none">@article{RonchiIaconoPaolucci1996,
  title={The ``cubed sphere&#39;&#39;: a new method for the solution of partial
         differential equations in spherical geometry},
  author={Ronchi, C. and Iacono, R. and Paolucci, P. S.},
  journal={Journal of Computational Physics},
  volume={124},
  number={1},
  pages={93--114},
  year={1996},
  doi={10.1006/jcph.1996.0047}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L916-L937">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Topologies.hasboundary" href="#ClimateMachine.Mesh.Topologies.hasboundary"><code>ClimateMachine.Mesh.Topologies.hasboundary</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hasboundary(topology::AbstractTopology)</code></pre><p>query function to check whether a topology has a boundary (i.e., not fully periodic)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Topologies.jl#L199-L204">source</a></section></article><h2 id="Grids-1"><a class="docs-heading-anchor" href="#Grids-1"><code>Grids</code></a><a class="docs-heading-anchor-permalink" href="#Grids-1" title="Permalink"></a></h2><p>Grids specify the approximation within each element, and any necessary warping.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Grids.DiscontinuousSpectralElementGrid" href="#ClimateMachine.Mesh.Grids.DiscontinuousSpectralElementGrid"><code>ClimateMachine.Mesh.Grids.DiscontinuousSpectralElementGrid</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscontinuousSpectralElementGrid(topology; FloatType, DeviceArray,
                                 polynomialorder,
                                 meshwarp = (x...)-&gt;identity(x))</code></pre><p>Generate a discontinuous spectral element (tensor product, Legendre-Gauss-Lobatto) grid/mesh from a <code>topology</code>, where the order of the elements is given by <code>polynomialorder</code>. <code>DeviceArray</code> gives the array type used to store the data (<code>CuArray</code> or <code>Array</code>), and the coordinate points will be of <code>FloatType</code>.</p><p>The optional <code>meshwarp</code> function allows the coordinate points to be warped after the mesh is created; the mesh degrees of freedom are orginally assigned using a trilinear blend of the element corner locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Grids.jl#L100-L114">source</a></section></article><h2 id="Filters-1"><a class="docs-heading-anchor" href="#Filters-1"><code>Filters</code></a><a class="docs-heading-anchor-permalink" href="#Filters-1" title="Permalink"></a></h2><p>There are methods used to cleanup state vectors.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Filters.CutoffFilter" href="#ClimateMachine.Mesh.Filters.CutoffFilter"><code>ClimateMachine.Mesh.Filters.CutoffFilter</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CutoffFilter(grid, Nc=polynomialorder(grid))</code></pre><p>Returns the spectral filter that zeros out polynomial modes greater than or equal to <code>Nc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Filters.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Filters.ExponentialFilter" href="#ClimateMachine.Mesh.Filters.ExponentialFilter"><code>ClimateMachine.Mesh.Filters.ExponentialFilter</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExponentialFilter(grid, Nc=0, s=32, Î±=-log(eps(eltype(grid))))</code></pre><p>Returns the spectral filter with the filter function</p><div>\[Ï(Î·) = xp(-Î± Î·^s)\]</div><p>where <code>s</code> is the filter order (must be even), the filter starts with polynomial order <code>Nc</code>, and <code>alpha</code> is a parameter controlling the smallest value of the filter function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Filters.jl#L41-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Filters.TMARFilter" href="#ClimateMachine.Mesh.Filters.TMARFilter"><code>ClimateMachine.Mesh.Filters.TMARFilter</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TMARFilter()</code></pre><p>Returns the truncation and mass aware rescaling nonnegativity preservation filter.  The details of this filter are described in</p><pre><code class="language-none">@article{doi:10.1175/MWR-D-16-0220.1,
  author = {Light, Devin and Durran, Dale},
  title = {Preserving Nonnegativity in Discontinuous Galerkin
           Approximations to Scalar Transport via Truncation and Mass
           Aware Rescaling (TMAR)},
  journal = {Monthly Weather Review},
  volume = {144},
  number = {12},
  pages = {4771-4786},
  year = {2016},
  doi = {10.1175/MWR-D-16-0220.1},
}</code></pre><p>Note this needs to be used with a restrictive time step or a flux correction to ensure that grid integral is conserved.</p><p><strong>Examples</strong></p><p>This filter can be applied to the 3rd and 4th fields of an <code>MPIStateArray</code> <code>Q</code> with the code</p><pre><code class="language-julia">Filters.apply!(Q, (3, 4), grid, TMARFilter())</code></pre><p>where <code>grid</code> is the associated <code>DiscontinuousSpectralElementGrid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Filters.jl#L97-L129">source</a></section></article><h2 id="Interpolation-1"><a class="docs-heading-anchor" href="#Interpolation-1"><code>Interpolation</code></a><a class="docs-heading-anchor-permalink" href="#Interpolation-1" title="Permalink"></a></h2><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Interpolation.InterpolationBrick" href="#ClimateMachine.Mesh.Interpolation.InterpolationBrick"><code>ClimateMachine.Mesh.Interpolation.InterpolationBrick</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterpolationBrick{
FT &lt;: AbstractFloat,
T &lt;: Int,
FTV &lt;: AbstractVector{FT},
FTVD &lt;: AbstractVector{FT},
TVD &lt;: AbstractVector{T},
FTA2 &lt;: Array{FT, 2},
UI8AD &lt;: AbstractArray{UInt8, 2},
UI16VD &lt;: AbstractVector{UInt16},
I32V &lt;: AbstractVector{Int32},
} &lt;: InterpolationTopology</code></pre><p>This interpolation data structure and the corresponding functions works for a brick, where stretching/compression happens only along the x1, x2 &amp; x3 axis. Here x1 = X1(Î¾1), x2 = X2(Î¾2) and x3 = X3(Î¾3).</p><p><strong>Fields</strong></p><ul><li><p><code>Nel</code></p><p>Number of elements</p></li><li><p><code>Np</code></p><p>Total number of interpolation points</p></li><li><p><code>Npl</code></p><p>Total number of interpolation points on local process</p></li><li><p><code>poly_order</code></p><p>Polynomial order of spectral element approximation</p></li><li><p><code>xbnd</code></p><p>Domain bounds in x1, x2 and x3 directions</p></li><li><p><code>x1g</code></p><p>Interpolation grid in x1 direction</p></li><li><p><code>x2g</code></p><p>Interpolation grid in x2 direction</p></li><li><p><code>x3g</code></p><p>Interpolation grid in x3 direction</p></li><li><p><code>Î¾1</code></p><p>Unique Î¾1 coordinates of interpolation points within each spectral element</p></li><li><p><code>Î¾2</code></p><p>Unique Î¾2 coordinates of interpolation points within each spectral element</p></li><li><p><code>Î¾3</code></p><p>Unique Î¾3 coordinates of interpolation points within each spectral element</p></li><li><p><code>flg</code></p><p>Flags when Î¾1/Î¾2/Î¾3 interpolation point matches with a GLL point</p></li><li><p><code>fac</code></p><p>Normalization factor</p></li><li><p><code>x1i</code></p><p>x1 interpolation grid index of interpolation points within each element on the local process</p></li><li><p><code>x2i</code></p><p>x2 interpolation grid index of interpolation points within each element on the local process</p></li><li><p><code>x3i</code></p><p>x3 interpolation grid index of interpolation points within each element on the local process</p></li><li><p><code>offset</code></p><p>Offsets for each element</p></li><li><p><code>m1_r</code></p><p>GLL points</p></li><li><p><code>m1_w</code></p><p>GLL weights</p></li><li><p><code>wb</code></p><p>Barycentric weights</p></li><li><p><code>Np_all</code></p><p>Number of interpolation points on each of the processes</p></li><li><p><code>x1i_all</code></p><p>x1 interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li><li><p><code>x2i_all</code></p><p>x2 interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li><li><p><code>x3i_all</code></p><p>x3 interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li></ul><p><strong>Usage</strong></p><pre><code class="language-none">InterpolationBrick(grid::DiscontinuousSpectralElementGrid{FT}, xbnd::Array{FT,2}, xres) where FT &lt;: AbstractFloat</code></pre><p>This interpolation structure and the corresponding functions works for a brick, where stretching/compression happens only along the x1, x2 &amp; x3 axis. Here x1 = X1(Î¾1), x2 = X2(Î¾2) and x3 = X3(Î¾3).</p><p><strong>Arguments for the inner constructor</strong></p><ul><li><code>grid</code>: DiscontinousSpectralElementGrid</li><li><code>xbnd</code>: Domain boundaries in x1, x2 and x3 directions</li><li><code>xres</code>: Resolution of the interpolation grid in x1, x2 and x3 directions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Interpolation.jl#L27-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Interpolation.InterpolationCubedSphere" href="#ClimateMachine.Mesh.Interpolation.InterpolationCubedSphere"><code>ClimateMachine.Mesh.Interpolation.InterpolationCubedSphere</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterpolationCubedSphere{
FT &lt;: AbstractFloat,
T &lt;: Int,
FTV &lt;: AbstractVector{FT},
FTVD &lt;: AbstractVector{FT},
TVD &lt;: AbstractVector{T},
UI8AD &lt;: AbstractArray{UInt8, 2},
UI16VD &lt;: AbstractVector{UInt16},
I32V &lt;: AbstractVector{Int32},
} &lt;: InterpolationTopology</code></pre><p>This interpolation structure and the corresponding functions works for a cubed sphere topology. The data is interpolated along a lat/long/rad grid.</p><p>-90â°  â¤ lat  â¤ 90â°</p><p>-180â° â¤ long â¤ 180â°</p><p>Ráµ¢ â¤ r â¤ Râ</p><p><strong>Fields</strong></p><ul><li><p><code>Nel</code></p><p>Number of elements</p></li><li><p><code>Np</code></p><p>Number of interpolation points</p></li><li><p><code>Npl</code></p><p>Number of interpolation points on local process</p></li><li><p><code>poly_order</code></p><p>Polynomial order of spectral element approximation</p></li><li><p><code>n_rad</code></p><p>Number of interpolation points in radial direction</p></li><li><p><code>n_lat</code></p><p>Number of interpolation points in lat direction</p></li><li><p><code>n_long</code></p><p>Number of interpolation points in long direction</p></li><li><p><code>rad_grd</code></p><p>Interpolation grid in radial direction</p></li><li><p><code>lat_grd</code></p><p>Interpolation grid in lat direction</p></li><li><p><code>long_grd</code></p><p>Interpolation grid in long direction</p></li><li><p><code>Î¾1</code></p><p>Device array containing Î¾1 coordinates of interpolation points within each element</p></li><li><p><code>Î¾2</code></p><p>Device array containing Î¾2 coordinates of interpolation points within each element</p></li><li><p><code>Î¾3</code></p><p>Device array containing Î¾3 coordinates of interpolation points within each element</p></li><li><p><code>flg</code></p><p>flags when Î¾1/Î¾2/Î¾3 interpolation point matches with a GLL point</p></li><li><p><code>fac</code></p><p>Normalization factor</p></li><li><p><code>radi</code></p><p>Radial coordinates of interpolation points withing each element</p></li><li><p><code>lati</code></p><p>Latitude coordinates of interpolation points withing each element</p></li><li><p><code>longi</code></p><p>Longitude coordinates of interpolation points withing each element</p></li><li><p><code>offset</code></p><p>Offsets for each element</p></li><li><p><code>m1_r</code></p><p>GLL points</p></li><li><p><code>m1_w</code></p><p>GLL weights</p></li><li><p><code>wb</code></p><p>Barycentric weights</p></li><li><p><code>Np_all</code></p><p>Number of interpolation points on each of the processes</p></li><li><p><code>radi_all</code></p><p>Radial interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li><li><p><code>lati_all</code></p><p>Latitude interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li><li><p><code>longi_all</code></p><p>Longitude interpolation grid index of interpolation points within each element on all processes stored only on proc 0</p></li></ul><p><strong>Usage</strong></p><pre><code class="language-none">InterpolationCubedSphere(grid::DiscontinuousSpectralElementGrid, vert_range::AbstractArray{FT}, nhor::Int, lat_res::FT, long_res::FT, rad_res::FT) where {FT &lt;: AbstractFloat}</code></pre><p>This interpolation structure and the corresponding functions works for a cubed sphere topology. The data is interpolated along a lat/long/rad grid.</p><p>-90â°  â¤ lat  â¤ 90â°</p><p>-180â° â¤ long â¤ 180â°</p><p>Ráµ¢ â¤ r â¤ Râ</p><p><strong>Arguments for the inner constructor</strong></p><ul><li><code>grid</code>: DiscontinousSpectralElementGrid</li><li><code>vert_range</code>: Vertex range along the radial coordinate</li><li><code>lat_res</code>: Resolution of the interpolation grid along the latitude coordinate in radians</li><li><code>long_res</code>: Resolution of the interpolation grid along the longitude coordinate in radians</li><li><code>rad_res</code>: Resolution of the interpolation grid along the radial coordinate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Interpolation.jl#L591-L633">source</a></section></article><h3 id="Functions-2"><a class="docs-heading-anchor" href="#Functions-2">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Interpolation.interpolate_local!" href="#ClimateMachine.Mesh.Interpolation.interpolate_local!"><code>ClimateMachine.Mesh.Interpolation.interpolate_local!</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interpolate_local!(intrp_brck::InterpolationBrick{FT},
                           sv::AbstractArray{FT},
                            v::AbstractArray{FT}) where {FT &lt;: AbstractFloat}</code></pre><p>This interpolation function works for a brick, where stretching/compression happens only along the x1, x2 &amp; x3 axis. Here x1 = X1(Î¾1), x2 = X2(Î¾2) and x3 = X3(Î¾3)</p><p><strong>Arguments</strong></p><ul><li><code>intrp_brck</code>: Initialized InterpolationBrick structure</li><li><code>sv</code>: State Array consisting of various variables on the discontinuous Galerkin grid</li><li><code>v</code>:  Interpolated variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Interpolation.jl#L356-L368">source</a></section><section><div><pre><code class="language-none">interpolate_local!(intrp_cs::InterpolationCubedSphere{FT},
                         sv::AbstractArray{FT},
                          v::AbstractArray{FT}) where {FT &lt;: AbstractFloat}</code></pre><p>This interpolation function works for cubed spherical shell geometry.</p><p><strong>Arguments</strong></p><ul><li><code>intrp_cs</code>: Initialized cubed sphere structure</li><li><code>sv</code>: Array consisting of various variables on the discontinuous Galerkin grid</li><li><code>v</code>:  Array consisting of variables on the interpolated grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Interpolation.jl#L1231-L1242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Interpolation.project_cubed_sphere!" href="#ClimateMachine.Mesh.Interpolation.project_cubed_sphere!"><code>ClimateMachine.Mesh.Interpolation.project_cubed_sphere!</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">project_cubed_sphere!(intrp_cs::InterpolationCubedSphere{FT},
                             v::AbstractArray{FT},
                          uvwi::Tuple{Int,Int,Int}) where {FT &lt;: AbstractFloat}</code></pre><p>This function projects the velocity field along unit vectors in radial, lat and long directions for cubed spherical shell geometry.</p><p><strong>Fields</strong></p><ul><li><code>intrp_cs</code>: Initialized cubed sphere structure</li><li><code>v</code>: Array consisting of x1, x2 and x3 components of the vector field</li><li><code>uvwi</code>:  Tuple providing the column numbers for x1, x2 and x3 components of vector field in the array.           These columns will be replaced with projected vector fields along unit vectors in rad, lat and long directions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Interpolation.jl#L1480-L1492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateMachine.Mesh.Interpolation.accumulate_interpolated_data!" href="#ClimateMachine.Mesh.Interpolation.accumulate_interpolated_data!"><code>ClimateMachine.Mesh.Interpolation.accumulate_interpolated_data!</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">accumulate_interpolated_data!(intrp::InterpolationTopology,
                                 iv::AbstractArray{FT,2},
                                fiv::AbstractArray{FT,4}) where {FT &lt;: AbstractFloat}</code></pre><p>This interpolation function gathers interpolated data onto process # 0.</p><p><strong>Fields</strong></p><ul><li><code>intrp</code>: Initialized interpolation topology structure</li><li><code>iv</code>: Interpolated variables on local process</li><li><code>fiv</code>: Full interpolated variables accumulated on process # 0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimateMachine.jl/blob/f71b866139ba1bc262b89e1cc63dcaad5f3f966d/src/Numerics/Mesh/Interpolation.jl#L1600-L1611">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../Diagnostics/InputOutput/">Â« Input/Output</a><a class="docs-footer-nextpage" href="../../LinearSolvers/LinearSolvers/">LinearSolvers Â»</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 27 May 2020 12:31">Wednesday 27 May 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
